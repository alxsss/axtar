<?php


/**
 * Base class that represents a row from the 'sf_guard_user' table.
 *
 *
 *
 * This class was autogenerated by Propel 1.6.7 on:
 *
 * Fri Jan  9 02:13:21 2015
 *
 * @package    propel.generator.plugins.sfGuardPlugin.lib.model.om
 */
abstract class BasesfGuardUser extends BaseObject implements Persistent
{
    /**
     * Peer class name
     */
    const PEER = 'sfGuardUserPeer';

    /**
     * The Peer class.
     * Instance provides a convenient way of calling static methods on a class
     * that calling code may not be able to identify.
     * @var        sfGuardUserPeer
     */
    protected static $peer;

    /**
     * The flag var to prevent infinit loop in deep copy
     * @var       boolean
     */
    protected $startCopy = false;

    /**
     * The value for the id field.
     * @var        int
     */
    protected $id;

    /**
     * The value for the username field.
     * @var        string
     */
    protected $username;

    /**
     * The value for the algorithm field.
     * Note: this column has a database default value of: 'sha1'
     * @var        string
     */
    protected $algorithm;

    /**
     * The value for the salt field.
     * @var        string
     */
    protected $salt;

    /**
     * The value for the password field.
     * @var        string
     */
    protected $password;

    /**
     * The value for the email field.
     * @var        string
     */
    protected $email;

    /**
     * The value for the password_hint field.
     * @var        string
     */
    protected $password_hint;

    /**
     * The value for the created_at field.
     * @var        string
     */
    protected $created_at;

    /**
     * The value for the last_login field.
     * @var        string
     */
    protected $last_login;

    /**
     * The value for the is_active field.
     * Note: this column has a database default value of: false
     * @var        boolean
     */
    protected $is_active;

    /**
     * The value for the is_super_admin field.
     * Note: this column has a database default value of: false
     * @var        boolean
     */
    protected $is_super_admin;

    /**
     * @var        PropelObjectCollection|Biznes[] Collection to store aggregation of Biznes objects.
     */
    protected $collBizness;
    protected $collBiznessPartial;

    /**
     * @var        PropelObjectCollection|BiznesComment[] Collection to store aggregation of BiznesComment objects.
     */
    protected $collBiznesComments;
    protected $collBiznesCommentsPartial;

    /**
     * @var        PropelObjectCollection|BiznesTag[] Collection to store aggregation of BiznesTag objects.
     */
    protected $collBiznesTags;
    protected $collBiznesTagsPartial;

    /**
     * @var        PropelObjectCollection|BiznesFav[] Collection to store aggregation of BiznesFav objects.
     */
    protected $collBiznesFavs;
    protected $collBiznesFavsPartial;

    /**
     * @var        PropelObjectCollection|BiznesRate[] Collection to store aggregation of BiznesRate objects.
     */
    protected $collBiznesRates;
    protected $collBiznesRatesPartial;

    /**
     * @var        PropelObjectCollection|Album[] Collection to store aggregation of Album objects.
     */
    protected $collAlbums;
    protected $collAlbumsPartial;

    /**
     * @var        PropelObjectCollection|Friend[] Collection to store aggregation of Friend objects.
     */
    protected $collFriendsRelatedByUserId;
    protected $collFriendsRelatedByUserIdPartial;

    /**
     * @var        PropelObjectCollection|Friend[] Collection to store aggregation of Friend objects.
     */
    protected $collFriendsRelatedByFriendId;
    protected $collFriendsRelatedByFriendIdPartial;

    /**
     * @var        PropelObjectCollection|Message[] Collection to store aggregation of Message objects.
     */
    protected $collMessagesRelatedByFromUserid;
    protected $collMessagesRelatedByFromUseridPartial;

    /**
     * @var        PropelObjectCollection|Message[] Collection to store aggregation of Message objects.
     */
    protected $collMessagesRelatedByToUserid;
    protected $collMessagesRelatedByToUseridPartial;

    /**
     * @var        PropelObjectCollection|Photo[] Collection to store aggregation of Photo objects.
     */
    protected $collPhotos;
    protected $collPhotosPartial;

    /**
     * @var        PropelObjectCollection|PhotoComment[] Collection to store aggregation of PhotoComment objects.
     */
    protected $collPhotoComments;
    protected $collPhotoCommentsPartial;

    /**
     * @var        PropelObjectCollection|PhotoTag[] Collection to store aggregation of PhotoTag objects.
     */
    protected $collPhotoTags;
    protected $collPhotoTagsPartial;

    /**
     * @var        PropelObjectCollection|PhotoFav[] Collection to store aggregation of PhotoFav objects.
     */
    protected $collPhotoFavs;
    protected $collPhotoFavsPartial;

    /**
     * @var        PropelObjectCollection|PhotoVote[] Collection to store aggregation of PhotoVote objects.
     */
    protected $collPhotoVotes;
    protected $collPhotoVotesPartial;

    /**
     * @var        PropelObjectCollection|PhotoRate[] Collection to store aggregation of PhotoRate objects.
     */
    protected $collPhotoRates;
    protected $collPhotoRatesPartial;

    /**
     * @var        PropelObjectCollection|SchoolUser[] Collection to store aggregation of SchoolUser objects.
     */
    protected $collSchoolUsers;
    protected $collSchoolUsersPartial;

    /**
     * @var        PropelObjectCollection|Updates[] Collection to store aggregation of Updates objects.
     */
    protected $collUpdatess;
    protected $collUpdatessPartial;

    /**
     * @var        PropelObjectCollection|Ignorelist[] Collection to store aggregation of Ignorelist objects.
     */
    protected $collIgnorelistsRelatedByUserId;
    protected $collIgnorelistsRelatedByUserIdPartial;

    /**
     * @var        PropelObjectCollection|Ignorelist[] Collection to store aggregation of Ignorelist objects.
     */
    protected $collIgnorelistsRelatedByIgnoredUserId;
    protected $collIgnorelistsRelatedByIgnoredUserIdPartial;

    /**
     * @var        PropelObjectCollection|Sessions[] Collection to store aggregation of Sessions objects.
     */
    protected $collSessionss;
    protected $collSessionssPartial;

    /**
     * @var        PropelObjectCollection|Guest[] Collection to store aggregation of Guest objects.
     */
    protected $collGuestsRelatedByUserId;
    protected $collGuestsRelatedByUserIdPartial;

    /**
     * @var        PropelObjectCollection|Guest[] Collection to store aggregation of Guest objects.
     */
    protected $collGuestsRelatedByGuestId;
    protected $collGuestsRelatedByGuestIdPartial;

    /**
     * @var        PropelObjectCollection|GameUser[] Collection to store aggregation of GameUser objects.
     */
    protected $collGameUsers;
    protected $collGameUsersPartial;

    /**
     * @var        PropelObjectCollection|Music[] Collection to store aggregation of Music objects.
     */
    protected $collMusics;
    protected $collMusicsPartial;

    /**
     * @var        PropelObjectCollection|Playlist[] Collection to store aggregation of Playlist objects.
     */
    protected $collPlaylists;
    protected $collPlaylistsPartial;

    /**
     * @var        PropelObjectCollection|PlaylistComment[] Collection to store aggregation of PlaylistComment objects.
     */
    protected $collPlaylistComments;
    protected $collPlaylistCommentsPartial;

    /**
     * @var        PropelObjectCollection|PlaylistFav[] Collection to store aggregation of PlaylistFav objects.
     */
    protected $collPlaylistFavs;
    protected $collPlaylistFavsPartial;

    /**
     * @var        PropelObjectCollection|YtvideoFav[] Collection to store aggregation of YtvideoFav objects.
     */
    protected $collYtvideoFavs;
    protected $collYtvideoFavsPartial;

    /**
     * @var        PropelObjectCollection|Videolist[] Collection to store aggregation of Videolist objects.
     */
    protected $collVideolists;
    protected $collVideolistsPartial;

    /**
     * @var        PropelObjectCollection|UserLink[] Collection to store aggregation of UserLink objects.
     */
    protected $collUserLinks;
    protected $collUserLinksPartial;

    /**
     * @var        PropelObjectCollection|UserLinkComment[] Collection to store aggregation of UserLinkComment objects.
     */
    protected $collUserLinkComments;
    protected $collUserLinkCommentsPartial;

    /**
     * @var        PropelObjectCollection|sfGuardUserPermission[] Collection to store aggregation of sfGuardUserPermission objects.
     */
    protected $collsfGuardUserPermissions;
    protected $collsfGuardUserPermissionsPartial;

    /**
     * @var        PropelObjectCollection|sfGuardUserGroup[] Collection to store aggregation of sfGuardUserGroup objects.
     */
    protected $collsfGuardUserGroups;
    protected $collsfGuardUserGroupsPartial;

    /**
     * @var        PropelObjectCollection|sfGuardRememberKey[] Collection to store aggregation of sfGuardRememberKey objects.
     */
    protected $collsfGuardRememberKeys;
    protected $collsfGuardRememberKeysPartial;

    /**
     * @var        PropelObjectCollection|sfGuardUserProfile[] Collection to store aggregation of sfGuardUserProfile objects.
     */
    protected $collsfGuardUserProfiles;
    protected $collsfGuardUserProfilesPartial;

    /**
     * @var        PropelObjectCollection|sfGuardUserStatus[] Collection to store aggregation of sfGuardUserStatus objects.
     */
    protected $collsfGuardUserStatuss;
    protected $collsfGuardUserStatussPartial;

    /**
     * @var        PropelObjectCollection|sfGuardUserStatusComment[] Collection to store aggregation of sfGuardUserStatusComment objects.
     */
    protected $collsfGuardUserStatusComments;
    protected $collsfGuardUserStatusCommentsPartial;

    /**
     * @var        PropelObjectCollection|sfSocialEvent[] Collection to store aggregation of sfSocialEvent objects.
     */
    protected $collsfSocialEvents;
    protected $collsfSocialEventsPartial;

    /**
     * @var        PropelObjectCollection|sfSocialEventInvite[] Collection to store aggregation of sfSocialEventInvite objects.
     */
    protected $collsfSocialEventInvitesRelatedByUserId;
    protected $collsfSocialEventInvitesRelatedByUserIdPartial;

    /**
     * @var        PropelObjectCollection|sfSocialEventInvite[] Collection to store aggregation of sfSocialEventInvite objects.
     */
    protected $collsfSocialEventInvitesRelatedByUserFrom;
    protected $collsfSocialEventInvitesRelatedByUserFromPartial;

    /**
     * @var        PropelObjectCollection|sfSocialEventUser[] Collection to store aggregation of sfSocialEventUser objects.
     */
    protected $collsfSocialEventUsers;
    protected $collsfSocialEventUsersPartial;

    /**
     * @var        PropelObjectCollection|sfSocialGroup[] Collection to store aggregation of sfSocialGroup objects.
     */
    protected $collsfSocialGroups;
    protected $collsfSocialGroupsPartial;

    /**
     * @var        PropelObjectCollection|sfSocialGroupInvite[] Collection to store aggregation of sfSocialGroupInvite objects.
     */
    protected $collsfSocialGroupInvitesRelatedByUserId;
    protected $collsfSocialGroupInvitesRelatedByUserIdPartial;

    /**
     * @var        PropelObjectCollection|sfSocialGroupInvite[] Collection to store aggregation of sfSocialGroupInvite objects.
     */
    protected $collsfSocialGroupInvitesRelatedByUserFrom;
    protected $collsfSocialGroupInvitesRelatedByUserFromPartial;

    /**
     * @var        PropelObjectCollection|sfSocialGroupUser[] Collection to store aggregation of sfSocialGroupUser objects.
     */
    protected $collsfSocialGroupUsers;
    protected $collsfSocialGroupUsersPartial;

    /**
     * @var        PropelObjectCollection|GroupStatusComment[] Collection to store aggregation of GroupStatusComment objects.
     */
    protected $collGroupStatusComments;
    protected $collGroupStatusCommentsPartial;

    /**
     * @var        PropelObjectCollection|EventStatus[] Collection to store aggregation of EventStatus objects.
     */
    protected $collEventStatuss;
    protected $collEventStatussPartial;

    /**
     * Flag to prevent endless save loop, if this object is referenced
     * by another object which falls in this transaction.
     * @var        boolean
     */
    protected $alreadyInSave = false;

    /**
     * Flag to prevent endless validation loop, if this object is referenced
     * by another object which falls in this transaction.
     * @var        boolean
     */
    protected $alreadyInValidation = false;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $biznessScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $biznesCommentsScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $biznesTagsScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $biznesFavsScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $biznesRatesScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $albumsScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $friendsRelatedByUserIdScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $friendsRelatedByFriendIdScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $messagesRelatedByFromUseridScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $messagesRelatedByToUseridScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $photosScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $photoCommentsScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $photoTagsScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $photoFavsScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $photoVotesScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $photoRatesScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $schoolUsersScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $updatessScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $ignorelistsRelatedByUserIdScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $ignorelistsRelatedByIgnoredUserIdScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $sessionssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $guestsRelatedByUserIdScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $guestsRelatedByGuestIdScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $gameUsersScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $musicsScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $playlistsScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $playlistCommentsScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $playlistFavsScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $ytvideoFavsScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $videolistsScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $userLinksScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $userLinkCommentsScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $sfGuardUserPermissionsScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $sfGuardUserGroupsScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $sfGuardRememberKeysScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $sfGuardUserProfilesScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $sfGuardUserStatussScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $sfGuardUserStatusCommentsScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $sfSocialEventsScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $sfSocialEventInvitesRelatedByUserIdScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $sfSocialEventInvitesRelatedByUserFromScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $sfSocialEventUsersScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $sfSocialGroupsScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $sfSocialGroupInvitesRelatedByUserIdScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $sfSocialGroupInvitesRelatedByUserFromScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $sfSocialGroupUsersScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $groupStatusCommentsScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var		PropelObjectCollection
     */
    protected $eventStatussScheduledForDeletion = null;

    /**
     * Applies default values to this object.
     * This method should be called from the object's constructor (or
     * equivalent initialization method).
     * @see        __construct()
     */
    public function applyDefaultValues()
    {
        $this->algorithm = 'sha1';
        $this->is_active = false;
        $this->is_super_admin = false;
    }

    /**
     * Initializes internal state of BasesfGuardUser object.
     * @see        applyDefaults()
     */
    public function __construct()
    {
        parent::__construct();
        $this->applyDefaultValues();
    }

    /**
     * Get the [id] column value.
     *
     * @return int
     */
    public function getId()
    {
        return $this->id;
    }

    /**
     * Get the [username] column value.
     *
     * @return string
     */
    public function getUsername()
    {
        return $this->username;
    }

    /**
     * Get the [algorithm] column value.
     *
     * @return string
     */
    public function getAlgorithm()
    {
        return $this->algorithm;
    }

    /**
     * Get the [salt] column value.
     *
     * @return string
     */
    public function getSalt()
    {
        return $this->salt;
    }

    /**
     * Get the [password] column value.
     *
     * @return string
     */
    public function getPassword()
    {
        return $this->password;
    }

    /**
     * Get the [email] column value.
     *
     * @return string
     */
    public function getEmail()
    {
        return $this->email;
    }

    /**
     * Get the [password_hint] column value.
     *
     * @return string
     */
    public function getPasswordHint()
    {
        return $this->password_hint;
    }

    /**
     * Get the [optionally formatted] temporal [created_at] column value.
     *
     *
     * @param string $format The date/time format string (either date()-style or strftime()-style).
     *				 If format is null, then the raw DateTime object will be returned.
     * @return mixed Formatted date/time value as string or DateTime object (if format is null), null if column is null, and 0 if column value is 0000-00-00 00:00:00
     * @throws PropelException - if unable to parse/validate the date/time value.
     */
    public function getCreatedAt($format = 'Y-m-d H:i:s')
    {
        if ($this->created_at === null) {
            return null;
        }

        if ($this->created_at === '0000-00-00 00:00:00') {
            // while technically this is not a default value of null,
            // this seems to be closest in meaning.
            return null;
        } else {
            try {
                $dt = new DateTime($this->created_at);
            } catch (Exception $x) {
                throw new PropelException("Internally stored date/time/timestamp value could not be converted to DateTime: " . var_export($this->created_at, true), $x);
            }
        }

        if ($format === null) {
            // Because propel.useDateTimeClass is true, we return a DateTime object.
            return $dt;
        } elseif (strpos($format, '%') !== false) {
            return strftime($format, $dt->format('U'));
        } else {
            return $dt->format($format);
        }
    }

    /**
     * Get the [optionally formatted] temporal [last_login] column value.
     *
     *
     * @param string $format The date/time format string (either date()-style or strftime()-style).
     *				 If format is null, then the raw DateTime object will be returned.
     * @return mixed Formatted date/time value as string or DateTime object (if format is null), null if column is null, and 0 if column value is 0000-00-00 00:00:00
     * @throws PropelException - if unable to parse/validate the date/time value.
     */
    public function getLastLogin($format = 'Y-m-d H:i:s')
    {
        if ($this->last_login === null) {
            return null;
        }

        if ($this->last_login === '0000-00-00 00:00:00') {
            // while technically this is not a default value of null,
            // this seems to be closest in meaning.
            return null;
        } else {
            try {
                $dt = new DateTime($this->last_login);
            } catch (Exception $x) {
                throw new PropelException("Internally stored date/time/timestamp value could not be converted to DateTime: " . var_export($this->last_login, true), $x);
            }
        }

        if ($format === null) {
            // Because propel.useDateTimeClass is true, we return a DateTime object.
            return $dt;
        } elseif (strpos($format, '%') !== false) {
            return strftime($format, $dt->format('U'));
        } else {
            return $dt->format($format);
        }
    }

    /**
     * Get the [is_active] column value.
     *
     * @return boolean
     */
    public function getIsActive()
    {
        return $this->is_active;
    }

    /**
     * Get the [is_super_admin] column value.
     *
     * @return boolean
     */
    public function getIsSuperAdmin()
    {
        return $this->is_super_admin;
    }

    /**
     * Set the value of [id] column.
     *
     * @param int $v new value
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function setId($v)
    {
        if ($v !== null) {
            $v = (int) $v;
        }

        if ($this->id !== $v) {
            $this->id = $v;
            $this->modifiedColumns[] = sfGuardUserPeer::ID;
        }


        return $this;
    } // setId()

    /**
     * Set the value of [username] column.
     *
     * @param string $v new value
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function setUsername($v)
    {
        if ($v !== null) {
            $v = (string) $v;
        }

        if ($this->username !== $v) {
            $this->username = $v;
            $this->modifiedColumns[] = sfGuardUserPeer::USERNAME;
        }


        return $this;
    } // setUsername()

    /**
     * Set the value of [algorithm] column.
     *
     * @param string $v new value
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function setAlgorithm($v)
    {
        if ($v !== null) {
            $v = (string) $v;
        }

        if ($this->algorithm !== $v) {
            $this->algorithm = $v;
            $this->modifiedColumns[] = sfGuardUserPeer::ALGORITHM;
        }


        return $this;
    } // setAlgorithm()

    /**
     * Set the value of [salt] column.
     *
     * @param string $v new value
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function setSalt($v)
    {
        if ($v !== null) {
            $v = (string) $v;
        }

        if ($this->salt !== $v) {
            $this->salt = $v;
            $this->modifiedColumns[] = sfGuardUserPeer::SALT;
        }


        return $this;
    } // setSalt()

    /**
     * Set the value of [password] column.
     *
     * @param string $v new value
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function setPassword($v)
    {
        if ($v !== null) {
            $v = (string) $v;
        }

        if ($this->password !== $v) {
            $this->password = $v;
            $this->modifiedColumns[] = sfGuardUserPeer::PASSWORD;
        }


        return $this;
    } // setPassword()

    /**
     * Set the value of [email] column.
     *
     * @param string $v new value
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function setEmail($v)
    {
        if ($v !== null) {
            $v = (string) $v;
        }

        if ($this->email !== $v) {
            $this->email = $v;
            $this->modifiedColumns[] = sfGuardUserPeer::EMAIL;
        }


        return $this;
    } // setEmail()

    /**
     * Set the value of [password_hint] column.
     *
     * @param string $v new value
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function setPasswordHint($v)
    {
        if ($v !== null) {
            $v = (string) $v;
        }

        if ($this->password_hint !== $v) {
            $this->password_hint = $v;
            $this->modifiedColumns[] = sfGuardUserPeer::PASSWORD_HINT;
        }


        return $this;
    } // setPasswordHint()

    /**
     * Sets the value of [created_at] column to a normalized version of the date/time value specified.
     *
     * @param mixed $v string, integer (timestamp), or DateTime value.
     *               Empty strings are treated as null.
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function setCreatedAt($v)
    {
        $dt = PropelDateTime::newInstance($v, null, 'DateTime');
        if ($this->created_at !== null || $dt !== null) {
            $currentDateAsString = ($this->created_at !== null && $tmpDt = new DateTime($this->created_at)) ? $tmpDt->format('Y-m-d H:i:s') : null;
            $newDateAsString = $dt ? $dt->format('Y-m-d H:i:s') : null;
            if ($currentDateAsString !== $newDateAsString) {
                $this->created_at = $newDateAsString;
                $this->modifiedColumns[] = sfGuardUserPeer::CREATED_AT;
            }
        } // if either are not null


        return $this;
    } // setCreatedAt()

    /**
     * Sets the value of [last_login] column to a normalized version of the date/time value specified.
     *
     * @param mixed $v string, integer (timestamp), or DateTime value.
     *               Empty strings are treated as null.
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function setLastLogin($v)
    {
        $dt = PropelDateTime::newInstance($v, null, 'DateTime');
        if ($this->last_login !== null || $dt !== null) {
            $currentDateAsString = ($this->last_login !== null && $tmpDt = new DateTime($this->last_login)) ? $tmpDt->format('Y-m-d H:i:s') : null;
            $newDateAsString = $dt ? $dt->format('Y-m-d H:i:s') : null;
            if ($currentDateAsString !== $newDateAsString) {
                $this->last_login = $newDateAsString;
                $this->modifiedColumns[] = sfGuardUserPeer::LAST_LOGIN;
            }
        } // if either are not null


        return $this;
    } // setLastLogin()

    /**
     * Sets the value of the [is_active] column.
     * Non-boolean arguments are converted using the following rules:
     *   * 1, '1', 'true',  'on',  and 'yes' are converted to boolean true
     *   * 0, '0', 'false', 'off', and 'no'  are converted to boolean false
     * Check on string values is case insensitive (so 'FaLsE' is seen as 'false').
     *
     * @param boolean|integer|string $v The new value
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function setIsActive($v)
    {
        if ($v !== null) {
            if (is_string($v)) {
                $v = in_array(strtolower($v), array('false', 'off', '-', 'no', 'n', '0', '')) ? false : true;
            } else {
                $v = (boolean) $v;
            }
        }

        if ($this->is_active !== $v) {
            $this->is_active = $v;
            $this->modifiedColumns[] = sfGuardUserPeer::IS_ACTIVE;
        }


        return $this;
    } // setIsActive()

    /**
     * Sets the value of the [is_super_admin] column.
     * Non-boolean arguments are converted using the following rules:
     *   * 1, '1', 'true',  'on',  and 'yes' are converted to boolean true
     *   * 0, '0', 'false', 'off', and 'no'  are converted to boolean false
     * Check on string values is case insensitive (so 'FaLsE' is seen as 'false').
     *
     * @param boolean|integer|string $v The new value
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function setIsSuperAdmin($v)
    {
        if ($v !== null) {
            if (is_string($v)) {
                $v = in_array(strtolower($v), array('false', 'off', '-', 'no', 'n', '0', '')) ? false : true;
            } else {
                $v = (boolean) $v;
            }
        }

        if ($this->is_super_admin !== $v) {
            $this->is_super_admin = $v;
            $this->modifiedColumns[] = sfGuardUserPeer::IS_SUPER_ADMIN;
        }


        return $this;
    } // setIsSuperAdmin()

    /**
     * Indicates whether the columns in this object are only set to default values.
     *
     * This method can be used in conjunction with isModified() to indicate whether an object is both
     * modified _and_ has some values set which are non-default.
     *
     * @return boolean Whether the columns in this object are only been set with default values.
     */
    public function hasOnlyDefaultValues()
    {
            if ($this->algorithm !== 'sha1') {
                return false;
            }

            if ($this->is_active !== false) {
                return false;
            }

            if ($this->is_super_admin !== false) {
                return false;
            }

        // otherwise, everything was equal, so return true
        return true;
    } // hasOnlyDefaultValues()

    /**
     * Hydrates (populates) the object variables with values from the database resultset.
     *
     * An offset (0-based "start column") is specified so that objects can be hydrated
     * with a subset of the columns in the resultset rows.  This is needed, for example,
     * for results of JOIN queries where the resultset row includes columns from two or
     * more tables.
     *
     * @param array $row The row returned by PDOStatement->fetch(PDO::FETCH_NUM)
     * @param int $startcol 0-based offset column which indicates which restultset column to start with.
     * @param boolean $rehydrate Whether this object is being re-hydrated from the database.
     * @return int             next starting column
     * @throws PropelException - Any caught Exception will be rewrapped as a PropelException.
     */
    public function hydrate($row, $startcol = 0, $rehydrate = false)
    {
        try {

            $this->id = ($row[$startcol + 0] !== null) ? (int) $row[$startcol + 0] : null;
            $this->username = ($row[$startcol + 1] !== null) ? (string) $row[$startcol + 1] : null;
            $this->algorithm = ($row[$startcol + 2] !== null) ? (string) $row[$startcol + 2] : null;
            $this->salt = ($row[$startcol + 3] !== null) ? (string) $row[$startcol + 3] : null;
            $this->password = ($row[$startcol + 4] !== null) ? (string) $row[$startcol + 4] : null;
            $this->email = ($row[$startcol + 5] !== null) ? (string) $row[$startcol + 5] : null;
            $this->password_hint = ($row[$startcol + 6] !== null) ? (string) $row[$startcol + 6] : null;
            $this->created_at = ($row[$startcol + 7] !== null) ? (string) $row[$startcol + 7] : null;
            $this->last_login = ($row[$startcol + 8] !== null) ? (string) $row[$startcol + 8] : null;
            $this->is_active = ($row[$startcol + 9] !== null) ? (boolean) $row[$startcol + 9] : null;
            $this->is_super_admin = ($row[$startcol + 10] !== null) ? (boolean) $row[$startcol + 10] : null;
            $this->resetModified();

            $this->setNew(false);

            if ($rehydrate) {
                $this->ensureConsistency();
            }

            return $startcol + 11; // 11 = sfGuardUserPeer::NUM_HYDRATE_COLUMNS.

        } catch (Exception $e) {
            throw new PropelException("Error populating sfGuardUser object", $e);
        }
    }

    /**
     * Checks and repairs the internal consistency of the object.
     *
     * This method is executed after an already-instantiated object is re-hydrated
     * from the database.  It exists to check any foreign keys to make sure that
     * the objects related to the current object are correct based on foreign key.
     *
     * You can override this method in the stub class, but you should always invoke
     * the base method from the overridden method (i.e. parent::ensureConsistency()),
     * in case your model changes.
     *
     * @throws PropelException
     */
    public function ensureConsistency()
    {

    } // ensureConsistency

    /**
     * Reloads this object from datastore based on primary key and (optionally) resets all associated objects.
     *
     * This will only work if the object has been saved and has a valid primary key set.
     *
     * @param boolean $deep (optional) Whether to also de-associated any related objects.
     * @param PropelPDO $con (optional) The PropelPDO connection to use.
     * @return void
     * @throws PropelException - if this object is deleted, unsaved or doesn't have pk match in db
     */
    public function reload($deep = false, PropelPDO $con = null)
    {
        if ($this->isDeleted()) {
            throw new PropelException("Cannot reload a deleted object.");
        }

        if ($this->isNew()) {
            throw new PropelException("Cannot reload an unsaved object.");
        }

        if ($con === null) {
            $con = Propel::getConnection(sfGuardUserPeer::DATABASE_NAME, Propel::CONNECTION_READ);
        }

        // We don't need to alter the object instance pool; we're just modifying this instance
        // already in the pool.

        $stmt = sfGuardUserPeer::doSelectStmt($this->buildPkeyCriteria(), $con);
        $row = $stmt->fetch(PDO::FETCH_NUM);
        $stmt->closeCursor();
        if (!$row) {
            throw new PropelException('Cannot find matching row in the database to reload object values.');
        }
        $this->hydrate($row, 0, true); // rehydrate

        if ($deep) {  // also de-associate any related objects?

            $this->collBizness = null;

            $this->collBiznesComments = null;

            $this->collBiznesTags = null;

            $this->collBiznesFavs = null;

            $this->collBiznesRates = null;

            $this->collAlbums = null;

            $this->collFriendsRelatedByUserId = null;

            $this->collFriendsRelatedByFriendId = null;

            $this->collMessagesRelatedByFromUserid = null;

            $this->collMessagesRelatedByToUserid = null;

            $this->collPhotos = null;

            $this->collPhotoComments = null;

            $this->collPhotoTags = null;

            $this->collPhotoFavs = null;

            $this->collPhotoVotes = null;

            $this->collPhotoRates = null;

            $this->collSchoolUsers = null;

            $this->collUpdatess = null;

            $this->collIgnorelistsRelatedByUserId = null;

            $this->collIgnorelistsRelatedByIgnoredUserId = null;

            $this->collSessionss = null;

            $this->collGuestsRelatedByUserId = null;

            $this->collGuestsRelatedByGuestId = null;

            $this->collGameUsers = null;

            $this->collMusics = null;

            $this->collPlaylists = null;

            $this->collPlaylistComments = null;

            $this->collPlaylistFavs = null;

            $this->collYtvideoFavs = null;

            $this->collVideolists = null;

            $this->collUserLinks = null;

            $this->collUserLinkComments = null;

            $this->collsfGuardUserPermissions = null;

            $this->collsfGuardUserGroups = null;

            $this->collsfGuardRememberKeys = null;

            $this->collsfGuardUserProfiles = null;

            $this->collsfGuardUserStatuss = null;

            $this->collsfGuardUserStatusComments = null;

            $this->collsfSocialEvents = null;

            $this->collsfSocialEventInvitesRelatedByUserId = null;

            $this->collsfSocialEventInvitesRelatedByUserFrom = null;

            $this->collsfSocialEventUsers = null;

            $this->collsfSocialGroups = null;

            $this->collsfSocialGroupInvitesRelatedByUserId = null;

            $this->collsfSocialGroupInvitesRelatedByUserFrom = null;

            $this->collsfSocialGroupUsers = null;

            $this->collGroupStatusComments = null;

            $this->collEventStatuss = null;

        } // if (deep)
    }

    /**
     * Removes this object from datastore and sets delete attribute.
     *
     * @param PropelPDO $con
     * @return void
     * @throws PropelException
     * @throws Exception
     * @see        BaseObject::setDeleted()
     * @see        BaseObject::isDeleted()
     */
    public function delete(PropelPDO $con = null)
    {
        if ($this->isDeleted()) {
            throw new PropelException("This object has already been deleted.");
        }

        if ($con === null) {
            $con = Propel::getConnection(sfGuardUserPeer::DATABASE_NAME, Propel::CONNECTION_WRITE);
        }

        $con->beginTransaction();
        try {
            $deleteQuery = sfGuardUserQuery::create()
                ->filterByPrimaryKey($this->getPrimaryKey());
            $ret = $this->preDelete($con);
            // symfony_behaviors behavior
            foreach (sfMixer::getCallables('BasesfGuardUser:delete:pre') as $callable)
            {
              if (call_user_func($callable, $this, $con))
              {
                $con->commit();
                return;
              }
            }

            if ($ret) {
                $deleteQuery->delete($con);
                $this->postDelete($con);
                // symfony_behaviors behavior
                foreach (sfMixer::getCallables('BasesfGuardUser:delete:post') as $callable)
                {
                  call_user_func($callable, $this, $con);
                }

                $con->commit();
                $this->setDeleted(true);
            } else {
                $con->commit();
            }
        } catch (Exception $e) {
            $con->rollBack();
            throw $e;
        }
    }

    /**
     * Persists this object to the database.
     *
     * If the object is new, it inserts it; otherwise an update is performed.
     * All modified related objects will also be persisted in the doSave()
     * method.  This method wraps all precipitate database operations in a
     * single transaction.
     *
     * @param PropelPDO $con
     * @return int             The number of rows affected by this insert/update and any referring fk objects' save() operations.
     * @throws PropelException
     * @throws Exception
     * @see        doSave()
     */
    public function save(PropelPDO $con = null)
    {
        if ($this->isDeleted()) {
            throw new PropelException("You cannot save an object that has been deleted.");
        }

        if ($con === null) {
            $con = Propel::getConnection(sfGuardUserPeer::DATABASE_NAME, Propel::CONNECTION_WRITE);
        }

        $con->beginTransaction();
        $isInsert = $this->isNew();
        try {
            $ret = $this->preSave($con);
            // symfony_behaviors behavior
            foreach (sfMixer::getCallables('BasesfGuardUser:save:pre') as $callable)
            {
              if (is_integer($affectedRows = call_user_func($callable, $this, $con)))
              {
                  $con->commit();
                return $affectedRows;
              }
            }

            if ($isInsert) {
                $ret = $ret && $this->preInsert($con);
                // symfony_timestampable behavior
                if (!$this->isColumnModified(sfGuardUserPeer::CREATED_AT))
                {
                  $this->setCreatedAt(time());
                }

            } else {
                $ret = $ret && $this->preUpdate($con);
            }
            if ($ret) {
                $affectedRows = $this->doSave($con);
                if ($isInsert) {
                    $this->postInsert($con);
                } else {
                    $this->postUpdate($con);
                }
                $this->postSave($con);
                // symfony_behaviors behavior
                foreach (sfMixer::getCallables('BasesfGuardUser:save:post') as $callable)
                {
                  call_user_func($callable, $this, $con, $affectedRows);
                }

                sfGuardUserPeer::addInstanceToPool($this);
            } else {
                $affectedRows = 0;
            }
            $con->commit();

            return $affectedRows;
        } catch (Exception $e) {
            $con->rollBack();
            throw $e;
        }
    }

    /**
     * Performs the work of inserting or updating the row in the database.
     *
     * If the object is new, it inserts it; otherwise an update is performed.
     * All related objects are also updated in this method.
     *
     * @param PropelPDO $con
     * @return int             The number of rows affected by this insert/update and any referring fk objects' save() operations.
     * @throws PropelException
     * @see        save()
     */
    protected function doSave(PropelPDO $con)
    {
        $affectedRows = 0; // initialize var to track total num of affected rows
        if (!$this->alreadyInSave) {
            $this->alreadyInSave = true;

            if ($this->isNew() || $this->isModified()) {
                // persist changes
                if ($this->isNew()) {
                    $this->doInsert($con);
                } else {
                    $this->doUpdate($con);
                }
                $affectedRows += 1;
                $this->resetModified();
            }

            if ($this->biznessScheduledForDeletion !== null) {
                if (!$this->biznessScheduledForDeletion->isEmpty()) {
                    foreach ($this->biznessScheduledForDeletion as $biznes) {
                        // need to save related object because we set the relation to null
                        $biznes->save($con);
                    }
                    $this->biznessScheduledForDeletion = null;
                }
            }

            if ($this->collBizness !== null) {
                foreach ($this->collBizness as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->biznesCommentsScheduledForDeletion !== null) {
                if (!$this->biznesCommentsScheduledForDeletion->isEmpty()) {
                    BiznesCommentQuery::create()
                        ->filterByPrimaryKeys($this->biznesCommentsScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->biznesCommentsScheduledForDeletion = null;
                }
            }

            if ($this->collBiznesComments !== null) {
                foreach ($this->collBiznesComments as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->biznesTagsScheduledForDeletion !== null) {
                if (!$this->biznesTagsScheduledForDeletion->isEmpty()) {
                    BiznesTagQuery::create()
                        ->filterByPrimaryKeys($this->biznesTagsScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->biznesTagsScheduledForDeletion = null;
                }
            }

            if ($this->collBiznesTags !== null) {
                foreach ($this->collBiznesTags as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->biznesFavsScheduledForDeletion !== null) {
                if (!$this->biznesFavsScheduledForDeletion->isEmpty()) {
                    BiznesFavQuery::create()
                        ->filterByPrimaryKeys($this->biznesFavsScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->biznesFavsScheduledForDeletion = null;
                }
            }

            if ($this->collBiznesFavs !== null) {
                foreach ($this->collBiznesFavs as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->biznesRatesScheduledForDeletion !== null) {
                if (!$this->biznesRatesScheduledForDeletion->isEmpty()) {
                    BiznesRateQuery::create()
                        ->filterByPrimaryKeys($this->biznesRatesScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->biznesRatesScheduledForDeletion = null;
                }
            }

            if ($this->collBiznesRates !== null) {
                foreach ($this->collBiznesRates as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->albumsScheduledForDeletion !== null) {
                if (!$this->albumsScheduledForDeletion->isEmpty()) {
                    AlbumQuery::create()
                        ->filterByPrimaryKeys($this->albumsScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->albumsScheduledForDeletion = null;
                }
            }

            if ($this->collAlbums !== null) {
                foreach ($this->collAlbums as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->friendsRelatedByUserIdScheduledForDeletion !== null) {
                if (!$this->friendsRelatedByUserIdScheduledForDeletion->isEmpty()) {
                    FriendQuery::create()
                        ->filterByPrimaryKeys($this->friendsRelatedByUserIdScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->friendsRelatedByUserIdScheduledForDeletion = null;
                }
            }

            if ($this->collFriendsRelatedByUserId !== null) {
                foreach ($this->collFriendsRelatedByUserId as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->friendsRelatedByFriendIdScheduledForDeletion !== null) {
                if (!$this->friendsRelatedByFriendIdScheduledForDeletion->isEmpty()) {
                    FriendQuery::create()
                        ->filterByPrimaryKeys($this->friendsRelatedByFriendIdScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->friendsRelatedByFriendIdScheduledForDeletion = null;
                }
            }

            if ($this->collFriendsRelatedByFriendId !== null) {
                foreach ($this->collFriendsRelatedByFriendId as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->messagesRelatedByFromUseridScheduledForDeletion !== null) {
                if (!$this->messagesRelatedByFromUseridScheduledForDeletion->isEmpty()) {
                    foreach ($this->messagesRelatedByFromUseridScheduledForDeletion as $messageRelatedByFromUserid) {
                        // need to save related object because we set the relation to null
                        $messageRelatedByFromUserid->save($con);
                    }
                    $this->messagesRelatedByFromUseridScheduledForDeletion = null;
                }
            }

            if ($this->collMessagesRelatedByFromUserid !== null) {
                foreach ($this->collMessagesRelatedByFromUserid as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->messagesRelatedByToUseridScheduledForDeletion !== null) {
                if (!$this->messagesRelatedByToUseridScheduledForDeletion->isEmpty()) {
                    foreach ($this->messagesRelatedByToUseridScheduledForDeletion as $messageRelatedByToUserid) {
                        // need to save related object because we set the relation to null
                        $messageRelatedByToUserid->save($con);
                    }
                    $this->messagesRelatedByToUseridScheduledForDeletion = null;
                }
            }

            if ($this->collMessagesRelatedByToUserid !== null) {
                foreach ($this->collMessagesRelatedByToUserid as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->photosScheduledForDeletion !== null) {
                if (!$this->photosScheduledForDeletion->isEmpty()) {
                    PhotoQuery::create()
                        ->filterByPrimaryKeys($this->photosScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->photosScheduledForDeletion = null;
                }
            }

            if ($this->collPhotos !== null) {
                foreach ($this->collPhotos as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->photoCommentsScheduledForDeletion !== null) {
                if (!$this->photoCommentsScheduledForDeletion->isEmpty()) {
                    PhotoCommentQuery::create()
                        ->filterByPrimaryKeys($this->photoCommentsScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->photoCommentsScheduledForDeletion = null;
                }
            }

            if ($this->collPhotoComments !== null) {
                foreach ($this->collPhotoComments as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->photoTagsScheduledForDeletion !== null) {
                if (!$this->photoTagsScheduledForDeletion->isEmpty()) {
                    PhotoTagQuery::create()
                        ->filterByPrimaryKeys($this->photoTagsScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->photoTagsScheduledForDeletion = null;
                }
            }

            if ($this->collPhotoTags !== null) {
                foreach ($this->collPhotoTags as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->photoFavsScheduledForDeletion !== null) {
                if (!$this->photoFavsScheduledForDeletion->isEmpty()) {
                    PhotoFavQuery::create()
                        ->filterByPrimaryKeys($this->photoFavsScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->photoFavsScheduledForDeletion = null;
                }
            }

            if ($this->collPhotoFavs !== null) {
                foreach ($this->collPhotoFavs as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->photoVotesScheduledForDeletion !== null) {
                if (!$this->photoVotesScheduledForDeletion->isEmpty()) {
                    PhotoVoteQuery::create()
                        ->filterByPrimaryKeys($this->photoVotesScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->photoVotesScheduledForDeletion = null;
                }
            }

            if ($this->collPhotoVotes !== null) {
                foreach ($this->collPhotoVotes as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->photoRatesScheduledForDeletion !== null) {
                if (!$this->photoRatesScheduledForDeletion->isEmpty()) {
                    PhotoRateQuery::create()
                        ->filterByPrimaryKeys($this->photoRatesScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->photoRatesScheduledForDeletion = null;
                }
            }

            if ($this->collPhotoRates !== null) {
                foreach ($this->collPhotoRates as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->schoolUsersScheduledForDeletion !== null) {
                if (!$this->schoolUsersScheduledForDeletion->isEmpty()) {
                    SchoolUserQuery::create()
                        ->filterByPrimaryKeys($this->schoolUsersScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->schoolUsersScheduledForDeletion = null;
                }
            }

            if ($this->collSchoolUsers !== null) {
                foreach ($this->collSchoolUsers as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->updatessScheduledForDeletion !== null) {
                if (!$this->updatessScheduledForDeletion->isEmpty()) {
                    foreach ($this->updatessScheduledForDeletion as $updates) {
                        // need to save related object because we set the relation to null
                        $updates->save($con);
                    }
                    $this->updatessScheduledForDeletion = null;
                }
            }

            if ($this->collUpdatess !== null) {
                foreach ($this->collUpdatess as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->ignorelistsRelatedByUserIdScheduledForDeletion !== null) {
                if (!$this->ignorelistsRelatedByUserIdScheduledForDeletion->isEmpty()) {
                    foreach ($this->ignorelistsRelatedByUserIdScheduledForDeletion as $ignorelistRelatedByUserId) {
                        // need to save related object because we set the relation to null
                        $ignorelistRelatedByUserId->save($con);
                    }
                    $this->ignorelistsRelatedByUserIdScheduledForDeletion = null;
                }
            }

            if ($this->collIgnorelistsRelatedByUserId !== null) {
                foreach ($this->collIgnorelistsRelatedByUserId as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->ignorelistsRelatedByIgnoredUserIdScheduledForDeletion !== null) {
                if (!$this->ignorelistsRelatedByIgnoredUserIdScheduledForDeletion->isEmpty()) {
                    foreach ($this->ignorelistsRelatedByIgnoredUserIdScheduledForDeletion as $ignorelistRelatedByIgnoredUserId) {
                        // need to save related object because we set the relation to null
                        $ignorelistRelatedByIgnoredUserId->save($con);
                    }
                    $this->ignorelistsRelatedByIgnoredUserIdScheduledForDeletion = null;
                }
            }

            if ($this->collIgnorelistsRelatedByIgnoredUserId !== null) {
                foreach ($this->collIgnorelistsRelatedByIgnoredUserId as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->sessionssScheduledForDeletion !== null) {
                if (!$this->sessionssScheduledForDeletion->isEmpty()) {
                    foreach ($this->sessionssScheduledForDeletion as $sessions) {
                        // need to save related object because we set the relation to null
                        $sessions->save($con);
                    }
                    $this->sessionssScheduledForDeletion = null;
                }
            }

            if ($this->collSessionss !== null) {
                foreach ($this->collSessionss as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->guestsRelatedByUserIdScheduledForDeletion !== null) {
                if (!$this->guestsRelatedByUserIdScheduledForDeletion->isEmpty()) {
                    foreach ($this->guestsRelatedByUserIdScheduledForDeletion as $guestRelatedByUserId) {
                        // need to save related object because we set the relation to null
                        $guestRelatedByUserId->save($con);
                    }
                    $this->guestsRelatedByUserIdScheduledForDeletion = null;
                }
            }

            if ($this->collGuestsRelatedByUserId !== null) {
                foreach ($this->collGuestsRelatedByUserId as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->guestsRelatedByGuestIdScheduledForDeletion !== null) {
                if (!$this->guestsRelatedByGuestIdScheduledForDeletion->isEmpty()) {
                    foreach ($this->guestsRelatedByGuestIdScheduledForDeletion as $guestRelatedByGuestId) {
                        // need to save related object because we set the relation to null
                        $guestRelatedByGuestId->save($con);
                    }
                    $this->guestsRelatedByGuestIdScheduledForDeletion = null;
                }
            }

            if ($this->collGuestsRelatedByGuestId !== null) {
                foreach ($this->collGuestsRelatedByGuestId as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->gameUsersScheduledForDeletion !== null) {
                if (!$this->gameUsersScheduledForDeletion->isEmpty()) {
                    GameUserQuery::create()
                        ->filterByPrimaryKeys($this->gameUsersScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->gameUsersScheduledForDeletion = null;
                }
            }

            if ($this->collGameUsers !== null) {
                foreach ($this->collGameUsers as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->musicsScheduledForDeletion !== null) {
                if (!$this->musicsScheduledForDeletion->isEmpty()) {
                    MusicQuery::create()
                        ->filterByPrimaryKeys($this->musicsScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->musicsScheduledForDeletion = null;
                }
            }

            if ($this->collMusics !== null) {
                foreach ($this->collMusics as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->playlistsScheduledForDeletion !== null) {
                if (!$this->playlistsScheduledForDeletion->isEmpty()) {
                    PlaylistQuery::create()
                        ->filterByPrimaryKeys($this->playlistsScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->playlistsScheduledForDeletion = null;
                }
            }

            if ($this->collPlaylists !== null) {
                foreach ($this->collPlaylists as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->playlistCommentsScheduledForDeletion !== null) {
                if (!$this->playlistCommentsScheduledForDeletion->isEmpty()) {
                    PlaylistCommentQuery::create()
                        ->filterByPrimaryKeys($this->playlistCommentsScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->playlistCommentsScheduledForDeletion = null;
                }
            }

            if ($this->collPlaylistComments !== null) {
                foreach ($this->collPlaylistComments as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->playlistFavsScheduledForDeletion !== null) {
                if (!$this->playlistFavsScheduledForDeletion->isEmpty()) {
                    PlaylistFavQuery::create()
                        ->filterByPrimaryKeys($this->playlistFavsScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->playlistFavsScheduledForDeletion = null;
                }
            }

            if ($this->collPlaylistFavs !== null) {
                foreach ($this->collPlaylistFavs as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->ytvideoFavsScheduledForDeletion !== null) {
                if (!$this->ytvideoFavsScheduledForDeletion->isEmpty()) {
                    YtvideoFavQuery::create()
                        ->filterByPrimaryKeys($this->ytvideoFavsScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->ytvideoFavsScheduledForDeletion = null;
                }
            }

            if ($this->collYtvideoFavs !== null) {
                foreach ($this->collYtvideoFavs as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->videolistsScheduledForDeletion !== null) {
                if (!$this->videolistsScheduledForDeletion->isEmpty()) {
                    VideolistQuery::create()
                        ->filterByPrimaryKeys($this->videolistsScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->videolistsScheduledForDeletion = null;
                }
            }

            if ($this->collVideolists !== null) {
                foreach ($this->collVideolists as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->userLinksScheduledForDeletion !== null) {
                if (!$this->userLinksScheduledForDeletion->isEmpty()) {
                    UserLinkQuery::create()
                        ->filterByPrimaryKeys($this->userLinksScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->userLinksScheduledForDeletion = null;
                }
            }

            if ($this->collUserLinks !== null) {
                foreach ($this->collUserLinks as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->userLinkCommentsScheduledForDeletion !== null) {
                if (!$this->userLinkCommentsScheduledForDeletion->isEmpty()) {
                    UserLinkCommentQuery::create()
                        ->filterByPrimaryKeys($this->userLinkCommentsScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->userLinkCommentsScheduledForDeletion = null;
                }
            }

            if ($this->collUserLinkComments !== null) {
                foreach ($this->collUserLinkComments as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->sfGuardUserPermissionsScheduledForDeletion !== null) {
                if (!$this->sfGuardUserPermissionsScheduledForDeletion->isEmpty()) {
                    sfGuardUserPermissionQuery::create()
                        ->filterByPrimaryKeys($this->sfGuardUserPermissionsScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->sfGuardUserPermissionsScheduledForDeletion = null;
                }
            }

            if ($this->collsfGuardUserPermissions !== null) {
                foreach ($this->collsfGuardUserPermissions as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->sfGuardUserGroupsScheduledForDeletion !== null) {
                if (!$this->sfGuardUserGroupsScheduledForDeletion->isEmpty()) {
                    sfGuardUserGroupQuery::create()
                        ->filterByPrimaryKeys($this->sfGuardUserGroupsScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->sfGuardUserGroupsScheduledForDeletion = null;
                }
            }

            if ($this->collsfGuardUserGroups !== null) {
                foreach ($this->collsfGuardUserGroups as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->sfGuardRememberKeysScheduledForDeletion !== null) {
                if (!$this->sfGuardRememberKeysScheduledForDeletion->isEmpty()) {
                    sfGuardRememberKeyQuery::create()
                        ->filterByPrimaryKeys($this->sfGuardRememberKeysScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->sfGuardRememberKeysScheduledForDeletion = null;
                }
            }

            if ($this->collsfGuardRememberKeys !== null) {
                foreach ($this->collsfGuardRememberKeys as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->sfGuardUserProfilesScheduledForDeletion !== null) {
                if (!$this->sfGuardUserProfilesScheduledForDeletion->isEmpty()) {
                    sfGuardUserProfileQuery::create()
                        ->filterByPrimaryKeys($this->sfGuardUserProfilesScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->sfGuardUserProfilesScheduledForDeletion = null;
                }
            }

            if ($this->collsfGuardUserProfiles !== null) {
                foreach ($this->collsfGuardUserProfiles as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->sfGuardUserStatussScheduledForDeletion !== null) {
                if (!$this->sfGuardUserStatussScheduledForDeletion->isEmpty()) {
                    sfGuardUserStatusQuery::create()
                        ->filterByPrimaryKeys($this->sfGuardUserStatussScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->sfGuardUserStatussScheduledForDeletion = null;
                }
            }

            if ($this->collsfGuardUserStatuss !== null) {
                foreach ($this->collsfGuardUserStatuss as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->sfGuardUserStatusCommentsScheduledForDeletion !== null) {
                if (!$this->sfGuardUserStatusCommentsScheduledForDeletion->isEmpty()) {
                    sfGuardUserStatusCommentQuery::create()
                        ->filterByPrimaryKeys($this->sfGuardUserStatusCommentsScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->sfGuardUserStatusCommentsScheduledForDeletion = null;
                }
            }

            if ($this->collsfGuardUserStatusComments !== null) {
                foreach ($this->collsfGuardUserStatusComments as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->sfSocialEventsScheduledForDeletion !== null) {
                if (!$this->sfSocialEventsScheduledForDeletion->isEmpty()) {
                    sfSocialEventQuery::create()
                        ->filterByPrimaryKeys($this->sfSocialEventsScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->sfSocialEventsScheduledForDeletion = null;
                }
            }

            if ($this->collsfSocialEvents !== null) {
                foreach ($this->collsfSocialEvents as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->sfSocialEventInvitesRelatedByUserIdScheduledForDeletion !== null) {
                if (!$this->sfSocialEventInvitesRelatedByUserIdScheduledForDeletion->isEmpty()) {
                    sfSocialEventInviteQuery::create()
                        ->filterByPrimaryKeys($this->sfSocialEventInvitesRelatedByUserIdScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->sfSocialEventInvitesRelatedByUserIdScheduledForDeletion = null;
                }
            }

            if ($this->collsfSocialEventInvitesRelatedByUserId !== null) {
                foreach ($this->collsfSocialEventInvitesRelatedByUserId as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->sfSocialEventInvitesRelatedByUserFromScheduledForDeletion !== null) {
                if (!$this->sfSocialEventInvitesRelatedByUserFromScheduledForDeletion->isEmpty()) {
                    sfSocialEventInviteQuery::create()
                        ->filterByPrimaryKeys($this->sfSocialEventInvitesRelatedByUserFromScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->sfSocialEventInvitesRelatedByUserFromScheduledForDeletion = null;
                }
            }

            if ($this->collsfSocialEventInvitesRelatedByUserFrom !== null) {
                foreach ($this->collsfSocialEventInvitesRelatedByUserFrom as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->sfSocialEventUsersScheduledForDeletion !== null) {
                if (!$this->sfSocialEventUsersScheduledForDeletion->isEmpty()) {
                    sfSocialEventUserQuery::create()
                        ->filterByPrimaryKeys($this->sfSocialEventUsersScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->sfSocialEventUsersScheduledForDeletion = null;
                }
            }

            if ($this->collsfSocialEventUsers !== null) {
                foreach ($this->collsfSocialEventUsers as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->sfSocialGroupsScheduledForDeletion !== null) {
                if (!$this->sfSocialGroupsScheduledForDeletion->isEmpty()) {
                    sfSocialGroupQuery::create()
                        ->filterByPrimaryKeys($this->sfSocialGroupsScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->sfSocialGroupsScheduledForDeletion = null;
                }
            }

            if ($this->collsfSocialGroups !== null) {
                foreach ($this->collsfSocialGroups as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->sfSocialGroupInvitesRelatedByUserIdScheduledForDeletion !== null) {
                if (!$this->sfSocialGroupInvitesRelatedByUserIdScheduledForDeletion->isEmpty()) {
                    sfSocialGroupInviteQuery::create()
                        ->filterByPrimaryKeys($this->sfSocialGroupInvitesRelatedByUserIdScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->sfSocialGroupInvitesRelatedByUserIdScheduledForDeletion = null;
                }
            }

            if ($this->collsfSocialGroupInvitesRelatedByUserId !== null) {
                foreach ($this->collsfSocialGroupInvitesRelatedByUserId as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->sfSocialGroupInvitesRelatedByUserFromScheduledForDeletion !== null) {
                if (!$this->sfSocialGroupInvitesRelatedByUserFromScheduledForDeletion->isEmpty()) {
                    sfSocialGroupInviteQuery::create()
                        ->filterByPrimaryKeys($this->sfSocialGroupInvitesRelatedByUserFromScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->sfSocialGroupInvitesRelatedByUserFromScheduledForDeletion = null;
                }
            }

            if ($this->collsfSocialGroupInvitesRelatedByUserFrom !== null) {
                foreach ($this->collsfSocialGroupInvitesRelatedByUserFrom as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->sfSocialGroupUsersScheduledForDeletion !== null) {
                if (!$this->sfSocialGroupUsersScheduledForDeletion->isEmpty()) {
                    sfSocialGroupUserQuery::create()
                        ->filterByPrimaryKeys($this->sfSocialGroupUsersScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->sfSocialGroupUsersScheduledForDeletion = null;
                }
            }

            if ($this->collsfSocialGroupUsers !== null) {
                foreach ($this->collsfSocialGroupUsers as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->groupStatusCommentsScheduledForDeletion !== null) {
                if (!$this->groupStatusCommentsScheduledForDeletion->isEmpty()) {
                    GroupStatusCommentQuery::create()
                        ->filterByPrimaryKeys($this->groupStatusCommentsScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->groupStatusCommentsScheduledForDeletion = null;
                }
            }

            if ($this->collGroupStatusComments !== null) {
                foreach ($this->collGroupStatusComments as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->eventStatussScheduledForDeletion !== null) {
                if (!$this->eventStatussScheduledForDeletion->isEmpty()) {
                    EventStatusQuery::create()
                        ->filterByPrimaryKeys($this->eventStatussScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->eventStatussScheduledForDeletion = null;
                }
            }

            if ($this->collEventStatuss !== null) {
                foreach ($this->collEventStatuss as $referrerFK) {
                    if (!$referrerFK->isDeleted()) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            $this->alreadyInSave = false;

        }

        return $affectedRows;
    } // doSave()

    /**
     * Insert the row in the database.
     *
     * @param PropelPDO $con
     *
     * @throws PropelException
     * @see        doSave()
     */
    protected function doInsert(PropelPDO $con)
    {
        $modifiedColumns = array();
        $index = 0;

        $this->modifiedColumns[] = sfGuardUserPeer::ID;
        if (null !== $this->id) {
            throw new PropelException('Cannot insert a value for auto-increment primary key (' . sfGuardUserPeer::ID . ')');
        }

         // check the columns in natural order for more readable SQL queries
        if ($this->isColumnModified(sfGuardUserPeer::ID)) {
            $modifiedColumns[':p' . $index++]  = '`ID`';
        }
        if ($this->isColumnModified(sfGuardUserPeer::USERNAME)) {
            $modifiedColumns[':p' . $index++]  = '`USERNAME`';
        }
        if ($this->isColumnModified(sfGuardUserPeer::ALGORITHM)) {
            $modifiedColumns[':p' . $index++]  = '`ALGORITHM`';
        }
        if ($this->isColumnModified(sfGuardUserPeer::SALT)) {
            $modifiedColumns[':p' . $index++]  = '`SALT`';
        }
        if ($this->isColumnModified(sfGuardUserPeer::PASSWORD)) {
            $modifiedColumns[':p' . $index++]  = '`PASSWORD`';
        }
        if ($this->isColumnModified(sfGuardUserPeer::EMAIL)) {
            $modifiedColumns[':p' . $index++]  = '`EMAIL`';
        }
        if ($this->isColumnModified(sfGuardUserPeer::PASSWORD_HINT)) {
            $modifiedColumns[':p' . $index++]  = '`PASSWORD_HINT`';
        }
        if ($this->isColumnModified(sfGuardUserPeer::CREATED_AT)) {
            $modifiedColumns[':p' . $index++]  = '`CREATED_AT`';
        }
        if ($this->isColumnModified(sfGuardUserPeer::LAST_LOGIN)) {
            $modifiedColumns[':p' . $index++]  = '`LAST_LOGIN`';
        }
        if ($this->isColumnModified(sfGuardUserPeer::IS_ACTIVE)) {
            $modifiedColumns[':p' . $index++]  = '`IS_ACTIVE`';
        }
        if ($this->isColumnModified(sfGuardUserPeer::IS_SUPER_ADMIN)) {
            $modifiedColumns[':p' . $index++]  = '`IS_SUPER_ADMIN`';
        }

        $sql = sprintf(
            'INSERT INTO `sf_guard_user` (%s) VALUES (%s)',
            implode(', ', $modifiedColumns),
            implode(', ', array_keys($modifiedColumns))
        );

        try {
            $stmt = $con->prepare($sql);
            foreach ($modifiedColumns as $identifier => $columnName) {
                switch ($columnName) {
                    case '`ID`':
                        $stmt->bindValue($identifier, $this->id, PDO::PARAM_INT);
                        break;
                    case '`USERNAME`':
                        $stmt->bindValue($identifier, $this->username, PDO::PARAM_STR);
                        break;
                    case '`ALGORITHM`':
                        $stmt->bindValue($identifier, $this->algorithm, PDO::PARAM_STR);
                        break;
                    case '`SALT`':
                        $stmt->bindValue($identifier, $this->salt, PDO::PARAM_STR);
                        break;
                    case '`PASSWORD`':
                        $stmt->bindValue($identifier, $this->password, PDO::PARAM_STR);
                        break;
                    case '`EMAIL`':
                        $stmt->bindValue($identifier, $this->email, PDO::PARAM_STR);
                        break;
                    case '`PASSWORD_HINT`':
                        $stmt->bindValue($identifier, $this->password_hint, PDO::PARAM_STR);
                        break;
                    case '`CREATED_AT`':
                        $stmt->bindValue($identifier, $this->created_at, PDO::PARAM_STR);
                        break;
                    case '`LAST_LOGIN`':
                        $stmt->bindValue($identifier, $this->last_login, PDO::PARAM_STR);
                        break;
                    case '`IS_ACTIVE`':
                        $stmt->bindValue($identifier, (int) $this->is_active, PDO::PARAM_INT);
                        break;
                    case '`IS_SUPER_ADMIN`':
                        $stmt->bindValue($identifier, (int) $this->is_super_admin, PDO::PARAM_INT);
                        break;
                }
            }
            $stmt->execute();
        } catch (Exception $e) {
            Propel::log($e->getMessage(), Propel::LOG_ERR);
            throw new PropelException(sprintf('Unable to execute INSERT statement [%s]', $sql), $e);
        }

        try {
            $pk = $con->lastInsertId();
        } catch (Exception $e) {
            throw new PropelException('Unable to get autoincrement id.', $e);
        }
        $this->setId($pk);

        $this->setNew(false);
    }

    /**
     * Update the row in the database.
     *
     * @param PropelPDO $con
     *
     * @see        doSave()
     */
    protected function doUpdate(PropelPDO $con)
    {
        $selectCriteria = $this->buildPkeyCriteria();
        $valuesCriteria = $this->buildCriteria();
        BasePeer::doUpdate($selectCriteria, $valuesCriteria, $con);
    }

    /**
     * Array of ValidationFailed objects.
     * @var        array ValidationFailed[]
     */
    protected $validationFailures = array();

    /**
     * Gets any ValidationFailed objects that resulted from last call to validate().
     *
     *
     * @return array ValidationFailed[]
     * @see        validate()
     */
    public function getValidationFailures()
    {
        return $this->validationFailures;
    }

    /**
     * Validates the objects modified field values and all objects related to this table.
     *
     * If $columns is either a column name or an array of column names
     * only those columns are validated.
     *
     * @param mixed $columns Column name or an array of column names.
     * @return boolean Whether all columns pass validation.
     * @see        doValidate()
     * @see        getValidationFailures()
     */
    public function validate($columns = null)
    {
        $res = $this->doValidate($columns);
        if ($res === true) {
            $this->validationFailures = array();

            return true;
        } else {
            $this->validationFailures = $res;

            return false;
        }
    }

    /**
     * This function performs the validation work for complex object models.
     *
     * In addition to checking the current object, all related objects will
     * also be validated.  If all pass then <code>true</code> is returned; otherwise
     * an aggreagated array of ValidationFailed objects will be returned.
     *
     * @param array $columns Array of column names to validate.
     * @return mixed <code>true</code> if all validations pass; array of <code>ValidationFailed</code> objets otherwise.
     */
    protected function doValidate($columns = null)
    {
        if (!$this->alreadyInValidation) {
            $this->alreadyInValidation = true;
            $retval = null;

            $failureMap = array();


            if (($retval = sfGuardUserPeer::doValidate($this, $columns)) !== true) {
                $failureMap = array_merge($failureMap, $retval);
            }


                if ($this->collBizness !== null) {
                    foreach ($this->collBizness as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collBiznesComments !== null) {
                    foreach ($this->collBiznesComments as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collBiznesTags !== null) {
                    foreach ($this->collBiznesTags as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collBiznesFavs !== null) {
                    foreach ($this->collBiznesFavs as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collBiznesRates !== null) {
                    foreach ($this->collBiznesRates as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collAlbums !== null) {
                    foreach ($this->collAlbums as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collFriendsRelatedByUserId !== null) {
                    foreach ($this->collFriendsRelatedByUserId as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collFriendsRelatedByFriendId !== null) {
                    foreach ($this->collFriendsRelatedByFriendId as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collMessagesRelatedByFromUserid !== null) {
                    foreach ($this->collMessagesRelatedByFromUserid as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collMessagesRelatedByToUserid !== null) {
                    foreach ($this->collMessagesRelatedByToUserid as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collPhotos !== null) {
                    foreach ($this->collPhotos as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collPhotoComments !== null) {
                    foreach ($this->collPhotoComments as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collPhotoTags !== null) {
                    foreach ($this->collPhotoTags as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collPhotoFavs !== null) {
                    foreach ($this->collPhotoFavs as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collPhotoVotes !== null) {
                    foreach ($this->collPhotoVotes as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collPhotoRates !== null) {
                    foreach ($this->collPhotoRates as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collSchoolUsers !== null) {
                    foreach ($this->collSchoolUsers as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collUpdatess !== null) {
                    foreach ($this->collUpdatess as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collIgnorelistsRelatedByUserId !== null) {
                    foreach ($this->collIgnorelistsRelatedByUserId as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collIgnorelistsRelatedByIgnoredUserId !== null) {
                    foreach ($this->collIgnorelistsRelatedByIgnoredUserId as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collSessionss !== null) {
                    foreach ($this->collSessionss as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collGuestsRelatedByUserId !== null) {
                    foreach ($this->collGuestsRelatedByUserId as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collGuestsRelatedByGuestId !== null) {
                    foreach ($this->collGuestsRelatedByGuestId as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collGameUsers !== null) {
                    foreach ($this->collGameUsers as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collMusics !== null) {
                    foreach ($this->collMusics as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collPlaylists !== null) {
                    foreach ($this->collPlaylists as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collPlaylistComments !== null) {
                    foreach ($this->collPlaylistComments as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collPlaylistFavs !== null) {
                    foreach ($this->collPlaylistFavs as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collYtvideoFavs !== null) {
                    foreach ($this->collYtvideoFavs as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collVideolists !== null) {
                    foreach ($this->collVideolists as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collUserLinks !== null) {
                    foreach ($this->collUserLinks as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collUserLinkComments !== null) {
                    foreach ($this->collUserLinkComments as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collsfGuardUserPermissions !== null) {
                    foreach ($this->collsfGuardUserPermissions as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collsfGuardUserGroups !== null) {
                    foreach ($this->collsfGuardUserGroups as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collsfGuardRememberKeys !== null) {
                    foreach ($this->collsfGuardRememberKeys as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collsfGuardUserProfiles !== null) {
                    foreach ($this->collsfGuardUserProfiles as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collsfGuardUserStatuss !== null) {
                    foreach ($this->collsfGuardUserStatuss as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collsfGuardUserStatusComments !== null) {
                    foreach ($this->collsfGuardUserStatusComments as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collsfSocialEvents !== null) {
                    foreach ($this->collsfSocialEvents as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collsfSocialEventInvitesRelatedByUserId !== null) {
                    foreach ($this->collsfSocialEventInvitesRelatedByUserId as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collsfSocialEventInvitesRelatedByUserFrom !== null) {
                    foreach ($this->collsfSocialEventInvitesRelatedByUserFrom as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collsfSocialEventUsers !== null) {
                    foreach ($this->collsfSocialEventUsers as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collsfSocialGroups !== null) {
                    foreach ($this->collsfSocialGroups as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collsfSocialGroupInvitesRelatedByUserId !== null) {
                    foreach ($this->collsfSocialGroupInvitesRelatedByUserId as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collsfSocialGroupInvitesRelatedByUserFrom !== null) {
                    foreach ($this->collsfSocialGroupInvitesRelatedByUserFrom as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collsfSocialGroupUsers !== null) {
                    foreach ($this->collsfSocialGroupUsers as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collGroupStatusComments !== null) {
                    foreach ($this->collGroupStatusComments as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }

                if ($this->collEventStatuss !== null) {
                    foreach ($this->collEventStatuss as $referrerFK) {
                        if (!$referrerFK->validate($columns)) {
                            $failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
                        }
                    }
                }


            $this->alreadyInValidation = false;
        }

        return (!empty($failureMap) ? $failureMap : true);
    }

    /**
     * Retrieves a field from the object by name passed in as a string.
     *
     * @param string $name name
     * @param string $type The type of fieldname the $name is of:
     *               one of the class type constants BasePeer::TYPE_PHPNAME, BasePeer::TYPE_STUDLYPHPNAME
     *               BasePeer::TYPE_COLNAME, BasePeer::TYPE_FIELDNAME, BasePeer::TYPE_NUM.
     *               Defaults to BasePeer::TYPE_PHPNAME
     * @return mixed Value of field.
     */
    public function getByName($name, $type = BasePeer::TYPE_PHPNAME)
    {
        $pos = sfGuardUserPeer::translateFieldName($name, $type, BasePeer::TYPE_NUM);
        $field = $this->getByPosition($pos);

        return $field;
    }

    /**
     * Retrieves a field from the object by Position as specified in the xml schema.
     * Zero-based.
     *
     * @param int $pos position in xml schema
     * @return mixed Value of field at $pos
     */
    public function getByPosition($pos)
    {
        switch ($pos) {
            case 0:
                return $this->getId();
                break;
            case 1:
                return $this->getUsername();
                break;
            case 2:
                return $this->getAlgorithm();
                break;
            case 3:
                return $this->getSalt();
                break;
            case 4:
                return $this->getPassword();
                break;
            case 5:
                return $this->getEmail();
                break;
            case 6:
                return $this->getPasswordHint();
                break;
            case 7:
                return $this->getCreatedAt();
                break;
            case 8:
                return $this->getLastLogin();
                break;
            case 9:
                return $this->getIsActive();
                break;
            case 10:
                return $this->getIsSuperAdmin();
                break;
            default:
                return null;
                break;
        } // switch()
    }

    /**
     * Exports the object as an array.
     *
     * You can specify the key type of the array by passing one of the class
     * type constants.
     *
     * @param     string  $keyType (optional) One of the class type constants BasePeer::TYPE_PHPNAME, BasePeer::TYPE_STUDLYPHPNAME,
     *                    BasePeer::TYPE_COLNAME, BasePeer::TYPE_FIELDNAME, BasePeer::TYPE_NUM.
     *                    Defaults to BasePeer::TYPE_PHPNAME.
     * @param     boolean $includeLazyLoadColumns (optional) Whether to include lazy loaded columns. Defaults to true.
     * @param     array $alreadyDumpedObjects List of objects to skip to avoid recursion
     * @param     boolean $includeForeignObjects (optional) Whether to include hydrated related objects. Default to FALSE.
     *
     * @return array an associative array containing the field names (as keys) and field values
     */
    public function toArray($keyType = BasePeer::TYPE_PHPNAME, $includeLazyLoadColumns = true, $alreadyDumpedObjects = array(), $includeForeignObjects = false)
    {
        if (isset($alreadyDumpedObjects['sfGuardUser'][$this->getPrimaryKey()])) {
            return '*RECURSION*';
        }
        $alreadyDumpedObjects['sfGuardUser'][$this->getPrimaryKey()] = true;
        $keys = sfGuardUserPeer::getFieldNames($keyType);
        $result = array(
            $keys[0] => $this->getId(),
            $keys[1] => $this->getUsername(),
            $keys[2] => $this->getAlgorithm(),
            $keys[3] => $this->getSalt(),
            $keys[4] => $this->getPassword(),
            $keys[5] => $this->getEmail(),
            $keys[6] => $this->getPasswordHint(),
            $keys[7] => $this->getCreatedAt(),
            $keys[8] => $this->getLastLogin(),
            $keys[9] => $this->getIsActive(),
            $keys[10] => $this->getIsSuperAdmin(),
        );
        if ($includeForeignObjects) {
            if (null !== $this->collBizness) {
                $result['Bizness'] = $this->collBizness->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collBiznesComments) {
                $result['BiznesComments'] = $this->collBiznesComments->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collBiznesTags) {
                $result['BiznesTags'] = $this->collBiznesTags->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collBiznesFavs) {
                $result['BiznesFavs'] = $this->collBiznesFavs->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collBiznesRates) {
                $result['BiznesRates'] = $this->collBiznesRates->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collAlbums) {
                $result['Albums'] = $this->collAlbums->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collFriendsRelatedByUserId) {
                $result['FriendsRelatedByUserId'] = $this->collFriendsRelatedByUserId->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collFriendsRelatedByFriendId) {
                $result['FriendsRelatedByFriendId'] = $this->collFriendsRelatedByFriendId->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collMessagesRelatedByFromUserid) {
                $result['MessagesRelatedByFromUserid'] = $this->collMessagesRelatedByFromUserid->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collMessagesRelatedByToUserid) {
                $result['MessagesRelatedByToUserid'] = $this->collMessagesRelatedByToUserid->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collPhotos) {
                $result['Photos'] = $this->collPhotos->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collPhotoComments) {
                $result['PhotoComments'] = $this->collPhotoComments->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collPhotoTags) {
                $result['PhotoTags'] = $this->collPhotoTags->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collPhotoFavs) {
                $result['PhotoFavs'] = $this->collPhotoFavs->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collPhotoVotes) {
                $result['PhotoVotes'] = $this->collPhotoVotes->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collPhotoRates) {
                $result['PhotoRates'] = $this->collPhotoRates->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collSchoolUsers) {
                $result['SchoolUsers'] = $this->collSchoolUsers->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collUpdatess) {
                $result['Updatess'] = $this->collUpdatess->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collIgnorelistsRelatedByUserId) {
                $result['IgnorelistsRelatedByUserId'] = $this->collIgnorelistsRelatedByUserId->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collIgnorelistsRelatedByIgnoredUserId) {
                $result['IgnorelistsRelatedByIgnoredUserId'] = $this->collIgnorelistsRelatedByIgnoredUserId->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collSessionss) {
                $result['Sessionss'] = $this->collSessionss->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collGuestsRelatedByUserId) {
                $result['GuestsRelatedByUserId'] = $this->collGuestsRelatedByUserId->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collGuestsRelatedByGuestId) {
                $result['GuestsRelatedByGuestId'] = $this->collGuestsRelatedByGuestId->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collGameUsers) {
                $result['GameUsers'] = $this->collGameUsers->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collMusics) {
                $result['Musics'] = $this->collMusics->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collPlaylists) {
                $result['Playlists'] = $this->collPlaylists->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collPlaylistComments) {
                $result['PlaylistComments'] = $this->collPlaylistComments->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collPlaylistFavs) {
                $result['PlaylistFavs'] = $this->collPlaylistFavs->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collYtvideoFavs) {
                $result['YtvideoFavs'] = $this->collYtvideoFavs->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collVideolists) {
                $result['Videolists'] = $this->collVideolists->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collUserLinks) {
                $result['UserLinks'] = $this->collUserLinks->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collUserLinkComments) {
                $result['UserLinkComments'] = $this->collUserLinkComments->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collsfGuardUserPermissions) {
                $result['sfGuardUserPermissions'] = $this->collsfGuardUserPermissions->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collsfGuardUserGroups) {
                $result['sfGuardUserGroups'] = $this->collsfGuardUserGroups->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collsfGuardRememberKeys) {
                $result['sfGuardRememberKeys'] = $this->collsfGuardRememberKeys->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collsfGuardUserProfiles) {
                $result['sfGuardUserProfiles'] = $this->collsfGuardUserProfiles->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collsfGuardUserStatuss) {
                $result['sfGuardUserStatuss'] = $this->collsfGuardUserStatuss->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collsfGuardUserStatusComments) {
                $result['sfGuardUserStatusComments'] = $this->collsfGuardUserStatusComments->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collsfSocialEvents) {
                $result['sfSocialEvents'] = $this->collsfSocialEvents->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collsfSocialEventInvitesRelatedByUserId) {
                $result['sfSocialEventInvitesRelatedByUserId'] = $this->collsfSocialEventInvitesRelatedByUserId->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collsfSocialEventInvitesRelatedByUserFrom) {
                $result['sfSocialEventInvitesRelatedByUserFrom'] = $this->collsfSocialEventInvitesRelatedByUserFrom->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collsfSocialEventUsers) {
                $result['sfSocialEventUsers'] = $this->collsfSocialEventUsers->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collsfSocialGroups) {
                $result['sfSocialGroups'] = $this->collsfSocialGroups->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collsfSocialGroupInvitesRelatedByUserId) {
                $result['sfSocialGroupInvitesRelatedByUserId'] = $this->collsfSocialGroupInvitesRelatedByUserId->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collsfSocialGroupInvitesRelatedByUserFrom) {
                $result['sfSocialGroupInvitesRelatedByUserFrom'] = $this->collsfSocialGroupInvitesRelatedByUserFrom->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collsfSocialGroupUsers) {
                $result['sfSocialGroupUsers'] = $this->collsfSocialGroupUsers->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collGroupStatusComments) {
                $result['GroupStatusComments'] = $this->collGroupStatusComments->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collEventStatuss) {
                $result['EventStatuss'] = $this->collEventStatuss->toArray(null, true, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
        }

        return $result;
    }

    /**
     * Sets a field from the object by name passed in as a string.
     *
     * @param string $name peer name
     * @param mixed $value field value
     * @param string $type The type of fieldname the $name is of:
     *                     one of the class type constants BasePeer::TYPE_PHPNAME, BasePeer::TYPE_STUDLYPHPNAME
     *                     BasePeer::TYPE_COLNAME, BasePeer::TYPE_FIELDNAME, BasePeer::TYPE_NUM.
     *                     Defaults to BasePeer::TYPE_PHPNAME
     * @return void
     */
    public function setByName($name, $value, $type = BasePeer::TYPE_PHPNAME)
    {
        $pos = sfGuardUserPeer::translateFieldName($name, $type, BasePeer::TYPE_NUM);

        $this->setByPosition($pos, $value);
    }

    /**
     * Sets a field from the object by Position as specified in the xml schema.
     * Zero-based.
     *
     * @param int $pos position in xml schema
     * @param mixed $value field value
     * @return void
     */
    public function setByPosition($pos, $value)
    {
        switch ($pos) {
            case 0:
                $this->setId($value);
                break;
            case 1:
                $this->setUsername($value);
                break;
            case 2:
                $this->setAlgorithm($value);
                break;
            case 3:
                $this->setSalt($value);
                break;
            case 4:
                $this->setPassword($value);
                break;
            case 5:
                $this->setEmail($value);
                break;
            case 6:
                $this->setPasswordHint($value);
                break;
            case 7:
                $this->setCreatedAt($value);
                break;
            case 8:
                $this->setLastLogin($value);
                break;
            case 9:
                $this->setIsActive($value);
                break;
            case 10:
                $this->setIsSuperAdmin($value);
                break;
        } // switch()
    }

    /**
     * Populates the object using an array.
     *
     * This is particularly useful when populating an object from one of the
     * request arrays (e.g. $_POST).  This method goes through the column
     * names, checking to see whether a matching key exists in populated
     * array. If so the setByName() method is called for that column.
     *
     * You can specify the key type of the array by additionally passing one
     * of the class type constants BasePeer::TYPE_PHPNAME, BasePeer::TYPE_STUDLYPHPNAME,
     * BasePeer::TYPE_COLNAME, BasePeer::TYPE_FIELDNAME, BasePeer::TYPE_NUM.
     * The default key type is the column's BasePeer::TYPE_PHPNAME
     *
     * @param array  $arr     An array to populate the object from.
     * @param string $keyType The type of keys the array uses.
     * @return void
     */
    public function fromArray($arr, $keyType = BasePeer::TYPE_PHPNAME)
    {
        $keys = sfGuardUserPeer::getFieldNames($keyType);

        if (array_key_exists($keys[0], $arr)) $this->setId($arr[$keys[0]]);
        if (array_key_exists($keys[1], $arr)) $this->setUsername($arr[$keys[1]]);
        if (array_key_exists($keys[2], $arr)) $this->setAlgorithm($arr[$keys[2]]);
        if (array_key_exists($keys[3], $arr)) $this->setSalt($arr[$keys[3]]);
        if (array_key_exists($keys[4], $arr)) $this->setPassword($arr[$keys[4]]);
        if (array_key_exists($keys[5], $arr)) $this->setEmail($arr[$keys[5]]);
        if (array_key_exists($keys[6], $arr)) $this->setPasswordHint($arr[$keys[6]]);
        if (array_key_exists($keys[7], $arr)) $this->setCreatedAt($arr[$keys[7]]);
        if (array_key_exists($keys[8], $arr)) $this->setLastLogin($arr[$keys[8]]);
        if (array_key_exists($keys[9], $arr)) $this->setIsActive($arr[$keys[9]]);
        if (array_key_exists($keys[10], $arr)) $this->setIsSuperAdmin($arr[$keys[10]]);
    }

    /**
     * Build a Criteria object containing the values of all modified columns in this object.
     *
     * @return Criteria The Criteria object containing all modified values.
     */
    public function buildCriteria()
    {
        $criteria = new Criteria(sfGuardUserPeer::DATABASE_NAME);

        if ($this->isColumnModified(sfGuardUserPeer::ID)) $criteria->add(sfGuardUserPeer::ID, $this->id);
        if ($this->isColumnModified(sfGuardUserPeer::USERNAME)) $criteria->add(sfGuardUserPeer::USERNAME, $this->username);
        if ($this->isColumnModified(sfGuardUserPeer::ALGORITHM)) $criteria->add(sfGuardUserPeer::ALGORITHM, $this->algorithm);
        if ($this->isColumnModified(sfGuardUserPeer::SALT)) $criteria->add(sfGuardUserPeer::SALT, $this->salt);
        if ($this->isColumnModified(sfGuardUserPeer::PASSWORD)) $criteria->add(sfGuardUserPeer::PASSWORD, $this->password);
        if ($this->isColumnModified(sfGuardUserPeer::EMAIL)) $criteria->add(sfGuardUserPeer::EMAIL, $this->email);
        if ($this->isColumnModified(sfGuardUserPeer::PASSWORD_HINT)) $criteria->add(sfGuardUserPeer::PASSWORD_HINT, $this->password_hint);
        if ($this->isColumnModified(sfGuardUserPeer::CREATED_AT)) $criteria->add(sfGuardUserPeer::CREATED_AT, $this->created_at);
        if ($this->isColumnModified(sfGuardUserPeer::LAST_LOGIN)) $criteria->add(sfGuardUserPeer::LAST_LOGIN, $this->last_login);
        if ($this->isColumnModified(sfGuardUserPeer::IS_ACTIVE)) $criteria->add(sfGuardUserPeer::IS_ACTIVE, $this->is_active);
        if ($this->isColumnModified(sfGuardUserPeer::IS_SUPER_ADMIN)) $criteria->add(sfGuardUserPeer::IS_SUPER_ADMIN, $this->is_super_admin);

        return $criteria;
    }

    /**
     * Builds a Criteria object containing the primary key for this object.
     *
     * Unlike buildCriteria() this method includes the primary key values regardless
     * of whether or not they have been modified.
     *
     * @return Criteria The Criteria object containing value(s) for primary key(s).
     */
    public function buildPkeyCriteria()
    {
        $criteria = new Criteria(sfGuardUserPeer::DATABASE_NAME);
        $criteria->add(sfGuardUserPeer::ID, $this->id);

        return $criteria;
    }

    /**
     * Returns the primary key for this object (row).
     * @return int
     */
    public function getPrimaryKey()
    {
        return $this->getId();
    }

    /**
     * Generic method to set the primary key (id column).
     *
     * @param  int $key Primary key.
     * @return void
     */
    public function setPrimaryKey($key)
    {
        $this->setId($key);
    }

    /**
     * Returns true if the primary key for this object is null.
     * @return boolean
     */
    public function isPrimaryKeyNull()
    {

        return null === $this->getId();
    }

    /**
     * Sets contents of passed object to values from current object.
     *
     * If desired, this method can also make copies of all associated (fkey referrers)
     * objects.
     *
     * @param object $copyObj An object of sfGuardUser (or compatible) type.
     * @param boolean $deepCopy Whether to also copy all rows that refer (by fkey) to the current row.
     * @param boolean $makeNew Whether to reset autoincrement PKs and make the object new.
     * @throws PropelException
     */
    public function copyInto($copyObj, $deepCopy = false, $makeNew = true)
    {
        $copyObj->setUsername($this->getUsername());
        $copyObj->setAlgorithm($this->getAlgorithm());
        $copyObj->setSalt($this->getSalt());
        $copyObj->setPassword($this->getPassword());
        $copyObj->setEmail($this->getEmail());
        $copyObj->setPasswordHint($this->getPasswordHint());
        $copyObj->setCreatedAt($this->getCreatedAt());
        $copyObj->setLastLogin($this->getLastLogin());
        $copyObj->setIsActive($this->getIsActive());
        $copyObj->setIsSuperAdmin($this->getIsSuperAdmin());

        if ($deepCopy && !$this->startCopy) {
            // important: temporarily setNew(false) because this affects the behavior of
            // the getter/setter methods for fkey referrer objects.
            $copyObj->setNew(false);
            // store object hash to prevent cycle
            $this->startCopy = true;

            foreach ($this->getBizness() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addBiznes($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getBiznesComments() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addBiznesComment($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getBiznesTags() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addBiznesTag($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getBiznesFavs() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addBiznesFav($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getBiznesRates() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addBiznesRate($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getAlbums() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addAlbum($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getFriendsRelatedByUserId() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addFriendRelatedByUserId($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getFriendsRelatedByFriendId() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addFriendRelatedByFriendId($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getMessagesRelatedByFromUserid() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addMessageRelatedByFromUserid($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getMessagesRelatedByToUserid() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addMessageRelatedByToUserid($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getPhotos() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addPhoto($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getPhotoComments() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addPhotoComment($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getPhotoTags() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addPhotoTag($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getPhotoFavs() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addPhotoFav($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getPhotoVotes() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addPhotoVote($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getPhotoRates() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addPhotoRate($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getSchoolUsers() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addSchoolUser($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getUpdatess() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addUpdates($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getIgnorelistsRelatedByUserId() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addIgnorelistRelatedByUserId($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getIgnorelistsRelatedByIgnoredUserId() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addIgnorelistRelatedByIgnoredUserId($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getSessionss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addSessions($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getGuestsRelatedByUserId() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addGuestRelatedByUserId($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getGuestsRelatedByGuestId() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addGuestRelatedByGuestId($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getGameUsers() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addGameUser($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getMusics() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addMusic($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getPlaylists() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addPlaylist($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getPlaylistComments() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addPlaylistComment($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getPlaylistFavs() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addPlaylistFav($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getYtvideoFavs() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addYtvideoFav($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getVideolists() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addVideolist($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getUserLinks() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addUserLink($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getUserLinkComments() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addUserLinkComment($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getsfGuardUserPermissions() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addsfGuardUserPermission($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getsfGuardUserGroups() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addsfGuardUserGroup($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getsfGuardRememberKeys() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addsfGuardRememberKey($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getsfGuardUserProfiles() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addsfGuardUserProfile($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getsfGuardUserStatuss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addsfGuardUserStatus($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getsfGuardUserStatusComments() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addsfGuardUserStatusComment($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getsfSocialEvents() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addsfSocialEvent($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getsfSocialEventInvitesRelatedByUserId() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addsfSocialEventInviteRelatedByUserId($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getsfSocialEventInvitesRelatedByUserFrom() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addsfSocialEventInviteRelatedByUserFrom($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getsfSocialEventUsers() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addsfSocialEventUser($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getsfSocialGroups() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addsfSocialGroup($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getsfSocialGroupInvitesRelatedByUserId() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addsfSocialGroupInviteRelatedByUserId($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getsfSocialGroupInvitesRelatedByUserFrom() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addsfSocialGroupInviteRelatedByUserFrom($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getsfSocialGroupUsers() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addsfSocialGroupUser($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getGroupStatusComments() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addGroupStatusComment($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getEventStatuss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addEventStatus($relObj->copy($deepCopy));
                }
            }

            //unflag object copy
            $this->startCopy = false;
        } // if ($deepCopy)

        if ($makeNew) {
            $copyObj->setNew(true);
            $copyObj->setId(NULL); // this is a auto-increment column, so set to default value
        }
    }

    /**
     * Makes a copy of this object that will be inserted as a new row in table when saved.
     * It creates a new object filling in the simple attributes, but skipping any primary
     * keys that are defined for the table.
     *
     * If desired, this method can also make copies of all associated (fkey referrers)
     * objects.
     *
     * @param boolean $deepCopy Whether to also copy all rows that refer (by fkey) to the current row.
     * @return sfGuardUser Clone of current object.
     * @throws PropelException
     */
    public function copy($deepCopy = false)
    {
        // we use get_class(), because this might be a subclass
        $clazz = get_class($this);
        $copyObj = new $clazz();
        $this->copyInto($copyObj, $deepCopy);

        return $copyObj;
    }

    /**
     * Returns a peer instance associated with this om.
     *
     * Since Peer classes are not to have any instance attributes, this method returns the
     * same instance for all member of this class. The method could therefore
     * be static, but this would prevent one from overriding the behavior.
     *
     * @return sfGuardUserPeer
     */
    public function getPeer()
    {
        if (self::$peer === null) {
            self::$peer = new sfGuardUserPeer();
        }

        return self::$peer;
    }


    /**
     * Initializes a collection based on the name of a relation.
     * Avoids crafting an 'init[$relationName]s' method name
     * that wouldn't work when StandardEnglishPluralizer is used.
     *
     * @param string $relationName The name of the relation to initialize
     * @return void
     */
    public function initRelation($relationName)
    {
        if ('Biznes' == $relationName) {
            $this->initBizness();
        }
        if ('BiznesComment' == $relationName) {
            $this->initBiznesComments();
        }
        if ('BiznesTag' == $relationName) {
            $this->initBiznesTags();
        }
        if ('BiznesFav' == $relationName) {
            $this->initBiznesFavs();
        }
        if ('BiznesRate' == $relationName) {
            $this->initBiznesRates();
        }
        if ('Album' == $relationName) {
            $this->initAlbums();
        }
        if ('FriendRelatedByUserId' == $relationName) {
            $this->initFriendsRelatedByUserId();
        }
        if ('FriendRelatedByFriendId' == $relationName) {
            $this->initFriendsRelatedByFriendId();
        }
        if ('MessageRelatedByFromUserid' == $relationName) {
            $this->initMessagesRelatedByFromUserid();
        }
        if ('MessageRelatedByToUserid' == $relationName) {
            $this->initMessagesRelatedByToUserid();
        }
        if ('Photo' == $relationName) {
            $this->initPhotos();
        }
        if ('PhotoComment' == $relationName) {
            $this->initPhotoComments();
        }
        if ('PhotoTag' == $relationName) {
            $this->initPhotoTags();
        }
        if ('PhotoFav' == $relationName) {
            $this->initPhotoFavs();
        }
        if ('PhotoVote' == $relationName) {
            $this->initPhotoVotes();
        }
        if ('PhotoRate' == $relationName) {
            $this->initPhotoRates();
        }
        if ('SchoolUser' == $relationName) {
            $this->initSchoolUsers();
        }
        if ('Updates' == $relationName) {
            $this->initUpdatess();
        }
        if ('IgnorelistRelatedByUserId' == $relationName) {
            $this->initIgnorelistsRelatedByUserId();
        }
        if ('IgnorelistRelatedByIgnoredUserId' == $relationName) {
            $this->initIgnorelistsRelatedByIgnoredUserId();
        }
        if ('Sessions' == $relationName) {
            $this->initSessionss();
        }
        if ('GuestRelatedByUserId' == $relationName) {
            $this->initGuestsRelatedByUserId();
        }
        if ('GuestRelatedByGuestId' == $relationName) {
            $this->initGuestsRelatedByGuestId();
        }
        if ('GameUser' == $relationName) {
            $this->initGameUsers();
        }
        if ('Music' == $relationName) {
            $this->initMusics();
        }
        if ('Playlist' == $relationName) {
            $this->initPlaylists();
        }
        if ('PlaylistComment' == $relationName) {
            $this->initPlaylistComments();
        }
        if ('PlaylistFav' == $relationName) {
            $this->initPlaylistFavs();
        }
        if ('YtvideoFav' == $relationName) {
            $this->initYtvideoFavs();
        }
        if ('Videolist' == $relationName) {
            $this->initVideolists();
        }
        if ('UserLink' == $relationName) {
            $this->initUserLinks();
        }
        if ('UserLinkComment' == $relationName) {
            $this->initUserLinkComments();
        }
        if ('sfGuardUserPermission' == $relationName) {
            $this->initsfGuardUserPermissions();
        }
        if ('sfGuardUserGroup' == $relationName) {
            $this->initsfGuardUserGroups();
        }
        if ('sfGuardRememberKey' == $relationName) {
            $this->initsfGuardRememberKeys();
        }
        if ('sfGuardUserProfile' == $relationName) {
            $this->initsfGuardUserProfiles();
        }
        if ('sfGuardUserStatus' == $relationName) {
            $this->initsfGuardUserStatuss();
        }
        if ('sfGuardUserStatusComment' == $relationName) {
            $this->initsfGuardUserStatusComments();
        }
        if ('sfSocialEvent' == $relationName) {
            $this->initsfSocialEvents();
        }
        if ('sfSocialEventInviteRelatedByUserId' == $relationName) {
            $this->initsfSocialEventInvitesRelatedByUserId();
        }
        if ('sfSocialEventInviteRelatedByUserFrom' == $relationName) {
            $this->initsfSocialEventInvitesRelatedByUserFrom();
        }
        if ('sfSocialEventUser' == $relationName) {
            $this->initsfSocialEventUsers();
        }
        if ('sfSocialGroup' == $relationName) {
            $this->initsfSocialGroups();
        }
        if ('sfSocialGroupInviteRelatedByUserId' == $relationName) {
            $this->initsfSocialGroupInvitesRelatedByUserId();
        }
        if ('sfSocialGroupInviteRelatedByUserFrom' == $relationName) {
            $this->initsfSocialGroupInvitesRelatedByUserFrom();
        }
        if ('sfSocialGroupUser' == $relationName) {
            $this->initsfSocialGroupUsers();
        }
        if ('GroupStatusComment' == $relationName) {
            $this->initGroupStatusComments();
        }
        if ('EventStatus' == $relationName) {
            $this->initEventStatuss();
        }
    }

    /**
     * Clears out the collBizness collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addBizness()
     */
    public function clearBizness()
    {
        $this->collBizness = null; // important to set this to null since that means it is uninitialized
        $this->collBiznessPartial = null;
    }

    /**
     * reset is the collBizness collection loaded partially
     *
     * @return void
     */
    public function resetPartialBizness($v = true)
    {
        $this->collBiznessPartial = $v;
    }

    /**
     * Initializes the collBizness collection.
     *
     * By default this just sets the collBizness collection to an empty array (like clearcollBizness());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initBizness($overrideExisting = true)
    {
        if (null !== $this->collBizness && !$overrideExisting) {
            return;
        }
        $this->collBizness = new PropelObjectCollection();
        $this->collBizness->setModel('Biznes');
    }

    /**
     * Gets an array of Biznes objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|Biznes[] List of Biznes objects
     * @throws PropelException
     */
    public function getBizness($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collBiznessPartial && !$this->isNew();
        if (null === $this->collBizness || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collBizness) {
                // return empty collection
                $this->initBizness();
            } else {
                $collBizness = BiznesQuery::create(null, $criteria)
                    ->filterBysfGuardUser($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collBiznessPartial && count($collBizness)) {
                      $this->initBizness(false);

                      foreach($collBizness as $obj) {
                        if (false == $this->collBizness->contains($obj)) {
                          $this->collBizness->append($obj);
                        }
                      }

                      $this->collBiznessPartial = true;
                    }

                    return $collBizness;
                }

                if($partial && $this->collBizness) {
                    foreach($this->collBizness as $obj) {
                        if($obj->isNew()) {
                            $collBizness[] = $obj;
                        }
                    }
                }

                $this->collBizness = $collBizness;
                $this->collBiznessPartial = false;
            }
        }

        return $this->collBizness;
    }

    /**
     * Sets a collection of Biznes objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $bizness A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setBizness(PropelCollection $bizness, PropelPDO $con = null)
    {
        $this->biznessScheduledForDeletion = $this->getBizness(new Criteria(), $con)->diff($bizness);

        foreach ($this->biznessScheduledForDeletion as $biznesRemoved) {
            $biznesRemoved->setsfGuardUser(null);
        }

        $this->collBizness = null;
        foreach ($bizness as $biznes) {
            $this->addBiznes($biznes);
        }

        $this->collBizness = $bizness;
        $this->collBiznessPartial = false;
    }

    /**
     * Returns the number of related Biznes objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related Biznes objects.
     * @throws PropelException
     */
    public function countBizness(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collBiznessPartial && !$this->isNew();
        if (null === $this->collBizness || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collBizness) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getBizness());
                }
                $query = BiznesQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUser($this)
                    ->count($con);
            }
        } else {
            return count($this->collBizness);
        }
    }

    /**
     * Method called to associate a Biznes object to this object
     * through the Biznes foreign key attribute.
     *
     * @param    Biznes $l Biznes
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addBiznes(Biznes $l)
    {
        if ($this->collBizness === null) {
            $this->initBizness();
            $this->collBiznessPartial = true;
        }
        if (!$this->collBizness->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddBiznes($l);
        }

        return $this;
    }

    /**
     * @param	Biznes $biznes The biznes object to add.
     */
    protected function doAddBiznes($biznes)
    {
        $this->collBizness[]= $biznes;
        $biznes->setsfGuardUser($this);
    }

    /**
     * @param	Biznes $biznes The biznes object to remove.
     */
    public function removeBiznes($biznes)
    {
        if ($this->getBizness()->contains($biznes)) {
            $this->collBizness->remove($this->collBizness->search($biznes));
            if (null === $this->biznessScheduledForDeletion) {
                $this->biznessScheduledForDeletion = clone $this->collBizness;
                $this->biznessScheduledForDeletion->clear();
            }
            $this->biznessScheduledForDeletion[]= $biznes;
            $biznes->setsfGuardUser(null);
        }
    }

    /**
     * Clears out the collBiznesComments collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addBiznesComments()
     */
    public function clearBiznesComments()
    {
        $this->collBiznesComments = null; // important to set this to null since that means it is uninitialized
        $this->collBiznesCommentsPartial = null;
    }

    /**
     * reset is the collBiznesComments collection loaded partially
     *
     * @return void
     */
    public function resetPartialBiznesComments($v = true)
    {
        $this->collBiznesCommentsPartial = $v;
    }

    /**
     * Initializes the collBiznesComments collection.
     *
     * By default this just sets the collBiznesComments collection to an empty array (like clearcollBiznesComments());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initBiznesComments($overrideExisting = true)
    {
        if (null !== $this->collBiznesComments && !$overrideExisting) {
            return;
        }
        $this->collBiznesComments = new PropelObjectCollection();
        $this->collBiznesComments->setModel('BiznesComment');
    }

    /**
     * Gets an array of BiznesComment objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|BiznesComment[] List of BiznesComment objects
     * @throws PropelException
     */
    public function getBiznesComments($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collBiznesCommentsPartial && !$this->isNew();
        if (null === $this->collBiznesComments || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collBiznesComments) {
                // return empty collection
                $this->initBiznesComments();
            } else {
                $collBiznesComments = BiznesCommentQuery::create(null, $criteria)
                    ->filterBysfGuardUser($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collBiznesCommentsPartial && count($collBiznesComments)) {
                      $this->initBiznesComments(false);

                      foreach($collBiznesComments as $obj) {
                        if (false == $this->collBiznesComments->contains($obj)) {
                          $this->collBiznesComments->append($obj);
                        }
                      }

                      $this->collBiznesCommentsPartial = true;
                    }

                    return $collBiznesComments;
                }

                if($partial && $this->collBiznesComments) {
                    foreach($this->collBiznesComments as $obj) {
                        if($obj->isNew()) {
                            $collBiznesComments[] = $obj;
                        }
                    }
                }

                $this->collBiznesComments = $collBiznesComments;
                $this->collBiznesCommentsPartial = false;
            }
        }

        return $this->collBiznesComments;
    }

    /**
     * Sets a collection of BiznesComment objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $biznesComments A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setBiznesComments(PropelCollection $biznesComments, PropelPDO $con = null)
    {
        $this->biznesCommentsScheduledForDeletion = $this->getBiznesComments(new Criteria(), $con)->diff($biznesComments);

        foreach ($this->biznesCommentsScheduledForDeletion as $biznesCommentRemoved) {
            $biznesCommentRemoved->setsfGuardUser(null);
        }

        $this->collBiznesComments = null;
        foreach ($biznesComments as $biznesComment) {
            $this->addBiznesComment($biznesComment);
        }

        $this->collBiznesComments = $biznesComments;
        $this->collBiznesCommentsPartial = false;
    }

    /**
     * Returns the number of related BiznesComment objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related BiznesComment objects.
     * @throws PropelException
     */
    public function countBiznesComments(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collBiznesCommentsPartial && !$this->isNew();
        if (null === $this->collBiznesComments || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collBiznesComments) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getBiznesComments());
                }
                $query = BiznesCommentQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUser($this)
                    ->count($con);
            }
        } else {
            return count($this->collBiznesComments);
        }
    }

    /**
     * Method called to associate a BiznesComment object to this object
     * through the BiznesComment foreign key attribute.
     *
     * @param    BiznesComment $l BiznesComment
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addBiznesComment(BiznesComment $l)
    {
        if ($this->collBiznesComments === null) {
            $this->initBiznesComments();
            $this->collBiznesCommentsPartial = true;
        }
        if (!$this->collBiznesComments->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddBiznesComment($l);
        }

        return $this;
    }

    /**
     * @param	BiznesComment $biznesComment The biznesComment object to add.
     */
    protected function doAddBiznesComment($biznesComment)
    {
        $this->collBiznesComments[]= $biznesComment;
        $biznesComment->setsfGuardUser($this);
    }

    /**
     * @param	BiznesComment $biznesComment The biznesComment object to remove.
     */
    public function removeBiznesComment($biznesComment)
    {
        if ($this->getBiznesComments()->contains($biznesComment)) {
            $this->collBiznesComments->remove($this->collBiznesComments->search($biznesComment));
            if (null === $this->biznesCommentsScheduledForDeletion) {
                $this->biznesCommentsScheduledForDeletion = clone $this->collBiznesComments;
                $this->biznesCommentsScheduledForDeletion->clear();
            }
            $this->biznesCommentsScheduledForDeletion[]= $biznesComment;
            $biznesComment->setsfGuardUser(null);
        }
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this sfGuardUser is new, it will return
     * an empty collection; or if this sfGuardUser has previously
     * been saved, it will retrieve related BiznesComments from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in sfGuardUser.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @param string $join_behavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return PropelObjectCollection|BiznesComment[] List of BiznesComment objects
     */
    public function getBiznesCommentsJoinBiznes($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
    {
        $query = BiznesCommentQuery::create(null, $criteria);
        $query->joinWith('Biznes', $join_behavior);

        return $this->getBiznesComments($query, $con);
    }

    /**
     * Clears out the collBiznesTags collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addBiznesTags()
     */
    public function clearBiznesTags()
    {
        $this->collBiznesTags = null; // important to set this to null since that means it is uninitialized
        $this->collBiznesTagsPartial = null;
    }

    /**
     * reset is the collBiznesTags collection loaded partially
     *
     * @return void
     */
    public function resetPartialBiznesTags($v = true)
    {
        $this->collBiznesTagsPartial = $v;
    }

    /**
     * Initializes the collBiznesTags collection.
     *
     * By default this just sets the collBiznesTags collection to an empty array (like clearcollBiznesTags());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initBiznesTags($overrideExisting = true)
    {
        if (null !== $this->collBiznesTags && !$overrideExisting) {
            return;
        }
        $this->collBiznesTags = new PropelObjectCollection();
        $this->collBiznesTags->setModel('BiznesTag');
    }

    /**
     * Gets an array of BiznesTag objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|BiznesTag[] List of BiznesTag objects
     * @throws PropelException
     */
    public function getBiznesTags($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collBiznesTagsPartial && !$this->isNew();
        if (null === $this->collBiznesTags || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collBiznesTags) {
                // return empty collection
                $this->initBiznesTags();
            } else {
                $collBiznesTags = BiznesTagQuery::create(null, $criteria)
                    ->filterBysfGuardUser($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collBiznesTagsPartial && count($collBiznesTags)) {
                      $this->initBiznesTags(false);

                      foreach($collBiznesTags as $obj) {
                        if (false == $this->collBiznesTags->contains($obj)) {
                          $this->collBiznesTags->append($obj);
                        }
                      }

                      $this->collBiznesTagsPartial = true;
                    }

                    return $collBiznesTags;
                }

                if($partial && $this->collBiznesTags) {
                    foreach($this->collBiznesTags as $obj) {
                        if($obj->isNew()) {
                            $collBiznesTags[] = $obj;
                        }
                    }
                }

                $this->collBiznesTags = $collBiznesTags;
                $this->collBiznesTagsPartial = false;
            }
        }

        return $this->collBiznesTags;
    }

    /**
     * Sets a collection of BiznesTag objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $biznesTags A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setBiznesTags(PropelCollection $biznesTags, PropelPDO $con = null)
    {
        $this->biznesTagsScheduledForDeletion = $this->getBiznesTags(new Criteria(), $con)->diff($biznesTags);

        foreach ($this->biznesTagsScheduledForDeletion as $biznesTagRemoved) {
            $biznesTagRemoved->setsfGuardUser(null);
        }

        $this->collBiznesTags = null;
        foreach ($biznesTags as $biznesTag) {
            $this->addBiznesTag($biznesTag);
        }

        $this->collBiznesTags = $biznesTags;
        $this->collBiznesTagsPartial = false;
    }

    /**
     * Returns the number of related BiznesTag objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related BiznesTag objects.
     * @throws PropelException
     */
    public function countBiznesTags(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collBiznesTagsPartial && !$this->isNew();
        if (null === $this->collBiznesTags || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collBiznesTags) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getBiznesTags());
                }
                $query = BiznesTagQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUser($this)
                    ->count($con);
            }
        } else {
            return count($this->collBiznesTags);
        }
    }

    /**
     * Method called to associate a BiznesTag object to this object
     * through the BiznesTag foreign key attribute.
     *
     * @param    BiznesTag $l BiznesTag
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addBiznesTag(BiznesTag $l)
    {
        if ($this->collBiznesTags === null) {
            $this->initBiznesTags();
            $this->collBiznesTagsPartial = true;
        }
        if (!$this->collBiznesTags->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddBiznesTag($l);
        }

        return $this;
    }

    /**
     * @param	BiznesTag $biznesTag The biznesTag object to add.
     */
    protected function doAddBiznesTag($biznesTag)
    {
        $this->collBiznesTags[]= $biznesTag;
        $biznesTag->setsfGuardUser($this);
    }

    /**
     * @param	BiznesTag $biznesTag The biznesTag object to remove.
     */
    public function removeBiznesTag($biznesTag)
    {
        if ($this->getBiznesTags()->contains($biznesTag)) {
            $this->collBiznesTags->remove($this->collBiznesTags->search($biznesTag));
            if (null === $this->biznesTagsScheduledForDeletion) {
                $this->biznesTagsScheduledForDeletion = clone $this->collBiznesTags;
                $this->biznesTagsScheduledForDeletion->clear();
            }
            $this->biznesTagsScheduledForDeletion[]= $biznesTag;
            $biznesTag->setsfGuardUser(null);
        }
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this sfGuardUser is new, it will return
     * an empty collection; or if this sfGuardUser has previously
     * been saved, it will retrieve related BiznesTags from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in sfGuardUser.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @param string $join_behavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return PropelObjectCollection|BiznesTag[] List of BiznesTag objects
     */
    public function getBiznesTagsJoinBiznes($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
    {
        $query = BiznesTagQuery::create(null, $criteria);
        $query->joinWith('Biznes', $join_behavior);

        return $this->getBiznesTags($query, $con);
    }

    /**
     * Clears out the collBiznesFavs collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addBiznesFavs()
     */
    public function clearBiznesFavs()
    {
        $this->collBiznesFavs = null; // important to set this to null since that means it is uninitialized
        $this->collBiznesFavsPartial = null;
    }

    /**
     * reset is the collBiznesFavs collection loaded partially
     *
     * @return void
     */
    public function resetPartialBiznesFavs($v = true)
    {
        $this->collBiznesFavsPartial = $v;
    }

    /**
     * Initializes the collBiznesFavs collection.
     *
     * By default this just sets the collBiznesFavs collection to an empty array (like clearcollBiznesFavs());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initBiznesFavs($overrideExisting = true)
    {
        if (null !== $this->collBiznesFavs && !$overrideExisting) {
            return;
        }
        $this->collBiznesFavs = new PropelObjectCollection();
        $this->collBiznesFavs->setModel('BiznesFav');
    }

    /**
     * Gets an array of BiznesFav objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|BiznesFav[] List of BiznesFav objects
     * @throws PropelException
     */
    public function getBiznesFavs($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collBiznesFavsPartial && !$this->isNew();
        if (null === $this->collBiznesFavs || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collBiznesFavs) {
                // return empty collection
                $this->initBiznesFavs();
            } else {
                $collBiznesFavs = BiznesFavQuery::create(null, $criteria)
                    ->filterBysfGuardUser($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collBiznesFavsPartial && count($collBiznesFavs)) {
                      $this->initBiznesFavs(false);

                      foreach($collBiznesFavs as $obj) {
                        if (false == $this->collBiznesFavs->contains($obj)) {
                          $this->collBiznesFavs->append($obj);
                        }
                      }

                      $this->collBiznesFavsPartial = true;
                    }

                    return $collBiznesFavs;
                }

                if($partial && $this->collBiznesFavs) {
                    foreach($this->collBiznesFavs as $obj) {
                        if($obj->isNew()) {
                            $collBiznesFavs[] = $obj;
                        }
                    }
                }

                $this->collBiznesFavs = $collBiznesFavs;
                $this->collBiznesFavsPartial = false;
            }
        }

        return $this->collBiznesFavs;
    }

    /**
     * Sets a collection of BiznesFav objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $biznesFavs A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setBiznesFavs(PropelCollection $biznesFavs, PropelPDO $con = null)
    {
        $this->biznesFavsScheduledForDeletion = $this->getBiznesFavs(new Criteria(), $con)->diff($biznesFavs);

        foreach ($this->biznesFavsScheduledForDeletion as $biznesFavRemoved) {
            $biznesFavRemoved->setsfGuardUser(null);
        }

        $this->collBiznesFavs = null;
        foreach ($biznesFavs as $biznesFav) {
            $this->addBiznesFav($biznesFav);
        }

        $this->collBiznesFavs = $biznesFavs;
        $this->collBiznesFavsPartial = false;
    }

    /**
     * Returns the number of related BiznesFav objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related BiznesFav objects.
     * @throws PropelException
     */
    public function countBiznesFavs(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collBiznesFavsPartial && !$this->isNew();
        if (null === $this->collBiznesFavs || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collBiznesFavs) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getBiznesFavs());
                }
                $query = BiznesFavQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUser($this)
                    ->count($con);
            }
        } else {
            return count($this->collBiznesFavs);
        }
    }

    /**
     * Method called to associate a BiznesFav object to this object
     * through the BiznesFav foreign key attribute.
     *
     * @param    BiznesFav $l BiznesFav
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addBiznesFav(BiznesFav $l)
    {
        if ($this->collBiznesFavs === null) {
            $this->initBiznesFavs();
            $this->collBiznesFavsPartial = true;
        }
        if (!$this->collBiznesFavs->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddBiznesFav($l);
        }

        return $this;
    }

    /**
     * @param	BiznesFav $biznesFav The biznesFav object to add.
     */
    protected function doAddBiznesFav($biznesFav)
    {
        $this->collBiznesFavs[]= $biznesFav;
        $biznesFav->setsfGuardUser($this);
    }

    /**
     * @param	BiznesFav $biznesFav The biznesFav object to remove.
     */
    public function removeBiznesFav($biznesFav)
    {
        if ($this->getBiznesFavs()->contains($biznesFav)) {
            $this->collBiznesFavs->remove($this->collBiznesFavs->search($biznesFav));
            if (null === $this->biznesFavsScheduledForDeletion) {
                $this->biznesFavsScheduledForDeletion = clone $this->collBiznesFavs;
                $this->biznesFavsScheduledForDeletion->clear();
            }
            $this->biznesFavsScheduledForDeletion[]= $biznesFav;
            $biznesFav->setsfGuardUser(null);
        }
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this sfGuardUser is new, it will return
     * an empty collection; or if this sfGuardUser has previously
     * been saved, it will retrieve related BiznesFavs from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in sfGuardUser.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @param string $join_behavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return PropelObjectCollection|BiznesFav[] List of BiznesFav objects
     */
    public function getBiznesFavsJoinBiznes($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
    {
        $query = BiznesFavQuery::create(null, $criteria);
        $query->joinWith('Biznes', $join_behavior);

        return $this->getBiznesFavs($query, $con);
    }

    /**
     * Clears out the collBiznesRates collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addBiznesRates()
     */
    public function clearBiznesRates()
    {
        $this->collBiznesRates = null; // important to set this to null since that means it is uninitialized
        $this->collBiznesRatesPartial = null;
    }

    /**
     * reset is the collBiznesRates collection loaded partially
     *
     * @return void
     */
    public function resetPartialBiznesRates($v = true)
    {
        $this->collBiznesRatesPartial = $v;
    }

    /**
     * Initializes the collBiznesRates collection.
     *
     * By default this just sets the collBiznesRates collection to an empty array (like clearcollBiznesRates());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initBiznesRates($overrideExisting = true)
    {
        if (null !== $this->collBiznesRates && !$overrideExisting) {
            return;
        }
        $this->collBiznesRates = new PropelObjectCollection();
        $this->collBiznesRates->setModel('BiznesRate');
    }

    /**
     * Gets an array of BiznesRate objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|BiznesRate[] List of BiznesRate objects
     * @throws PropelException
     */
    public function getBiznesRates($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collBiznesRatesPartial && !$this->isNew();
        if (null === $this->collBiznesRates || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collBiznesRates) {
                // return empty collection
                $this->initBiznesRates();
            } else {
                $collBiznesRates = BiznesRateQuery::create(null, $criteria)
                    ->filterBysfGuardUser($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collBiznesRatesPartial && count($collBiznesRates)) {
                      $this->initBiznesRates(false);

                      foreach($collBiznesRates as $obj) {
                        if (false == $this->collBiznesRates->contains($obj)) {
                          $this->collBiznesRates->append($obj);
                        }
                      }

                      $this->collBiznesRatesPartial = true;
                    }

                    return $collBiznesRates;
                }

                if($partial && $this->collBiznesRates) {
                    foreach($this->collBiznesRates as $obj) {
                        if($obj->isNew()) {
                            $collBiznesRates[] = $obj;
                        }
                    }
                }

                $this->collBiznesRates = $collBiznesRates;
                $this->collBiznesRatesPartial = false;
            }
        }

        return $this->collBiznesRates;
    }

    /**
     * Sets a collection of BiznesRate objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $biznesRates A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setBiznesRates(PropelCollection $biznesRates, PropelPDO $con = null)
    {
        $this->biznesRatesScheduledForDeletion = $this->getBiznesRates(new Criteria(), $con)->diff($biznesRates);

        foreach ($this->biznesRatesScheduledForDeletion as $biznesRateRemoved) {
            $biznesRateRemoved->setsfGuardUser(null);
        }

        $this->collBiznesRates = null;
        foreach ($biznesRates as $biznesRate) {
            $this->addBiznesRate($biznesRate);
        }

        $this->collBiznesRates = $biznesRates;
        $this->collBiznesRatesPartial = false;
    }

    /**
     * Returns the number of related BiznesRate objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related BiznesRate objects.
     * @throws PropelException
     */
    public function countBiznesRates(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collBiznesRatesPartial && !$this->isNew();
        if (null === $this->collBiznesRates || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collBiznesRates) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getBiznesRates());
                }
                $query = BiznesRateQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUser($this)
                    ->count($con);
            }
        } else {
            return count($this->collBiznesRates);
        }
    }

    /**
     * Method called to associate a BiznesRate object to this object
     * through the BiznesRate foreign key attribute.
     *
     * @param    BiznesRate $l BiznesRate
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addBiznesRate(BiznesRate $l)
    {
        if ($this->collBiznesRates === null) {
            $this->initBiznesRates();
            $this->collBiznesRatesPartial = true;
        }
        if (!$this->collBiznesRates->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddBiznesRate($l);
        }

        return $this;
    }

    /**
     * @param	BiznesRate $biznesRate The biznesRate object to add.
     */
    protected function doAddBiznesRate($biznesRate)
    {
        $this->collBiznesRates[]= $biznesRate;
        $biznesRate->setsfGuardUser($this);
    }

    /**
     * @param	BiznesRate $biznesRate The biznesRate object to remove.
     */
    public function removeBiznesRate($biznesRate)
    {
        if ($this->getBiznesRates()->contains($biznesRate)) {
            $this->collBiznesRates->remove($this->collBiznesRates->search($biznesRate));
            if (null === $this->biznesRatesScheduledForDeletion) {
                $this->biznesRatesScheduledForDeletion = clone $this->collBiznesRates;
                $this->biznesRatesScheduledForDeletion->clear();
            }
            $this->biznesRatesScheduledForDeletion[]= $biznesRate;
            $biznesRate->setsfGuardUser(null);
        }
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this sfGuardUser is new, it will return
     * an empty collection; or if this sfGuardUser has previously
     * been saved, it will retrieve related BiznesRates from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in sfGuardUser.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @param string $join_behavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return PropelObjectCollection|BiznesRate[] List of BiznesRate objects
     */
    public function getBiznesRatesJoinBiznes($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
    {
        $query = BiznesRateQuery::create(null, $criteria);
        $query->joinWith('Biznes', $join_behavior);

        return $this->getBiznesRates($query, $con);
    }

    /**
     * Clears out the collAlbums collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addAlbums()
     */
    public function clearAlbums()
    {
        $this->collAlbums = null; // important to set this to null since that means it is uninitialized
        $this->collAlbumsPartial = null;
    }

    /**
     * reset is the collAlbums collection loaded partially
     *
     * @return void
     */
    public function resetPartialAlbums($v = true)
    {
        $this->collAlbumsPartial = $v;
    }

    /**
     * Initializes the collAlbums collection.
     *
     * By default this just sets the collAlbums collection to an empty array (like clearcollAlbums());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initAlbums($overrideExisting = true)
    {
        if (null !== $this->collAlbums && !$overrideExisting) {
            return;
        }
        $this->collAlbums = new PropelObjectCollection();
        $this->collAlbums->setModel('Album');
    }

    /**
     * Gets an array of Album objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|Album[] List of Album objects
     * @throws PropelException
     */
    public function getAlbums($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collAlbumsPartial && !$this->isNew();
        if (null === $this->collAlbums || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collAlbums) {
                // return empty collection
                $this->initAlbums();
            } else {
                $collAlbums = AlbumQuery::create(null, $criteria)
                    ->filterBysfGuardUser($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collAlbumsPartial && count($collAlbums)) {
                      $this->initAlbums(false);

                      foreach($collAlbums as $obj) {
                        if (false == $this->collAlbums->contains($obj)) {
                          $this->collAlbums->append($obj);
                        }
                      }

                      $this->collAlbumsPartial = true;
                    }

                    return $collAlbums;
                }

                if($partial && $this->collAlbums) {
                    foreach($this->collAlbums as $obj) {
                        if($obj->isNew()) {
                            $collAlbums[] = $obj;
                        }
                    }
                }

                $this->collAlbums = $collAlbums;
                $this->collAlbumsPartial = false;
            }
        }

        return $this->collAlbums;
    }

    /**
     * Sets a collection of Album objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $albums A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setAlbums(PropelCollection $albums, PropelPDO $con = null)
    {
        $this->albumsScheduledForDeletion = $this->getAlbums(new Criteria(), $con)->diff($albums);

        foreach ($this->albumsScheduledForDeletion as $albumRemoved) {
            $albumRemoved->setsfGuardUser(null);
        }

        $this->collAlbums = null;
        foreach ($albums as $album) {
            $this->addAlbum($album);
        }

        $this->collAlbums = $albums;
        $this->collAlbumsPartial = false;
    }

    /**
     * Returns the number of related Album objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related Album objects.
     * @throws PropelException
     */
    public function countAlbums(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collAlbumsPartial && !$this->isNew();
        if (null === $this->collAlbums || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collAlbums) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getAlbums());
                }
                $query = AlbumQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUser($this)
                    ->count($con);
            }
        } else {
            return count($this->collAlbums);
        }
    }

    /**
     * Method called to associate a Album object to this object
     * through the Album foreign key attribute.
     *
     * @param    Album $l Album
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addAlbum(Album $l)
    {
        if ($this->collAlbums === null) {
            $this->initAlbums();
            $this->collAlbumsPartial = true;
        }
        if (!$this->collAlbums->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddAlbum($l);
        }

        return $this;
    }

    /**
     * @param	Album $album The album object to add.
     */
    protected function doAddAlbum($album)
    {
        $this->collAlbums[]= $album;
        $album->setsfGuardUser($this);
    }

    /**
     * @param	Album $album The album object to remove.
     */
    public function removeAlbum($album)
    {
        if ($this->getAlbums()->contains($album)) {
            $this->collAlbums->remove($this->collAlbums->search($album));
            if (null === $this->albumsScheduledForDeletion) {
                $this->albumsScheduledForDeletion = clone $this->collAlbums;
                $this->albumsScheduledForDeletion->clear();
            }
            $this->albumsScheduledForDeletion[]= $album;
            $album->setsfGuardUser(null);
        }
    }

    /**
     * Clears out the collFriendsRelatedByUserId collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addFriendsRelatedByUserId()
     */
    public function clearFriendsRelatedByUserId()
    {
        $this->collFriendsRelatedByUserId = null; // important to set this to null since that means it is uninitialized
        $this->collFriendsRelatedByUserIdPartial = null;
    }

    /**
     * reset is the collFriendsRelatedByUserId collection loaded partially
     *
     * @return void
     */
    public function resetPartialFriendsRelatedByUserId($v = true)
    {
        $this->collFriendsRelatedByUserIdPartial = $v;
    }

    /**
     * Initializes the collFriendsRelatedByUserId collection.
     *
     * By default this just sets the collFriendsRelatedByUserId collection to an empty array (like clearcollFriendsRelatedByUserId());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initFriendsRelatedByUserId($overrideExisting = true)
    {
        if (null !== $this->collFriendsRelatedByUserId && !$overrideExisting) {
            return;
        }
        $this->collFriendsRelatedByUserId = new PropelObjectCollection();
        $this->collFriendsRelatedByUserId->setModel('Friend');
    }

    /**
     * Gets an array of Friend objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|Friend[] List of Friend objects
     * @throws PropelException
     */
    public function getFriendsRelatedByUserId($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collFriendsRelatedByUserIdPartial && !$this->isNew();
        if (null === $this->collFriendsRelatedByUserId || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collFriendsRelatedByUserId) {
                // return empty collection
                $this->initFriendsRelatedByUserId();
            } else {
                $collFriendsRelatedByUserId = FriendQuery::create(null, $criteria)
                    ->filterBysfGuardUserRelatedByUserId($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collFriendsRelatedByUserIdPartial && count($collFriendsRelatedByUserId)) {
                      $this->initFriendsRelatedByUserId(false);

                      foreach($collFriendsRelatedByUserId as $obj) {
                        if (false == $this->collFriendsRelatedByUserId->contains($obj)) {
                          $this->collFriendsRelatedByUserId->append($obj);
                        }
                      }

                      $this->collFriendsRelatedByUserIdPartial = true;
                    }

                    return $collFriendsRelatedByUserId;
                }

                if($partial && $this->collFriendsRelatedByUserId) {
                    foreach($this->collFriendsRelatedByUserId as $obj) {
                        if($obj->isNew()) {
                            $collFriendsRelatedByUserId[] = $obj;
                        }
                    }
                }

                $this->collFriendsRelatedByUserId = $collFriendsRelatedByUserId;
                $this->collFriendsRelatedByUserIdPartial = false;
            }
        }

        return $this->collFriendsRelatedByUserId;
    }

    /**
     * Sets a collection of FriendRelatedByUserId objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $friendsRelatedByUserId A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setFriendsRelatedByUserId(PropelCollection $friendsRelatedByUserId, PropelPDO $con = null)
    {
        $this->friendsRelatedByUserIdScheduledForDeletion = $this->getFriendsRelatedByUserId(new Criteria(), $con)->diff($friendsRelatedByUserId);

        foreach ($this->friendsRelatedByUserIdScheduledForDeletion as $friendRelatedByUserIdRemoved) {
            $friendRelatedByUserIdRemoved->setsfGuardUserRelatedByUserId(null);
        }

        $this->collFriendsRelatedByUserId = null;
        foreach ($friendsRelatedByUserId as $friendRelatedByUserId) {
            $this->addFriendRelatedByUserId($friendRelatedByUserId);
        }

        $this->collFriendsRelatedByUserId = $friendsRelatedByUserId;
        $this->collFriendsRelatedByUserIdPartial = false;
    }

    /**
     * Returns the number of related Friend objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related Friend objects.
     * @throws PropelException
     */
    public function countFriendsRelatedByUserId(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collFriendsRelatedByUserIdPartial && !$this->isNew();
        if (null === $this->collFriendsRelatedByUserId || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collFriendsRelatedByUserId) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getFriendsRelatedByUserId());
                }
                $query = FriendQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUserRelatedByUserId($this)
                    ->count($con);
            }
        } else {
            return count($this->collFriendsRelatedByUserId);
        }
    }

    /**
     * Method called to associate a Friend object to this object
     * through the Friend foreign key attribute.
     *
     * @param    Friend $l Friend
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addFriendRelatedByUserId(Friend $l)
    {
        if ($this->collFriendsRelatedByUserId === null) {
            $this->initFriendsRelatedByUserId();
            $this->collFriendsRelatedByUserIdPartial = true;
        }
        if (!$this->collFriendsRelatedByUserId->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddFriendRelatedByUserId($l);
        }

        return $this;
    }

    /**
     * @param	FriendRelatedByUserId $friendRelatedByUserId The friendRelatedByUserId object to add.
     */
    protected function doAddFriendRelatedByUserId($friendRelatedByUserId)
    {
        $this->collFriendsRelatedByUserId[]= $friendRelatedByUserId;
        $friendRelatedByUserId->setsfGuardUserRelatedByUserId($this);
    }

    /**
     * @param	FriendRelatedByUserId $friendRelatedByUserId The friendRelatedByUserId object to remove.
     */
    public function removeFriendRelatedByUserId($friendRelatedByUserId)
    {
        if ($this->getFriendsRelatedByUserId()->contains($friendRelatedByUserId)) {
            $this->collFriendsRelatedByUserId->remove($this->collFriendsRelatedByUserId->search($friendRelatedByUserId));
            if (null === $this->friendsRelatedByUserIdScheduledForDeletion) {
                $this->friendsRelatedByUserIdScheduledForDeletion = clone $this->collFriendsRelatedByUserId;
                $this->friendsRelatedByUserIdScheduledForDeletion->clear();
            }
            $this->friendsRelatedByUserIdScheduledForDeletion[]= $friendRelatedByUserId;
            $friendRelatedByUserId->setsfGuardUserRelatedByUserId(null);
        }
    }

    /**
     * Clears out the collFriendsRelatedByFriendId collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addFriendsRelatedByFriendId()
     */
    public function clearFriendsRelatedByFriendId()
    {
        $this->collFriendsRelatedByFriendId = null; // important to set this to null since that means it is uninitialized
        $this->collFriendsRelatedByFriendIdPartial = null;
    }

    /**
     * reset is the collFriendsRelatedByFriendId collection loaded partially
     *
     * @return void
     */
    public function resetPartialFriendsRelatedByFriendId($v = true)
    {
        $this->collFriendsRelatedByFriendIdPartial = $v;
    }

    /**
     * Initializes the collFriendsRelatedByFriendId collection.
     *
     * By default this just sets the collFriendsRelatedByFriendId collection to an empty array (like clearcollFriendsRelatedByFriendId());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initFriendsRelatedByFriendId($overrideExisting = true)
    {
        if (null !== $this->collFriendsRelatedByFriendId && !$overrideExisting) {
            return;
        }
        $this->collFriendsRelatedByFriendId = new PropelObjectCollection();
        $this->collFriendsRelatedByFriendId->setModel('Friend');
    }

    /**
     * Gets an array of Friend objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|Friend[] List of Friend objects
     * @throws PropelException
     */
    public function getFriendsRelatedByFriendId($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collFriendsRelatedByFriendIdPartial && !$this->isNew();
        if (null === $this->collFriendsRelatedByFriendId || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collFriendsRelatedByFriendId) {
                // return empty collection
                $this->initFriendsRelatedByFriendId();
            } else {
                $collFriendsRelatedByFriendId = FriendQuery::create(null, $criteria)
                    ->filterBysfGuardUserRelatedByFriendId($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collFriendsRelatedByFriendIdPartial && count($collFriendsRelatedByFriendId)) {
                      $this->initFriendsRelatedByFriendId(false);

                      foreach($collFriendsRelatedByFriendId as $obj) {
                        if (false == $this->collFriendsRelatedByFriendId->contains($obj)) {
                          $this->collFriendsRelatedByFriendId->append($obj);
                        }
                      }

                      $this->collFriendsRelatedByFriendIdPartial = true;
                    }

                    return $collFriendsRelatedByFriendId;
                }

                if($partial && $this->collFriendsRelatedByFriendId) {
                    foreach($this->collFriendsRelatedByFriendId as $obj) {
                        if($obj->isNew()) {
                            $collFriendsRelatedByFriendId[] = $obj;
                        }
                    }
                }

                $this->collFriendsRelatedByFriendId = $collFriendsRelatedByFriendId;
                $this->collFriendsRelatedByFriendIdPartial = false;
            }
        }

        return $this->collFriendsRelatedByFriendId;
    }

    /**
     * Sets a collection of FriendRelatedByFriendId objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $friendsRelatedByFriendId A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setFriendsRelatedByFriendId(PropelCollection $friendsRelatedByFriendId, PropelPDO $con = null)
    {
        $this->friendsRelatedByFriendIdScheduledForDeletion = $this->getFriendsRelatedByFriendId(new Criteria(), $con)->diff($friendsRelatedByFriendId);

        foreach ($this->friendsRelatedByFriendIdScheduledForDeletion as $friendRelatedByFriendIdRemoved) {
            $friendRelatedByFriendIdRemoved->setsfGuardUserRelatedByFriendId(null);
        }

        $this->collFriendsRelatedByFriendId = null;
        foreach ($friendsRelatedByFriendId as $friendRelatedByFriendId) {
            $this->addFriendRelatedByFriendId($friendRelatedByFriendId);
        }

        $this->collFriendsRelatedByFriendId = $friendsRelatedByFriendId;
        $this->collFriendsRelatedByFriendIdPartial = false;
    }

    /**
     * Returns the number of related Friend objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related Friend objects.
     * @throws PropelException
     */
    public function countFriendsRelatedByFriendId(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collFriendsRelatedByFriendIdPartial && !$this->isNew();
        if (null === $this->collFriendsRelatedByFriendId || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collFriendsRelatedByFriendId) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getFriendsRelatedByFriendId());
                }
                $query = FriendQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUserRelatedByFriendId($this)
                    ->count($con);
            }
        } else {
            return count($this->collFriendsRelatedByFriendId);
        }
    }

    /**
     * Method called to associate a Friend object to this object
     * through the Friend foreign key attribute.
     *
     * @param    Friend $l Friend
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addFriendRelatedByFriendId(Friend $l)
    {
        if ($this->collFriendsRelatedByFriendId === null) {
            $this->initFriendsRelatedByFriendId();
            $this->collFriendsRelatedByFriendIdPartial = true;
        }
        if (!$this->collFriendsRelatedByFriendId->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddFriendRelatedByFriendId($l);
        }

        return $this;
    }

    /**
     * @param	FriendRelatedByFriendId $friendRelatedByFriendId The friendRelatedByFriendId object to add.
     */
    protected function doAddFriendRelatedByFriendId($friendRelatedByFriendId)
    {
        $this->collFriendsRelatedByFriendId[]= $friendRelatedByFriendId;
        $friendRelatedByFriendId->setsfGuardUserRelatedByFriendId($this);
    }

    /**
     * @param	FriendRelatedByFriendId $friendRelatedByFriendId The friendRelatedByFriendId object to remove.
     */
    public function removeFriendRelatedByFriendId($friendRelatedByFriendId)
    {
        if ($this->getFriendsRelatedByFriendId()->contains($friendRelatedByFriendId)) {
            $this->collFriendsRelatedByFriendId->remove($this->collFriendsRelatedByFriendId->search($friendRelatedByFriendId));
            if (null === $this->friendsRelatedByFriendIdScheduledForDeletion) {
                $this->friendsRelatedByFriendIdScheduledForDeletion = clone $this->collFriendsRelatedByFriendId;
                $this->friendsRelatedByFriendIdScheduledForDeletion->clear();
            }
            $this->friendsRelatedByFriendIdScheduledForDeletion[]= $friendRelatedByFriendId;
            $friendRelatedByFriendId->setsfGuardUserRelatedByFriendId(null);
        }
    }

    /**
     * Clears out the collMessagesRelatedByFromUserid collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addMessagesRelatedByFromUserid()
     */
    public function clearMessagesRelatedByFromUserid()
    {
        $this->collMessagesRelatedByFromUserid = null; // important to set this to null since that means it is uninitialized
        $this->collMessagesRelatedByFromUseridPartial = null;
    }

    /**
     * reset is the collMessagesRelatedByFromUserid collection loaded partially
     *
     * @return void
     */
    public function resetPartialMessagesRelatedByFromUserid($v = true)
    {
        $this->collMessagesRelatedByFromUseridPartial = $v;
    }

    /**
     * Initializes the collMessagesRelatedByFromUserid collection.
     *
     * By default this just sets the collMessagesRelatedByFromUserid collection to an empty array (like clearcollMessagesRelatedByFromUserid());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initMessagesRelatedByFromUserid($overrideExisting = true)
    {
        if (null !== $this->collMessagesRelatedByFromUserid && !$overrideExisting) {
            return;
        }
        $this->collMessagesRelatedByFromUserid = new PropelObjectCollection();
        $this->collMessagesRelatedByFromUserid->setModel('Message');
    }

    /**
     * Gets an array of Message objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|Message[] List of Message objects
     * @throws PropelException
     */
    public function getMessagesRelatedByFromUserid($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collMessagesRelatedByFromUseridPartial && !$this->isNew();
        if (null === $this->collMessagesRelatedByFromUserid || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collMessagesRelatedByFromUserid) {
                // return empty collection
                $this->initMessagesRelatedByFromUserid();
            } else {
                $collMessagesRelatedByFromUserid = MessageQuery::create(null, $criteria)
                    ->filterBysfGuardUserRelatedByFromUserid($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collMessagesRelatedByFromUseridPartial && count($collMessagesRelatedByFromUserid)) {
                      $this->initMessagesRelatedByFromUserid(false);

                      foreach($collMessagesRelatedByFromUserid as $obj) {
                        if (false == $this->collMessagesRelatedByFromUserid->contains($obj)) {
                          $this->collMessagesRelatedByFromUserid->append($obj);
                        }
                      }

                      $this->collMessagesRelatedByFromUseridPartial = true;
                    }

                    return $collMessagesRelatedByFromUserid;
                }

                if($partial && $this->collMessagesRelatedByFromUserid) {
                    foreach($this->collMessagesRelatedByFromUserid as $obj) {
                        if($obj->isNew()) {
                            $collMessagesRelatedByFromUserid[] = $obj;
                        }
                    }
                }

                $this->collMessagesRelatedByFromUserid = $collMessagesRelatedByFromUserid;
                $this->collMessagesRelatedByFromUseridPartial = false;
            }
        }

        return $this->collMessagesRelatedByFromUserid;
    }

    /**
     * Sets a collection of MessageRelatedByFromUserid objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $messagesRelatedByFromUserid A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setMessagesRelatedByFromUserid(PropelCollection $messagesRelatedByFromUserid, PropelPDO $con = null)
    {
        $this->messagesRelatedByFromUseridScheduledForDeletion = $this->getMessagesRelatedByFromUserid(new Criteria(), $con)->diff($messagesRelatedByFromUserid);

        foreach ($this->messagesRelatedByFromUseridScheduledForDeletion as $messageRelatedByFromUseridRemoved) {
            $messageRelatedByFromUseridRemoved->setsfGuardUserRelatedByFromUserid(null);
        }

        $this->collMessagesRelatedByFromUserid = null;
        foreach ($messagesRelatedByFromUserid as $messageRelatedByFromUserid) {
            $this->addMessageRelatedByFromUserid($messageRelatedByFromUserid);
        }

        $this->collMessagesRelatedByFromUserid = $messagesRelatedByFromUserid;
        $this->collMessagesRelatedByFromUseridPartial = false;
    }

    /**
     * Returns the number of related Message objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related Message objects.
     * @throws PropelException
     */
    public function countMessagesRelatedByFromUserid(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collMessagesRelatedByFromUseridPartial && !$this->isNew();
        if (null === $this->collMessagesRelatedByFromUserid || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collMessagesRelatedByFromUserid) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getMessagesRelatedByFromUserid());
                }
                $query = MessageQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUserRelatedByFromUserid($this)
                    ->count($con);
            }
        } else {
            return count($this->collMessagesRelatedByFromUserid);
        }
    }

    /**
     * Method called to associate a Message object to this object
     * through the Message foreign key attribute.
     *
     * @param    Message $l Message
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addMessageRelatedByFromUserid(Message $l)
    {
        if ($this->collMessagesRelatedByFromUserid === null) {
            $this->initMessagesRelatedByFromUserid();
            $this->collMessagesRelatedByFromUseridPartial = true;
        }
        if (!$this->collMessagesRelatedByFromUserid->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddMessageRelatedByFromUserid($l);
        }

        return $this;
    }

    /**
     * @param	MessageRelatedByFromUserid $messageRelatedByFromUserid The messageRelatedByFromUserid object to add.
     */
    protected function doAddMessageRelatedByFromUserid($messageRelatedByFromUserid)
    {
        $this->collMessagesRelatedByFromUserid[]= $messageRelatedByFromUserid;
        $messageRelatedByFromUserid->setsfGuardUserRelatedByFromUserid($this);
    }

    /**
     * @param	MessageRelatedByFromUserid $messageRelatedByFromUserid The messageRelatedByFromUserid object to remove.
     */
    public function removeMessageRelatedByFromUserid($messageRelatedByFromUserid)
    {
        if ($this->getMessagesRelatedByFromUserid()->contains($messageRelatedByFromUserid)) {
            $this->collMessagesRelatedByFromUserid->remove($this->collMessagesRelatedByFromUserid->search($messageRelatedByFromUserid));
            if (null === $this->messagesRelatedByFromUseridScheduledForDeletion) {
                $this->messagesRelatedByFromUseridScheduledForDeletion = clone $this->collMessagesRelatedByFromUserid;
                $this->messagesRelatedByFromUseridScheduledForDeletion->clear();
            }
            $this->messagesRelatedByFromUseridScheduledForDeletion[]= $messageRelatedByFromUserid;
            $messageRelatedByFromUserid->setsfGuardUserRelatedByFromUserid(null);
        }
    }

    /**
     * Clears out the collMessagesRelatedByToUserid collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addMessagesRelatedByToUserid()
     */
    public function clearMessagesRelatedByToUserid()
    {
        $this->collMessagesRelatedByToUserid = null; // important to set this to null since that means it is uninitialized
        $this->collMessagesRelatedByToUseridPartial = null;
    }

    /**
     * reset is the collMessagesRelatedByToUserid collection loaded partially
     *
     * @return void
     */
    public function resetPartialMessagesRelatedByToUserid($v = true)
    {
        $this->collMessagesRelatedByToUseridPartial = $v;
    }

    /**
     * Initializes the collMessagesRelatedByToUserid collection.
     *
     * By default this just sets the collMessagesRelatedByToUserid collection to an empty array (like clearcollMessagesRelatedByToUserid());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initMessagesRelatedByToUserid($overrideExisting = true)
    {
        if (null !== $this->collMessagesRelatedByToUserid && !$overrideExisting) {
            return;
        }
        $this->collMessagesRelatedByToUserid = new PropelObjectCollection();
        $this->collMessagesRelatedByToUserid->setModel('Message');
    }

    /**
     * Gets an array of Message objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|Message[] List of Message objects
     * @throws PropelException
     */
    public function getMessagesRelatedByToUserid($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collMessagesRelatedByToUseridPartial && !$this->isNew();
        if (null === $this->collMessagesRelatedByToUserid || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collMessagesRelatedByToUserid) {
                // return empty collection
                $this->initMessagesRelatedByToUserid();
            } else {
                $collMessagesRelatedByToUserid = MessageQuery::create(null, $criteria)
                    ->filterBysfGuardUserRelatedByToUserid($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collMessagesRelatedByToUseridPartial && count($collMessagesRelatedByToUserid)) {
                      $this->initMessagesRelatedByToUserid(false);

                      foreach($collMessagesRelatedByToUserid as $obj) {
                        if (false == $this->collMessagesRelatedByToUserid->contains($obj)) {
                          $this->collMessagesRelatedByToUserid->append($obj);
                        }
                      }

                      $this->collMessagesRelatedByToUseridPartial = true;
                    }

                    return $collMessagesRelatedByToUserid;
                }

                if($partial && $this->collMessagesRelatedByToUserid) {
                    foreach($this->collMessagesRelatedByToUserid as $obj) {
                        if($obj->isNew()) {
                            $collMessagesRelatedByToUserid[] = $obj;
                        }
                    }
                }

                $this->collMessagesRelatedByToUserid = $collMessagesRelatedByToUserid;
                $this->collMessagesRelatedByToUseridPartial = false;
            }
        }

        return $this->collMessagesRelatedByToUserid;
    }

    /**
     * Sets a collection of MessageRelatedByToUserid objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $messagesRelatedByToUserid A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setMessagesRelatedByToUserid(PropelCollection $messagesRelatedByToUserid, PropelPDO $con = null)
    {
        $this->messagesRelatedByToUseridScheduledForDeletion = $this->getMessagesRelatedByToUserid(new Criteria(), $con)->diff($messagesRelatedByToUserid);

        foreach ($this->messagesRelatedByToUseridScheduledForDeletion as $messageRelatedByToUseridRemoved) {
            $messageRelatedByToUseridRemoved->setsfGuardUserRelatedByToUserid(null);
        }

        $this->collMessagesRelatedByToUserid = null;
        foreach ($messagesRelatedByToUserid as $messageRelatedByToUserid) {
            $this->addMessageRelatedByToUserid($messageRelatedByToUserid);
        }

        $this->collMessagesRelatedByToUserid = $messagesRelatedByToUserid;
        $this->collMessagesRelatedByToUseridPartial = false;
    }

    /**
     * Returns the number of related Message objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related Message objects.
     * @throws PropelException
     */
    public function countMessagesRelatedByToUserid(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collMessagesRelatedByToUseridPartial && !$this->isNew();
        if (null === $this->collMessagesRelatedByToUserid || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collMessagesRelatedByToUserid) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getMessagesRelatedByToUserid());
                }
                $query = MessageQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUserRelatedByToUserid($this)
                    ->count($con);
            }
        } else {
            return count($this->collMessagesRelatedByToUserid);
        }
    }

    /**
     * Method called to associate a Message object to this object
     * through the Message foreign key attribute.
     *
     * @param    Message $l Message
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addMessageRelatedByToUserid(Message $l)
    {
        if ($this->collMessagesRelatedByToUserid === null) {
            $this->initMessagesRelatedByToUserid();
            $this->collMessagesRelatedByToUseridPartial = true;
        }
        if (!$this->collMessagesRelatedByToUserid->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddMessageRelatedByToUserid($l);
        }

        return $this;
    }

    /**
     * @param	MessageRelatedByToUserid $messageRelatedByToUserid The messageRelatedByToUserid object to add.
     */
    protected function doAddMessageRelatedByToUserid($messageRelatedByToUserid)
    {
        $this->collMessagesRelatedByToUserid[]= $messageRelatedByToUserid;
        $messageRelatedByToUserid->setsfGuardUserRelatedByToUserid($this);
    }

    /**
     * @param	MessageRelatedByToUserid $messageRelatedByToUserid The messageRelatedByToUserid object to remove.
     */
    public function removeMessageRelatedByToUserid($messageRelatedByToUserid)
    {
        if ($this->getMessagesRelatedByToUserid()->contains($messageRelatedByToUserid)) {
            $this->collMessagesRelatedByToUserid->remove($this->collMessagesRelatedByToUserid->search($messageRelatedByToUserid));
            if (null === $this->messagesRelatedByToUseridScheduledForDeletion) {
                $this->messagesRelatedByToUseridScheduledForDeletion = clone $this->collMessagesRelatedByToUserid;
                $this->messagesRelatedByToUseridScheduledForDeletion->clear();
            }
            $this->messagesRelatedByToUseridScheduledForDeletion[]= $messageRelatedByToUserid;
            $messageRelatedByToUserid->setsfGuardUserRelatedByToUserid(null);
        }
    }

    /**
     * Clears out the collPhotos collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addPhotos()
     */
    public function clearPhotos()
    {
        $this->collPhotos = null; // important to set this to null since that means it is uninitialized
        $this->collPhotosPartial = null;
    }

    /**
     * reset is the collPhotos collection loaded partially
     *
     * @return void
     */
    public function resetPartialPhotos($v = true)
    {
        $this->collPhotosPartial = $v;
    }

    /**
     * Initializes the collPhotos collection.
     *
     * By default this just sets the collPhotos collection to an empty array (like clearcollPhotos());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initPhotos($overrideExisting = true)
    {
        if (null !== $this->collPhotos && !$overrideExisting) {
            return;
        }
        $this->collPhotos = new PropelObjectCollection();
        $this->collPhotos->setModel('Photo');
    }

    /**
     * Gets an array of Photo objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|Photo[] List of Photo objects
     * @throws PropelException
     */
    public function getPhotos($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collPhotosPartial && !$this->isNew();
        if (null === $this->collPhotos || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collPhotos) {
                // return empty collection
                $this->initPhotos();
            } else {
                $collPhotos = PhotoQuery::create(null, $criteria)
                    ->filterBysfGuardUser($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collPhotosPartial && count($collPhotos)) {
                      $this->initPhotos(false);

                      foreach($collPhotos as $obj) {
                        if (false == $this->collPhotos->contains($obj)) {
                          $this->collPhotos->append($obj);
                        }
                      }

                      $this->collPhotosPartial = true;
                    }

                    return $collPhotos;
                }

                if($partial && $this->collPhotos) {
                    foreach($this->collPhotos as $obj) {
                        if($obj->isNew()) {
                            $collPhotos[] = $obj;
                        }
                    }
                }

                $this->collPhotos = $collPhotos;
                $this->collPhotosPartial = false;
            }
        }

        return $this->collPhotos;
    }

    /**
     * Sets a collection of Photo objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $photos A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setPhotos(PropelCollection $photos, PropelPDO $con = null)
    {
        $this->photosScheduledForDeletion = $this->getPhotos(new Criteria(), $con)->diff($photos);

        foreach ($this->photosScheduledForDeletion as $photoRemoved) {
            $photoRemoved->setsfGuardUser(null);
        }

        $this->collPhotos = null;
        foreach ($photos as $photo) {
            $this->addPhoto($photo);
        }

        $this->collPhotos = $photos;
        $this->collPhotosPartial = false;
    }

    /**
     * Returns the number of related Photo objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related Photo objects.
     * @throws PropelException
     */
    public function countPhotos(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collPhotosPartial && !$this->isNew();
        if (null === $this->collPhotos || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collPhotos) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getPhotos());
                }
                $query = PhotoQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUser($this)
                    ->count($con);
            }
        } else {
            return count($this->collPhotos);
        }
    }

    /**
     * Method called to associate a Photo object to this object
     * through the Photo foreign key attribute.
     *
     * @param    Photo $l Photo
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addPhoto(Photo $l)
    {
        if ($this->collPhotos === null) {
            $this->initPhotos();
            $this->collPhotosPartial = true;
        }
        if (!$this->collPhotos->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddPhoto($l);
        }

        return $this;
    }

    /**
     * @param	Photo $photo The photo object to add.
     */
    protected function doAddPhoto($photo)
    {
        $this->collPhotos[]= $photo;
        $photo->setsfGuardUser($this);
    }

    /**
     * @param	Photo $photo The photo object to remove.
     */
    public function removePhoto($photo)
    {
        if ($this->getPhotos()->contains($photo)) {
            $this->collPhotos->remove($this->collPhotos->search($photo));
            if (null === $this->photosScheduledForDeletion) {
                $this->photosScheduledForDeletion = clone $this->collPhotos;
                $this->photosScheduledForDeletion->clear();
            }
            $this->photosScheduledForDeletion[]= $photo;
            $photo->setsfGuardUser(null);
        }
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this sfGuardUser is new, it will return
     * an empty collection; or if this sfGuardUser has previously
     * been saved, it will retrieve related Photos from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in sfGuardUser.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @param string $join_behavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return PropelObjectCollection|Photo[] List of Photo objects
     */
    public function getPhotosJoinAlbum($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
    {
        $query = PhotoQuery::create(null, $criteria);
        $query->joinWith('Album', $join_behavior);

        return $this->getPhotos($query, $con);
    }

    /**
     * Clears out the collPhotoComments collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addPhotoComments()
     */
    public function clearPhotoComments()
    {
        $this->collPhotoComments = null; // important to set this to null since that means it is uninitialized
        $this->collPhotoCommentsPartial = null;
    }

    /**
     * reset is the collPhotoComments collection loaded partially
     *
     * @return void
     */
    public function resetPartialPhotoComments($v = true)
    {
        $this->collPhotoCommentsPartial = $v;
    }

    /**
     * Initializes the collPhotoComments collection.
     *
     * By default this just sets the collPhotoComments collection to an empty array (like clearcollPhotoComments());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initPhotoComments($overrideExisting = true)
    {
        if (null !== $this->collPhotoComments && !$overrideExisting) {
            return;
        }
        $this->collPhotoComments = new PropelObjectCollection();
        $this->collPhotoComments->setModel('PhotoComment');
    }

    /**
     * Gets an array of PhotoComment objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|PhotoComment[] List of PhotoComment objects
     * @throws PropelException
     */
    public function getPhotoComments($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collPhotoCommentsPartial && !$this->isNew();
        if (null === $this->collPhotoComments || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collPhotoComments) {
                // return empty collection
                $this->initPhotoComments();
            } else {
                $collPhotoComments = PhotoCommentQuery::create(null, $criteria)
                    ->filterBysfGuardUser($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collPhotoCommentsPartial && count($collPhotoComments)) {
                      $this->initPhotoComments(false);

                      foreach($collPhotoComments as $obj) {
                        if (false == $this->collPhotoComments->contains($obj)) {
                          $this->collPhotoComments->append($obj);
                        }
                      }

                      $this->collPhotoCommentsPartial = true;
                    }

                    return $collPhotoComments;
                }

                if($partial && $this->collPhotoComments) {
                    foreach($this->collPhotoComments as $obj) {
                        if($obj->isNew()) {
                            $collPhotoComments[] = $obj;
                        }
                    }
                }

                $this->collPhotoComments = $collPhotoComments;
                $this->collPhotoCommentsPartial = false;
            }
        }

        return $this->collPhotoComments;
    }

    /**
     * Sets a collection of PhotoComment objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $photoComments A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setPhotoComments(PropelCollection $photoComments, PropelPDO $con = null)
    {
        $this->photoCommentsScheduledForDeletion = $this->getPhotoComments(new Criteria(), $con)->diff($photoComments);

        foreach ($this->photoCommentsScheduledForDeletion as $photoCommentRemoved) {
            $photoCommentRemoved->setsfGuardUser(null);
        }

        $this->collPhotoComments = null;
        foreach ($photoComments as $photoComment) {
            $this->addPhotoComment($photoComment);
        }

        $this->collPhotoComments = $photoComments;
        $this->collPhotoCommentsPartial = false;
    }

    /**
     * Returns the number of related PhotoComment objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related PhotoComment objects.
     * @throws PropelException
     */
    public function countPhotoComments(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collPhotoCommentsPartial && !$this->isNew();
        if (null === $this->collPhotoComments || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collPhotoComments) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getPhotoComments());
                }
                $query = PhotoCommentQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUser($this)
                    ->count($con);
            }
        } else {
            return count($this->collPhotoComments);
        }
    }

    /**
     * Method called to associate a PhotoComment object to this object
     * through the PhotoComment foreign key attribute.
     *
     * @param    PhotoComment $l PhotoComment
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addPhotoComment(PhotoComment $l)
    {
        if ($this->collPhotoComments === null) {
            $this->initPhotoComments();
            $this->collPhotoCommentsPartial = true;
        }
        if (!$this->collPhotoComments->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddPhotoComment($l);
        }

        return $this;
    }

    /**
     * @param	PhotoComment $photoComment The photoComment object to add.
     */
    protected function doAddPhotoComment($photoComment)
    {
        $this->collPhotoComments[]= $photoComment;
        $photoComment->setsfGuardUser($this);
    }

    /**
     * @param	PhotoComment $photoComment The photoComment object to remove.
     */
    public function removePhotoComment($photoComment)
    {
        if ($this->getPhotoComments()->contains($photoComment)) {
            $this->collPhotoComments->remove($this->collPhotoComments->search($photoComment));
            if (null === $this->photoCommentsScheduledForDeletion) {
                $this->photoCommentsScheduledForDeletion = clone $this->collPhotoComments;
                $this->photoCommentsScheduledForDeletion->clear();
            }
            $this->photoCommentsScheduledForDeletion[]= $photoComment;
            $photoComment->setsfGuardUser(null);
        }
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this sfGuardUser is new, it will return
     * an empty collection; or if this sfGuardUser has previously
     * been saved, it will retrieve related PhotoComments from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in sfGuardUser.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @param string $join_behavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return PropelObjectCollection|PhotoComment[] List of PhotoComment objects
     */
    public function getPhotoCommentsJoinPhoto($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
    {
        $query = PhotoCommentQuery::create(null, $criteria);
        $query->joinWith('Photo', $join_behavior);

        return $this->getPhotoComments($query, $con);
    }

    /**
     * Clears out the collPhotoTags collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addPhotoTags()
     */
    public function clearPhotoTags()
    {
        $this->collPhotoTags = null; // important to set this to null since that means it is uninitialized
        $this->collPhotoTagsPartial = null;
    }

    /**
     * reset is the collPhotoTags collection loaded partially
     *
     * @return void
     */
    public function resetPartialPhotoTags($v = true)
    {
        $this->collPhotoTagsPartial = $v;
    }

    /**
     * Initializes the collPhotoTags collection.
     *
     * By default this just sets the collPhotoTags collection to an empty array (like clearcollPhotoTags());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initPhotoTags($overrideExisting = true)
    {
        if (null !== $this->collPhotoTags && !$overrideExisting) {
            return;
        }
        $this->collPhotoTags = new PropelObjectCollection();
        $this->collPhotoTags->setModel('PhotoTag');
    }

    /**
     * Gets an array of PhotoTag objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|PhotoTag[] List of PhotoTag objects
     * @throws PropelException
     */
    public function getPhotoTags($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collPhotoTagsPartial && !$this->isNew();
        if (null === $this->collPhotoTags || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collPhotoTags) {
                // return empty collection
                $this->initPhotoTags();
            } else {
                $collPhotoTags = PhotoTagQuery::create(null, $criteria)
                    ->filterBysfGuardUser($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collPhotoTagsPartial && count($collPhotoTags)) {
                      $this->initPhotoTags(false);

                      foreach($collPhotoTags as $obj) {
                        if (false == $this->collPhotoTags->contains($obj)) {
                          $this->collPhotoTags->append($obj);
                        }
                      }

                      $this->collPhotoTagsPartial = true;
                    }

                    return $collPhotoTags;
                }

                if($partial && $this->collPhotoTags) {
                    foreach($this->collPhotoTags as $obj) {
                        if($obj->isNew()) {
                            $collPhotoTags[] = $obj;
                        }
                    }
                }

                $this->collPhotoTags = $collPhotoTags;
                $this->collPhotoTagsPartial = false;
            }
        }

        return $this->collPhotoTags;
    }

    /**
     * Sets a collection of PhotoTag objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $photoTags A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setPhotoTags(PropelCollection $photoTags, PropelPDO $con = null)
    {
        $this->photoTagsScheduledForDeletion = $this->getPhotoTags(new Criteria(), $con)->diff($photoTags);

        foreach ($this->photoTagsScheduledForDeletion as $photoTagRemoved) {
            $photoTagRemoved->setsfGuardUser(null);
        }

        $this->collPhotoTags = null;
        foreach ($photoTags as $photoTag) {
            $this->addPhotoTag($photoTag);
        }

        $this->collPhotoTags = $photoTags;
        $this->collPhotoTagsPartial = false;
    }

    /**
     * Returns the number of related PhotoTag objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related PhotoTag objects.
     * @throws PropelException
     */
    public function countPhotoTags(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collPhotoTagsPartial && !$this->isNew();
        if (null === $this->collPhotoTags || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collPhotoTags) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getPhotoTags());
                }
                $query = PhotoTagQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUser($this)
                    ->count($con);
            }
        } else {
            return count($this->collPhotoTags);
        }
    }

    /**
     * Method called to associate a PhotoTag object to this object
     * through the PhotoTag foreign key attribute.
     *
     * @param    PhotoTag $l PhotoTag
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addPhotoTag(PhotoTag $l)
    {
        if ($this->collPhotoTags === null) {
            $this->initPhotoTags();
            $this->collPhotoTagsPartial = true;
        }
        if (!$this->collPhotoTags->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddPhotoTag($l);
        }

        return $this;
    }

    /**
     * @param	PhotoTag $photoTag The photoTag object to add.
     */
    protected function doAddPhotoTag($photoTag)
    {
        $this->collPhotoTags[]= $photoTag;
        $photoTag->setsfGuardUser($this);
    }

    /**
     * @param	PhotoTag $photoTag The photoTag object to remove.
     */
    public function removePhotoTag($photoTag)
    {
        if ($this->getPhotoTags()->contains($photoTag)) {
            $this->collPhotoTags->remove($this->collPhotoTags->search($photoTag));
            if (null === $this->photoTagsScheduledForDeletion) {
                $this->photoTagsScheduledForDeletion = clone $this->collPhotoTags;
                $this->photoTagsScheduledForDeletion->clear();
            }
            $this->photoTagsScheduledForDeletion[]= $photoTag;
            $photoTag->setsfGuardUser(null);
        }
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this sfGuardUser is new, it will return
     * an empty collection; or if this sfGuardUser has previously
     * been saved, it will retrieve related PhotoTags from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in sfGuardUser.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @param string $join_behavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return PropelObjectCollection|PhotoTag[] List of PhotoTag objects
     */
    public function getPhotoTagsJoinPhoto($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
    {
        $query = PhotoTagQuery::create(null, $criteria);
        $query->joinWith('Photo', $join_behavior);

        return $this->getPhotoTags($query, $con);
    }

    /**
     * Clears out the collPhotoFavs collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addPhotoFavs()
     */
    public function clearPhotoFavs()
    {
        $this->collPhotoFavs = null; // important to set this to null since that means it is uninitialized
        $this->collPhotoFavsPartial = null;
    }

    /**
     * reset is the collPhotoFavs collection loaded partially
     *
     * @return void
     */
    public function resetPartialPhotoFavs($v = true)
    {
        $this->collPhotoFavsPartial = $v;
    }

    /**
     * Initializes the collPhotoFavs collection.
     *
     * By default this just sets the collPhotoFavs collection to an empty array (like clearcollPhotoFavs());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initPhotoFavs($overrideExisting = true)
    {
        if (null !== $this->collPhotoFavs && !$overrideExisting) {
            return;
        }
        $this->collPhotoFavs = new PropelObjectCollection();
        $this->collPhotoFavs->setModel('PhotoFav');
    }

    /**
     * Gets an array of PhotoFav objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|PhotoFav[] List of PhotoFav objects
     * @throws PropelException
     */
    public function getPhotoFavs($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collPhotoFavsPartial && !$this->isNew();
        if (null === $this->collPhotoFavs || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collPhotoFavs) {
                // return empty collection
                $this->initPhotoFavs();
            } else {
                $collPhotoFavs = PhotoFavQuery::create(null, $criteria)
                    ->filterBysfGuardUser($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collPhotoFavsPartial && count($collPhotoFavs)) {
                      $this->initPhotoFavs(false);

                      foreach($collPhotoFavs as $obj) {
                        if (false == $this->collPhotoFavs->contains($obj)) {
                          $this->collPhotoFavs->append($obj);
                        }
                      }

                      $this->collPhotoFavsPartial = true;
                    }

                    return $collPhotoFavs;
                }

                if($partial && $this->collPhotoFavs) {
                    foreach($this->collPhotoFavs as $obj) {
                        if($obj->isNew()) {
                            $collPhotoFavs[] = $obj;
                        }
                    }
                }

                $this->collPhotoFavs = $collPhotoFavs;
                $this->collPhotoFavsPartial = false;
            }
        }

        return $this->collPhotoFavs;
    }

    /**
     * Sets a collection of PhotoFav objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $photoFavs A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setPhotoFavs(PropelCollection $photoFavs, PropelPDO $con = null)
    {
        $this->photoFavsScheduledForDeletion = $this->getPhotoFavs(new Criteria(), $con)->diff($photoFavs);

        foreach ($this->photoFavsScheduledForDeletion as $photoFavRemoved) {
            $photoFavRemoved->setsfGuardUser(null);
        }

        $this->collPhotoFavs = null;
        foreach ($photoFavs as $photoFav) {
            $this->addPhotoFav($photoFav);
        }

        $this->collPhotoFavs = $photoFavs;
        $this->collPhotoFavsPartial = false;
    }

    /**
     * Returns the number of related PhotoFav objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related PhotoFav objects.
     * @throws PropelException
     */
    public function countPhotoFavs(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collPhotoFavsPartial && !$this->isNew();
        if (null === $this->collPhotoFavs || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collPhotoFavs) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getPhotoFavs());
                }
                $query = PhotoFavQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUser($this)
                    ->count($con);
            }
        } else {
            return count($this->collPhotoFavs);
        }
    }

    /**
     * Method called to associate a PhotoFav object to this object
     * through the PhotoFav foreign key attribute.
     *
     * @param    PhotoFav $l PhotoFav
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addPhotoFav(PhotoFav $l)
    {
        if ($this->collPhotoFavs === null) {
            $this->initPhotoFavs();
            $this->collPhotoFavsPartial = true;
        }
        if (!$this->collPhotoFavs->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddPhotoFav($l);
        }

        return $this;
    }

    /**
     * @param	PhotoFav $photoFav The photoFav object to add.
     */
    protected function doAddPhotoFav($photoFav)
    {
        $this->collPhotoFavs[]= $photoFav;
        $photoFav->setsfGuardUser($this);
    }

    /**
     * @param	PhotoFav $photoFav The photoFav object to remove.
     */
    public function removePhotoFav($photoFav)
    {
        if ($this->getPhotoFavs()->contains($photoFav)) {
            $this->collPhotoFavs->remove($this->collPhotoFavs->search($photoFav));
            if (null === $this->photoFavsScheduledForDeletion) {
                $this->photoFavsScheduledForDeletion = clone $this->collPhotoFavs;
                $this->photoFavsScheduledForDeletion->clear();
            }
            $this->photoFavsScheduledForDeletion[]= $photoFav;
            $photoFav->setsfGuardUser(null);
        }
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this sfGuardUser is new, it will return
     * an empty collection; or if this sfGuardUser has previously
     * been saved, it will retrieve related PhotoFavs from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in sfGuardUser.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @param string $join_behavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return PropelObjectCollection|PhotoFav[] List of PhotoFav objects
     */
    public function getPhotoFavsJoinPhoto($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
    {
        $query = PhotoFavQuery::create(null, $criteria);
        $query->joinWith('Photo', $join_behavior);

        return $this->getPhotoFavs($query, $con);
    }

    /**
     * Clears out the collPhotoVotes collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addPhotoVotes()
     */
    public function clearPhotoVotes()
    {
        $this->collPhotoVotes = null; // important to set this to null since that means it is uninitialized
        $this->collPhotoVotesPartial = null;
    }

    /**
     * reset is the collPhotoVotes collection loaded partially
     *
     * @return void
     */
    public function resetPartialPhotoVotes($v = true)
    {
        $this->collPhotoVotesPartial = $v;
    }

    /**
     * Initializes the collPhotoVotes collection.
     *
     * By default this just sets the collPhotoVotes collection to an empty array (like clearcollPhotoVotes());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initPhotoVotes($overrideExisting = true)
    {
        if (null !== $this->collPhotoVotes && !$overrideExisting) {
            return;
        }
        $this->collPhotoVotes = new PropelObjectCollection();
        $this->collPhotoVotes->setModel('PhotoVote');
    }

    /**
     * Gets an array of PhotoVote objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|PhotoVote[] List of PhotoVote objects
     * @throws PropelException
     */
    public function getPhotoVotes($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collPhotoVotesPartial && !$this->isNew();
        if (null === $this->collPhotoVotes || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collPhotoVotes) {
                // return empty collection
                $this->initPhotoVotes();
            } else {
                $collPhotoVotes = PhotoVoteQuery::create(null, $criteria)
                    ->filterBysfGuardUser($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collPhotoVotesPartial && count($collPhotoVotes)) {
                      $this->initPhotoVotes(false);

                      foreach($collPhotoVotes as $obj) {
                        if (false == $this->collPhotoVotes->contains($obj)) {
                          $this->collPhotoVotes->append($obj);
                        }
                      }

                      $this->collPhotoVotesPartial = true;
                    }

                    return $collPhotoVotes;
                }

                if($partial && $this->collPhotoVotes) {
                    foreach($this->collPhotoVotes as $obj) {
                        if($obj->isNew()) {
                            $collPhotoVotes[] = $obj;
                        }
                    }
                }

                $this->collPhotoVotes = $collPhotoVotes;
                $this->collPhotoVotesPartial = false;
            }
        }

        return $this->collPhotoVotes;
    }

    /**
     * Sets a collection of PhotoVote objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $photoVotes A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setPhotoVotes(PropelCollection $photoVotes, PropelPDO $con = null)
    {
        $this->photoVotesScheduledForDeletion = $this->getPhotoVotes(new Criteria(), $con)->diff($photoVotes);

        foreach ($this->photoVotesScheduledForDeletion as $photoVoteRemoved) {
            $photoVoteRemoved->setsfGuardUser(null);
        }

        $this->collPhotoVotes = null;
        foreach ($photoVotes as $photoVote) {
            $this->addPhotoVote($photoVote);
        }

        $this->collPhotoVotes = $photoVotes;
        $this->collPhotoVotesPartial = false;
    }

    /**
     * Returns the number of related PhotoVote objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related PhotoVote objects.
     * @throws PropelException
     */
    public function countPhotoVotes(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collPhotoVotesPartial && !$this->isNew();
        if (null === $this->collPhotoVotes || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collPhotoVotes) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getPhotoVotes());
                }
                $query = PhotoVoteQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUser($this)
                    ->count($con);
            }
        } else {
            return count($this->collPhotoVotes);
        }
    }

    /**
     * Method called to associate a PhotoVote object to this object
     * through the PhotoVote foreign key attribute.
     *
     * @param    PhotoVote $l PhotoVote
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addPhotoVote(PhotoVote $l)
    {
        if ($this->collPhotoVotes === null) {
            $this->initPhotoVotes();
            $this->collPhotoVotesPartial = true;
        }
        if (!$this->collPhotoVotes->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddPhotoVote($l);
        }

        return $this;
    }

    /**
     * @param	PhotoVote $photoVote The photoVote object to add.
     */
    protected function doAddPhotoVote($photoVote)
    {
        $this->collPhotoVotes[]= $photoVote;
        $photoVote->setsfGuardUser($this);
    }

    /**
     * @param	PhotoVote $photoVote The photoVote object to remove.
     */
    public function removePhotoVote($photoVote)
    {
        if ($this->getPhotoVotes()->contains($photoVote)) {
            $this->collPhotoVotes->remove($this->collPhotoVotes->search($photoVote));
            if (null === $this->photoVotesScheduledForDeletion) {
                $this->photoVotesScheduledForDeletion = clone $this->collPhotoVotes;
                $this->photoVotesScheduledForDeletion->clear();
            }
            $this->photoVotesScheduledForDeletion[]= $photoVote;
            $photoVote->setsfGuardUser(null);
        }
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this sfGuardUser is new, it will return
     * an empty collection; or if this sfGuardUser has previously
     * been saved, it will retrieve related PhotoVotes from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in sfGuardUser.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @param string $join_behavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return PropelObjectCollection|PhotoVote[] List of PhotoVote objects
     */
    public function getPhotoVotesJoinPhoto($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
    {
        $query = PhotoVoteQuery::create(null, $criteria);
        $query->joinWith('Photo', $join_behavior);

        return $this->getPhotoVotes($query, $con);
    }

    /**
     * Clears out the collPhotoRates collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addPhotoRates()
     */
    public function clearPhotoRates()
    {
        $this->collPhotoRates = null; // important to set this to null since that means it is uninitialized
        $this->collPhotoRatesPartial = null;
    }

    /**
     * reset is the collPhotoRates collection loaded partially
     *
     * @return void
     */
    public function resetPartialPhotoRates($v = true)
    {
        $this->collPhotoRatesPartial = $v;
    }

    /**
     * Initializes the collPhotoRates collection.
     *
     * By default this just sets the collPhotoRates collection to an empty array (like clearcollPhotoRates());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initPhotoRates($overrideExisting = true)
    {
        if (null !== $this->collPhotoRates && !$overrideExisting) {
            return;
        }
        $this->collPhotoRates = new PropelObjectCollection();
        $this->collPhotoRates->setModel('PhotoRate');
    }

    /**
     * Gets an array of PhotoRate objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|PhotoRate[] List of PhotoRate objects
     * @throws PropelException
     */
    public function getPhotoRates($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collPhotoRatesPartial && !$this->isNew();
        if (null === $this->collPhotoRates || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collPhotoRates) {
                // return empty collection
                $this->initPhotoRates();
            } else {
                $collPhotoRates = PhotoRateQuery::create(null, $criteria)
                    ->filterBysfGuardUser($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collPhotoRatesPartial && count($collPhotoRates)) {
                      $this->initPhotoRates(false);

                      foreach($collPhotoRates as $obj) {
                        if (false == $this->collPhotoRates->contains($obj)) {
                          $this->collPhotoRates->append($obj);
                        }
                      }

                      $this->collPhotoRatesPartial = true;
                    }

                    return $collPhotoRates;
                }

                if($partial && $this->collPhotoRates) {
                    foreach($this->collPhotoRates as $obj) {
                        if($obj->isNew()) {
                            $collPhotoRates[] = $obj;
                        }
                    }
                }

                $this->collPhotoRates = $collPhotoRates;
                $this->collPhotoRatesPartial = false;
            }
        }

        return $this->collPhotoRates;
    }

    /**
     * Sets a collection of PhotoRate objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $photoRates A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setPhotoRates(PropelCollection $photoRates, PropelPDO $con = null)
    {
        $this->photoRatesScheduledForDeletion = $this->getPhotoRates(new Criteria(), $con)->diff($photoRates);

        foreach ($this->photoRatesScheduledForDeletion as $photoRateRemoved) {
            $photoRateRemoved->setsfGuardUser(null);
        }

        $this->collPhotoRates = null;
        foreach ($photoRates as $photoRate) {
            $this->addPhotoRate($photoRate);
        }

        $this->collPhotoRates = $photoRates;
        $this->collPhotoRatesPartial = false;
    }

    /**
     * Returns the number of related PhotoRate objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related PhotoRate objects.
     * @throws PropelException
     */
    public function countPhotoRates(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collPhotoRatesPartial && !$this->isNew();
        if (null === $this->collPhotoRates || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collPhotoRates) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getPhotoRates());
                }
                $query = PhotoRateQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUser($this)
                    ->count($con);
            }
        } else {
            return count($this->collPhotoRates);
        }
    }

    /**
     * Method called to associate a PhotoRate object to this object
     * through the PhotoRate foreign key attribute.
     *
     * @param    PhotoRate $l PhotoRate
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addPhotoRate(PhotoRate $l)
    {
        if ($this->collPhotoRates === null) {
            $this->initPhotoRates();
            $this->collPhotoRatesPartial = true;
        }
        if (!$this->collPhotoRates->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddPhotoRate($l);
        }

        return $this;
    }

    /**
     * @param	PhotoRate $photoRate The photoRate object to add.
     */
    protected function doAddPhotoRate($photoRate)
    {
        $this->collPhotoRates[]= $photoRate;
        $photoRate->setsfGuardUser($this);
    }

    /**
     * @param	PhotoRate $photoRate The photoRate object to remove.
     */
    public function removePhotoRate($photoRate)
    {
        if ($this->getPhotoRates()->contains($photoRate)) {
            $this->collPhotoRates->remove($this->collPhotoRates->search($photoRate));
            if (null === $this->photoRatesScheduledForDeletion) {
                $this->photoRatesScheduledForDeletion = clone $this->collPhotoRates;
                $this->photoRatesScheduledForDeletion->clear();
            }
            $this->photoRatesScheduledForDeletion[]= $photoRate;
            $photoRate->setsfGuardUser(null);
        }
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this sfGuardUser is new, it will return
     * an empty collection; or if this sfGuardUser has previously
     * been saved, it will retrieve related PhotoRates from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in sfGuardUser.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @param string $join_behavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return PropelObjectCollection|PhotoRate[] List of PhotoRate objects
     */
    public function getPhotoRatesJoinPhoto($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
    {
        $query = PhotoRateQuery::create(null, $criteria);
        $query->joinWith('Photo', $join_behavior);

        return $this->getPhotoRates($query, $con);
    }

    /**
     * Clears out the collSchoolUsers collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addSchoolUsers()
     */
    public function clearSchoolUsers()
    {
        $this->collSchoolUsers = null; // important to set this to null since that means it is uninitialized
        $this->collSchoolUsersPartial = null;
    }

    /**
     * reset is the collSchoolUsers collection loaded partially
     *
     * @return void
     */
    public function resetPartialSchoolUsers($v = true)
    {
        $this->collSchoolUsersPartial = $v;
    }

    /**
     * Initializes the collSchoolUsers collection.
     *
     * By default this just sets the collSchoolUsers collection to an empty array (like clearcollSchoolUsers());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initSchoolUsers($overrideExisting = true)
    {
        if (null !== $this->collSchoolUsers && !$overrideExisting) {
            return;
        }
        $this->collSchoolUsers = new PropelObjectCollection();
        $this->collSchoolUsers->setModel('SchoolUser');
    }

    /**
     * Gets an array of SchoolUser objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|SchoolUser[] List of SchoolUser objects
     * @throws PropelException
     */
    public function getSchoolUsers($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collSchoolUsersPartial && !$this->isNew();
        if (null === $this->collSchoolUsers || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collSchoolUsers) {
                // return empty collection
                $this->initSchoolUsers();
            } else {
                $collSchoolUsers = SchoolUserQuery::create(null, $criteria)
                    ->filterBysfGuardUser($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collSchoolUsersPartial && count($collSchoolUsers)) {
                      $this->initSchoolUsers(false);

                      foreach($collSchoolUsers as $obj) {
                        if (false == $this->collSchoolUsers->contains($obj)) {
                          $this->collSchoolUsers->append($obj);
                        }
                      }

                      $this->collSchoolUsersPartial = true;
                    }

                    return $collSchoolUsers;
                }

                if($partial && $this->collSchoolUsers) {
                    foreach($this->collSchoolUsers as $obj) {
                        if($obj->isNew()) {
                            $collSchoolUsers[] = $obj;
                        }
                    }
                }

                $this->collSchoolUsers = $collSchoolUsers;
                $this->collSchoolUsersPartial = false;
            }
        }

        return $this->collSchoolUsers;
    }

    /**
     * Sets a collection of SchoolUser objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $schoolUsers A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setSchoolUsers(PropelCollection $schoolUsers, PropelPDO $con = null)
    {
        $this->schoolUsersScheduledForDeletion = $this->getSchoolUsers(new Criteria(), $con)->diff($schoolUsers);

        foreach ($this->schoolUsersScheduledForDeletion as $schoolUserRemoved) {
            $schoolUserRemoved->setsfGuardUser(null);
        }

        $this->collSchoolUsers = null;
        foreach ($schoolUsers as $schoolUser) {
            $this->addSchoolUser($schoolUser);
        }

        $this->collSchoolUsers = $schoolUsers;
        $this->collSchoolUsersPartial = false;
    }

    /**
     * Returns the number of related SchoolUser objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related SchoolUser objects.
     * @throws PropelException
     */
    public function countSchoolUsers(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collSchoolUsersPartial && !$this->isNew();
        if (null === $this->collSchoolUsers || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collSchoolUsers) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getSchoolUsers());
                }
                $query = SchoolUserQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUser($this)
                    ->count($con);
            }
        } else {
            return count($this->collSchoolUsers);
        }
    }

    /**
     * Method called to associate a SchoolUser object to this object
     * through the SchoolUser foreign key attribute.
     *
     * @param    SchoolUser $l SchoolUser
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addSchoolUser(SchoolUser $l)
    {
        if ($this->collSchoolUsers === null) {
            $this->initSchoolUsers();
            $this->collSchoolUsersPartial = true;
        }
        if (!$this->collSchoolUsers->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddSchoolUser($l);
        }

        return $this;
    }

    /**
     * @param	SchoolUser $schoolUser The schoolUser object to add.
     */
    protected function doAddSchoolUser($schoolUser)
    {
        $this->collSchoolUsers[]= $schoolUser;
        $schoolUser->setsfGuardUser($this);
    }

    /**
     * @param	SchoolUser $schoolUser The schoolUser object to remove.
     */
    public function removeSchoolUser($schoolUser)
    {
        if ($this->getSchoolUsers()->contains($schoolUser)) {
            $this->collSchoolUsers->remove($this->collSchoolUsers->search($schoolUser));
            if (null === $this->schoolUsersScheduledForDeletion) {
                $this->schoolUsersScheduledForDeletion = clone $this->collSchoolUsers;
                $this->schoolUsersScheduledForDeletion->clear();
            }
            $this->schoolUsersScheduledForDeletion[]= $schoolUser;
            $schoolUser->setsfGuardUser(null);
        }
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this sfGuardUser is new, it will return
     * an empty collection; or if this sfGuardUser has previously
     * been saved, it will retrieve related SchoolUsers from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in sfGuardUser.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @param string $join_behavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return PropelObjectCollection|SchoolUser[] List of SchoolUser objects
     */
    public function getSchoolUsersJoinSchool($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
    {
        $query = SchoolUserQuery::create(null, $criteria);
        $query->joinWith('School', $join_behavior);

        return $this->getSchoolUsers($query, $con);
    }

    /**
     * Clears out the collUpdatess collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addUpdatess()
     */
    public function clearUpdatess()
    {
        $this->collUpdatess = null; // important to set this to null since that means it is uninitialized
        $this->collUpdatessPartial = null;
    }

    /**
     * reset is the collUpdatess collection loaded partially
     *
     * @return void
     */
    public function resetPartialUpdatess($v = true)
    {
        $this->collUpdatessPartial = $v;
    }

    /**
     * Initializes the collUpdatess collection.
     *
     * By default this just sets the collUpdatess collection to an empty array (like clearcollUpdatess());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initUpdatess($overrideExisting = true)
    {
        if (null !== $this->collUpdatess && !$overrideExisting) {
            return;
        }
        $this->collUpdatess = new PropelObjectCollection();
        $this->collUpdatess->setModel('Updates');
    }

    /**
     * Gets an array of Updates objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|Updates[] List of Updates objects
     * @throws PropelException
     */
    public function getUpdatess($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collUpdatessPartial && !$this->isNew();
        if (null === $this->collUpdatess || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collUpdatess) {
                // return empty collection
                $this->initUpdatess();
            } else {
                $collUpdatess = UpdatesQuery::create(null, $criteria)
                    ->filterBysfGuardUser($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collUpdatessPartial && count($collUpdatess)) {
                      $this->initUpdatess(false);

                      foreach($collUpdatess as $obj) {
                        if (false == $this->collUpdatess->contains($obj)) {
                          $this->collUpdatess->append($obj);
                        }
                      }

                      $this->collUpdatessPartial = true;
                    }

                    return $collUpdatess;
                }

                if($partial && $this->collUpdatess) {
                    foreach($this->collUpdatess as $obj) {
                        if($obj->isNew()) {
                            $collUpdatess[] = $obj;
                        }
                    }
                }

                $this->collUpdatess = $collUpdatess;
                $this->collUpdatessPartial = false;
            }
        }

        return $this->collUpdatess;
    }

    /**
     * Sets a collection of Updates objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $updatess A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setUpdatess(PropelCollection $updatess, PropelPDO $con = null)
    {
        $this->updatessScheduledForDeletion = $this->getUpdatess(new Criteria(), $con)->diff($updatess);

        foreach ($this->updatessScheduledForDeletion as $updatesRemoved) {
            $updatesRemoved->setsfGuardUser(null);
        }

        $this->collUpdatess = null;
        foreach ($updatess as $updates) {
            $this->addUpdates($updates);
        }

        $this->collUpdatess = $updatess;
        $this->collUpdatessPartial = false;
    }

    /**
     * Returns the number of related Updates objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related Updates objects.
     * @throws PropelException
     */
    public function countUpdatess(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collUpdatessPartial && !$this->isNew();
        if (null === $this->collUpdatess || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collUpdatess) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getUpdatess());
                }
                $query = UpdatesQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUser($this)
                    ->count($con);
            }
        } else {
            return count($this->collUpdatess);
        }
    }

    /**
     * Method called to associate a Updates object to this object
     * through the Updates foreign key attribute.
     *
     * @param    Updates $l Updates
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addUpdates(Updates $l)
    {
        if ($this->collUpdatess === null) {
            $this->initUpdatess();
            $this->collUpdatessPartial = true;
        }
        if (!$this->collUpdatess->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddUpdates($l);
        }

        return $this;
    }

    /**
     * @param	Updates $updates The updates object to add.
     */
    protected function doAddUpdates($updates)
    {
        $this->collUpdatess[]= $updates;
        $updates->setsfGuardUser($this);
    }

    /**
     * @param	Updates $updates The updates object to remove.
     */
    public function removeUpdates($updates)
    {
        if ($this->getUpdatess()->contains($updates)) {
            $this->collUpdatess->remove($this->collUpdatess->search($updates));
            if (null === $this->updatessScheduledForDeletion) {
                $this->updatessScheduledForDeletion = clone $this->collUpdatess;
                $this->updatessScheduledForDeletion->clear();
            }
            $this->updatessScheduledForDeletion[]= $updates;
            $updates->setsfGuardUser(null);
        }
    }

    /**
     * Clears out the collIgnorelistsRelatedByUserId collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addIgnorelistsRelatedByUserId()
     */
    public function clearIgnorelistsRelatedByUserId()
    {
        $this->collIgnorelistsRelatedByUserId = null; // important to set this to null since that means it is uninitialized
        $this->collIgnorelistsRelatedByUserIdPartial = null;
    }

    /**
     * reset is the collIgnorelistsRelatedByUserId collection loaded partially
     *
     * @return void
     */
    public function resetPartialIgnorelistsRelatedByUserId($v = true)
    {
        $this->collIgnorelistsRelatedByUserIdPartial = $v;
    }

    /**
     * Initializes the collIgnorelistsRelatedByUserId collection.
     *
     * By default this just sets the collIgnorelistsRelatedByUserId collection to an empty array (like clearcollIgnorelistsRelatedByUserId());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initIgnorelistsRelatedByUserId($overrideExisting = true)
    {
        if (null !== $this->collIgnorelistsRelatedByUserId && !$overrideExisting) {
            return;
        }
        $this->collIgnorelistsRelatedByUserId = new PropelObjectCollection();
        $this->collIgnorelistsRelatedByUserId->setModel('Ignorelist');
    }

    /**
     * Gets an array of Ignorelist objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|Ignorelist[] List of Ignorelist objects
     * @throws PropelException
     */
    public function getIgnorelistsRelatedByUserId($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collIgnorelistsRelatedByUserIdPartial && !$this->isNew();
        if (null === $this->collIgnorelistsRelatedByUserId || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collIgnorelistsRelatedByUserId) {
                // return empty collection
                $this->initIgnorelistsRelatedByUserId();
            } else {
                $collIgnorelistsRelatedByUserId = IgnorelistQuery::create(null, $criteria)
                    ->filterBysfGuardUserRelatedByUserId($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collIgnorelistsRelatedByUserIdPartial && count($collIgnorelistsRelatedByUserId)) {
                      $this->initIgnorelistsRelatedByUserId(false);

                      foreach($collIgnorelistsRelatedByUserId as $obj) {
                        if (false == $this->collIgnorelistsRelatedByUserId->contains($obj)) {
                          $this->collIgnorelistsRelatedByUserId->append($obj);
                        }
                      }

                      $this->collIgnorelistsRelatedByUserIdPartial = true;
                    }

                    return $collIgnorelistsRelatedByUserId;
                }

                if($partial && $this->collIgnorelistsRelatedByUserId) {
                    foreach($this->collIgnorelistsRelatedByUserId as $obj) {
                        if($obj->isNew()) {
                            $collIgnorelistsRelatedByUserId[] = $obj;
                        }
                    }
                }

                $this->collIgnorelistsRelatedByUserId = $collIgnorelistsRelatedByUserId;
                $this->collIgnorelistsRelatedByUserIdPartial = false;
            }
        }

        return $this->collIgnorelistsRelatedByUserId;
    }

    /**
     * Sets a collection of IgnorelistRelatedByUserId objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $ignorelistsRelatedByUserId A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setIgnorelistsRelatedByUserId(PropelCollection $ignorelistsRelatedByUserId, PropelPDO $con = null)
    {
        $this->ignorelistsRelatedByUserIdScheduledForDeletion = $this->getIgnorelistsRelatedByUserId(new Criteria(), $con)->diff($ignorelistsRelatedByUserId);

        foreach ($this->ignorelistsRelatedByUserIdScheduledForDeletion as $ignorelistRelatedByUserIdRemoved) {
            $ignorelistRelatedByUserIdRemoved->setsfGuardUserRelatedByUserId(null);
        }

        $this->collIgnorelistsRelatedByUserId = null;
        foreach ($ignorelistsRelatedByUserId as $ignorelistRelatedByUserId) {
            $this->addIgnorelistRelatedByUserId($ignorelistRelatedByUserId);
        }

        $this->collIgnorelistsRelatedByUserId = $ignorelistsRelatedByUserId;
        $this->collIgnorelistsRelatedByUserIdPartial = false;
    }

    /**
     * Returns the number of related Ignorelist objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related Ignorelist objects.
     * @throws PropelException
     */
    public function countIgnorelistsRelatedByUserId(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collIgnorelistsRelatedByUserIdPartial && !$this->isNew();
        if (null === $this->collIgnorelistsRelatedByUserId || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collIgnorelistsRelatedByUserId) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getIgnorelistsRelatedByUserId());
                }
                $query = IgnorelistQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUserRelatedByUserId($this)
                    ->count($con);
            }
        } else {
            return count($this->collIgnorelistsRelatedByUserId);
        }
    }

    /**
     * Method called to associate a Ignorelist object to this object
     * through the Ignorelist foreign key attribute.
     *
     * @param    Ignorelist $l Ignorelist
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addIgnorelistRelatedByUserId(Ignorelist $l)
    {
        if ($this->collIgnorelistsRelatedByUserId === null) {
            $this->initIgnorelistsRelatedByUserId();
            $this->collIgnorelistsRelatedByUserIdPartial = true;
        }
        if (!$this->collIgnorelistsRelatedByUserId->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddIgnorelistRelatedByUserId($l);
        }

        return $this;
    }

    /**
     * @param	IgnorelistRelatedByUserId $ignorelistRelatedByUserId The ignorelistRelatedByUserId object to add.
     */
    protected function doAddIgnorelistRelatedByUserId($ignorelistRelatedByUserId)
    {
        $this->collIgnorelistsRelatedByUserId[]= $ignorelistRelatedByUserId;
        $ignorelistRelatedByUserId->setsfGuardUserRelatedByUserId($this);
    }

    /**
     * @param	IgnorelistRelatedByUserId $ignorelistRelatedByUserId The ignorelistRelatedByUserId object to remove.
     */
    public function removeIgnorelistRelatedByUserId($ignorelistRelatedByUserId)
    {
        if ($this->getIgnorelistsRelatedByUserId()->contains($ignorelistRelatedByUserId)) {
            $this->collIgnorelistsRelatedByUserId->remove($this->collIgnorelistsRelatedByUserId->search($ignorelistRelatedByUserId));
            if (null === $this->ignorelistsRelatedByUserIdScheduledForDeletion) {
                $this->ignorelistsRelatedByUserIdScheduledForDeletion = clone $this->collIgnorelistsRelatedByUserId;
                $this->ignorelistsRelatedByUserIdScheduledForDeletion->clear();
            }
            $this->ignorelistsRelatedByUserIdScheduledForDeletion[]= $ignorelistRelatedByUserId;
            $ignorelistRelatedByUserId->setsfGuardUserRelatedByUserId(null);
        }
    }

    /**
     * Clears out the collIgnorelistsRelatedByIgnoredUserId collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addIgnorelistsRelatedByIgnoredUserId()
     */
    public function clearIgnorelistsRelatedByIgnoredUserId()
    {
        $this->collIgnorelistsRelatedByIgnoredUserId = null; // important to set this to null since that means it is uninitialized
        $this->collIgnorelistsRelatedByIgnoredUserIdPartial = null;
    }

    /**
     * reset is the collIgnorelistsRelatedByIgnoredUserId collection loaded partially
     *
     * @return void
     */
    public function resetPartialIgnorelistsRelatedByIgnoredUserId($v = true)
    {
        $this->collIgnorelistsRelatedByIgnoredUserIdPartial = $v;
    }

    /**
     * Initializes the collIgnorelistsRelatedByIgnoredUserId collection.
     *
     * By default this just sets the collIgnorelistsRelatedByIgnoredUserId collection to an empty array (like clearcollIgnorelistsRelatedByIgnoredUserId());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initIgnorelistsRelatedByIgnoredUserId($overrideExisting = true)
    {
        if (null !== $this->collIgnorelistsRelatedByIgnoredUserId && !$overrideExisting) {
            return;
        }
        $this->collIgnorelistsRelatedByIgnoredUserId = new PropelObjectCollection();
        $this->collIgnorelistsRelatedByIgnoredUserId->setModel('Ignorelist');
    }

    /**
     * Gets an array of Ignorelist objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|Ignorelist[] List of Ignorelist objects
     * @throws PropelException
     */
    public function getIgnorelistsRelatedByIgnoredUserId($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collIgnorelistsRelatedByIgnoredUserIdPartial && !$this->isNew();
        if (null === $this->collIgnorelistsRelatedByIgnoredUserId || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collIgnorelistsRelatedByIgnoredUserId) {
                // return empty collection
                $this->initIgnorelistsRelatedByIgnoredUserId();
            } else {
                $collIgnorelistsRelatedByIgnoredUserId = IgnorelistQuery::create(null, $criteria)
                    ->filterBysfGuardUserRelatedByIgnoredUserId($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collIgnorelistsRelatedByIgnoredUserIdPartial && count($collIgnorelistsRelatedByIgnoredUserId)) {
                      $this->initIgnorelistsRelatedByIgnoredUserId(false);

                      foreach($collIgnorelistsRelatedByIgnoredUserId as $obj) {
                        if (false == $this->collIgnorelistsRelatedByIgnoredUserId->contains($obj)) {
                          $this->collIgnorelistsRelatedByIgnoredUserId->append($obj);
                        }
                      }

                      $this->collIgnorelistsRelatedByIgnoredUserIdPartial = true;
                    }

                    return $collIgnorelistsRelatedByIgnoredUserId;
                }

                if($partial && $this->collIgnorelistsRelatedByIgnoredUserId) {
                    foreach($this->collIgnorelistsRelatedByIgnoredUserId as $obj) {
                        if($obj->isNew()) {
                            $collIgnorelistsRelatedByIgnoredUserId[] = $obj;
                        }
                    }
                }

                $this->collIgnorelistsRelatedByIgnoredUserId = $collIgnorelistsRelatedByIgnoredUserId;
                $this->collIgnorelistsRelatedByIgnoredUserIdPartial = false;
            }
        }

        return $this->collIgnorelistsRelatedByIgnoredUserId;
    }

    /**
     * Sets a collection of IgnorelistRelatedByIgnoredUserId objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $ignorelistsRelatedByIgnoredUserId A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setIgnorelistsRelatedByIgnoredUserId(PropelCollection $ignorelistsRelatedByIgnoredUserId, PropelPDO $con = null)
    {
        $this->ignorelistsRelatedByIgnoredUserIdScheduledForDeletion = $this->getIgnorelistsRelatedByIgnoredUserId(new Criteria(), $con)->diff($ignorelistsRelatedByIgnoredUserId);

        foreach ($this->ignorelistsRelatedByIgnoredUserIdScheduledForDeletion as $ignorelistRelatedByIgnoredUserIdRemoved) {
            $ignorelistRelatedByIgnoredUserIdRemoved->setsfGuardUserRelatedByIgnoredUserId(null);
        }

        $this->collIgnorelistsRelatedByIgnoredUserId = null;
        foreach ($ignorelistsRelatedByIgnoredUserId as $ignorelistRelatedByIgnoredUserId) {
            $this->addIgnorelistRelatedByIgnoredUserId($ignorelistRelatedByIgnoredUserId);
        }

        $this->collIgnorelistsRelatedByIgnoredUserId = $ignorelistsRelatedByIgnoredUserId;
        $this->collIgnorelistsRelatedByIgnoredUserIdPartial = false;
    }

    /**
     * Returns the number of related Ignorelist objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related Ignorelist objects.
     * @throws PropelException
     */
    public function countIgnorelistsRelatedByIgnoredUserId(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collIgnorelistsRelatedByIgnoredUserIdPartial && !$this->isNew();
        if (null === $this->collIgnorelistsRelatedByIgnoredUserId || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collIgnorelistsRelatedByIgnoredUserId) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getIgnorelistsRelatedByIgnoredUserId());
                }
                $query = IgnorelistQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUserRelatedByIgnoredUserId($this)
                    ->count($con);
            }
        } else {
            return count($this->collIgnorelistsRelatedByIgnoredUserId);
        }
    }

    /**
     * Method called to associate a Ignorelist object to this object
     * through the Ignorelist foreign key attribute.
     *
     * @param    Ignorelist $l Ignorelist
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addIgnorelistRelatedByIgnoredUserId(Ignorelist $l)
    {
        if ($this->collIgnorelistsRelatedByIgnoredUserId === null) {
            $this->initIgnorelistsRelatedByIgnoredUserId();
            $this->collIgnorelistsRelatedByIgnoredUserIdPartial = true;
        }
        if (!$this->collIgnorelistsRelatedByIgnoredUserId->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddIgnorelistRelatedByIgnoredUserId($l);
        }

        return $this;
    }

    /**
     * @param	IgnorelistRelatedByIgnoredUserId $ignorelistRelatedByIgnoredUserId The ignorelistRelatedByIgnoredUserId object to add.
     */
    protected function doAddIgnorelistRelatedByIgnoredUserId($ignorelistRelatedByIgnoredUserId)
    {
        $this->collIgnorelistsRelatedByIgnoredUserId[]= $ignorelistRelatedByIgnoredUserId;
        $ignorelistRelatedByIgnoredUserId->setsfGuardUserRelatedByIgnoredUserId($this);
    }

    /**
     * @param	IgnorelistRelatedByIgnoredUserId $ignorelistRelatedByIgnoredUserId The ignorelistRelatedByIgnoredUserId object to remove.
     */
    public function removeIgnorelistRelatedByIgnoredUserId($ignorelistRelatedByIgnoredUserId)
    {
        if ($this->getIgnorelistsRelatedByIgnoredUserId()->contains($ignorelistRelatedByIgnoredUserId)) {
            $this->collIgnorelistsRelatedByIgnoredUserId->remove($this->collIgnorelistsRelatedByIgnoredUserId->search($ignorelistRelatedByIgnoredUserId));
            if (null === $this->ignorelistsRelatedByIgnoredUserIdScheduledForDeletion) {
                $this->ignorelistsRelatedByIgnoredUserIdScheduledForDeletion = clone $this->collIgnorelistsRelatedByIgnoredUserId;
                $this->ignorelistsRelatedByIgnoredUserIdScheduledForDeletion->clear();
            }
            $this->ignorelistsRelatedByIgnoredUserIdScheduledForDeletion[]= $ignorelistRelatedByIgnoredUserId;
            $ignorelistRelatedByIgnoredUserId->setsfGuardUserRelatedByIgnoredUserId(null);
        }
    }

    /**
     * Clears out the collSessionss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addSessionss()
     */
    public function clearSessionss()
    {
        $this->collSessionss = null; // important to set this to null since that means it is uninitialized
        $this->collSessionssPartial = null;
    }

    /**
     * reset is the collSessionss collection loaded partially
     *
     * @return void
     */
    public function resetPartialSessionss($v = true)
    {
        $this->collSessionssPartial = $v;
    }

    /**
     * Initializes the collSessionss collection.
     *
     * By default this just sets the collSessionss collection to an empty array (like clearcollSessionss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initSessionss($overrideExisting = true)
    {
        if (null !== $this->collSessionss && !$overrideExisting) {
            return;
        }
        $this->collSessionss = new PropelObjectCollection();
        $this->collSessionss->setModel('Sessions');
    }

    /**
     * Gets an array of Sessions objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|Sessions[] List of Sessions objects
     * @throws PropelException
     */
    public function getSessionss($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collSessionssPartial && !$this->isNew();
        if (null === $this->collSessionss || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collSessionss) {
                // return empty collection
                $this->initSessionss();
            } else {
                $collSessionss = SessionsQuery::create(null, $criteria)
                    ->filterBysfGuardUser($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collSessionssPartial && count($collSessionss)) {
                      $this->initSessionss(false);

                      foreach($collSessionss as $obj) {
                        if (false == $this->collSessionss->contains($obj)) {
                          $this->collSessionss->append($obj);
                        }
                      }

                      $this->collSessionssPartial = true;
                    }

                    return $collSessionss;
                }

                if($partial && $this->collSessionss) {
                    foreach($this->collSessionss as $obj) {
                        if($obj->isNew()) {
                            $collSessionss[] = $obj;
                        }
                    }
                }

                $this->collSessionss = $collSessionss;
                $this->collSessionssPartial = false;
            }
        }

        return $this->collSessionss;
    }

    /**
     * Sets a collection of Sessions objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $sessionss A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setSessionss(PropelCollection $sessionss, PropelPDO $con = null)
    {
        $this->sessionssScheduledForDeletion = $this->getSessionss(new Criteria(), $con)->diff($sessionss);

        foreach ($this->sessionssScheduledForDeletion as $sessionsRemoved) {
            $sessionsRemoved->setsfGuardUser(null);
        }

        $this->collSessionss = null;
        foreach ($sessionss as $sessions) {
            $this->addSessions($sessions);
        }

        $this->collSessionss = $sessionss;
        $this->collSessionssPartial = false;
    }

    /**
     * Returns the number of related Sessions objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related Sessions objects.
     * @throws PropelException
     */
    public function countSessionss(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collSessionssPartial && !$this->isNew();
        if (null === $this->collSessionss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collSessionss) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getSessionss());
                }
                $query = SessionsQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUser($this)
                    ->count($con);
            }
        } else {
            return count($this->collSessionss);
        }
    }

    /**
     * Method called to associate a Sessions object to this object
     * through the Sessions foreign key attribute.
     *
     * @param    Sessions $l Sessions
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addSessions(Sessions $l)
    {
        if ($this->collSessionss === null) {
            $this->initSessionss();
            $this->collSessionssPartial = true;
        }
        if (!$this->collSessionss->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddSessions($l);
        }

        return $this;
    }

    /**
     * @param	Sessions $sessions The sessions object to add.
     */
    protected function doAddSessions($sessions)
    {
        $this->collSessionss[]= $sessions;
        $sessions->setsfGuardUser($this);
    }

    /**
     * @param	Sessions $sessions The sessions object to remove.
     */
    public function removeSessions($sessions)
    {
        if ($this->getSessionss()->contains($sessions)) {
            $this->collSessionss->remove($this->collSessionss->search($sessions));
            if (null === $this->sessionssScheduledForDeletion) {
                $this->sessionssScheduledForDeletion = clone $this->collSessionss;
                $this->sessionssScheduledForDeletion->clear();
            }
            $this->sessionssScheduledForDeletion[]= $sessions;
            $sessions->setsfGuardUser(null);
        }
    }

    /**
     * Clears out the collGuestsRelatedByUserId collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addGuestsRelatedByUserId()
     */
    public function clearGuestsRelatedByUserId()
    {
        $this->collGuestsRelatedByUserId = null; // important to set this to null since that means it is uninitialized
        $this->collGuestsRelatedByUserIdPartial = null;
    }

    /**
     * reset is the collGuestsRelatedByUserId collection loaded partially
     *
     * @return void
     */
    public function resetPartialGuestsRelatedByUserId($v = true)
    {
        $this->collGuestsRelatedByUserIdPartial = $v;
    }

    /**
     * Initializes the collGuestsRelatedByUserId collection.
     *
     * By default this just sets the collGuestsRelatedByUserId collection to an empty array (like clearcollGuestsRelatedByUserId());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initGuestsRelatedByUserId($overrideExisting = true)
    {
        if (null !== $this->collGuestsRelatedByUserId && !$overrideExisting) {
            return;
        }
        $this->collGuestsRelatedByUserId = new PropelObjectCollection();
        $this->collGuestsRelatedByUserId->setModel('Guest');
    }

    /**
     * Gets an array of Guest objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|Guest[] List of Guest objects
     * @throws PropelException
     */
    public function getGuestsRelatedByUserId($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collGuestsRelatedByUserIdPartial && !$this->isNew();
        if (null === $this->collGuestsRelatedByUserId || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collGuestsRelatedByUserId) {
                // return empty collection
                $this->initGuestsRelatedByUserId();
            } else {
                $collGuestsRelatedByUserId = GuestQuery::create(null, $criteria)
                    ->filterBysfGuardUserRelatedByUserId($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collGuestsRelatedByUserIdPartial && count($collGuestsRelatedByUserId)) {
                      $this->initGuestsRelatedByUserId(false);

                      foreach($collGuestsRelatedByUserId as $obj) {
                        if (false == $this->collGuestsRelatedByUserId->contains($obj)) {
                          $this->collGuestsRelatedByUserId->append($obj);
                        }
                      }

                      $this->collGuestsRelatedByUserIdPartial = true;
                    }

                    return $collGuestsRelatedByUserId;
                }

                if($partial && $this->collGuestsRelatedByUserId) {
                    foreach($this->collGuestsRelatedByUserId as $obj) {
                        if($obj->isNew()) {
                            $collGuestsRelatedByUserId[] = $obj;
                        }
                    }
                }

                $this->collGuestsRelatedByUserId = $collGuestsRelatedByUserId;
                $this->collGuestsRelatedByUserIdPartial = false;
            }
        }

        return $this->collGuestsRelatedByUserId;
    }

    /**
     * Sets a collection of GuestRelatedByUserId objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $guestsRelatedByUserId A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setGuestsRelatedByUserId(PropelCollection $guestsRelatedByUserId, PropelPDO $con = null)
    {
        $this->guestsRelatedByUserIdScheduledForDeletion = $this->getGuestsRelatedByUserId(new Criteria(), $con)->diff($guestsRelatedByUserId);

        foreach ($this->guestsRelatedByUserIdScheduledForDeletion as $guestRelatedByUserIdRemoved) {
            $guestRelatedByUserIdRemoved->setsfGuardUserRelatedByUserId(null);
        }

        $this->collGuestsRelatedByUserId = null;
        foreach ($guestsRelatedByUserId as $guestRelatedByUserId) {
            $this->addGuestRelatedByUserId($guestRelatedByUserId);
        }

        $this->collGuestsRelatedByUserId = $guestsRelatedByUserId;
        $this->collGuestsRelatedByUserIdPartial = false;
    }

    /**
     * Returns the number of related Guest objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related Guest objects.
     * @throws PropelException
     */
    public function countGuestsRelatedByUserId(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collGuestsRelatedByUserIdPartial && !$this->isNew();
        if (null === $this->collGuestsRelatedByUserId || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collGuestsRelatedByUserId) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getGuestsRelatedByUserId());
                }
                $query = GuestQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUserRelatedByUserId($this)
                    ->count($con);
            }
        } else {
            return count($this->collGuestsRelatedByUserId);
        }
    }

    /**
     * Method called to associate a Guest object to this object
     * through the Guest foreign key attribute.
     *
     * @param    Guest $l Guest
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addGuestRelatedByUserId(Guest $l)
    {
        if ($this->collGuestsRelatedByUserId === null) {
            $this->initGuestsRelatedByUserId();
            $this->collGuestsRelatedByUserIdPartial = true;
        }
        if (!$this->collGuestsRelatedByUserId->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddGuestRelatedByUserId($l);
        }

        return $this;
    }

    /**
     * @param	GuestRelatedByUserId $guestRelatedByUserId The guestRelatedByUserId object to add.
     */
    protected function doAddGuestRelatedByUserId($guestRelatedByUserId)
    {
        $this->collGuestsRelatedByUserId[]= $guestRelatedByUserId;
        $guestRelatedByUserId->setsfGuardUserRelatedByUserId($this);
    }

    /**
     * @param	GuestRelatedByUserId $guestRelatedByUserId The guestRelatedByUserId object to remove.
     */
    public function removeGuestRelatedByUserId($guestRelatedByUserId)
    {
        if ($this->getGuestsRelatedByUserId()->contains($guestRelatedByUserId)) {
            $this->collGuestsRelatedByUserId->remove($this->collGuestsRelatedByUserId->search($guestRelatedByUserId));
            if (null === $this->guestsRelatedByUserIdScheduledForDeletion) {
                $this->guestsRelatedByUserIdScheduledForDeletion = clone $this->collGuestsRelatedByUserId;
                $this->guestsRelatedByUserIdScheduledForDeletion->clear();
            }
            $this->guestsRelatedByUserIdScheduledForDeletion[]= $guestRelatedByUserId;
            $guestRelatedByUserId->setsfGuardUserRelatedByUserId(null);
        }
    }

    /**
     * Clears out the collGuestsRelatedByGuestId collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addGuestsRelatedByGuestId()
     */
    public function clearGuestsRelatedByGuestId()
    {
        $this->collGuestsRelatedByGuestId = null; // important to set this to null since that means it is uninitialized
        $this->collGuestsRelatedByGuestIdPartial = null;
    }

    /**
     * reset is the collGuestsRelatedByGuestId collection loaded partially
     *
     * @return void
     */
    public function resetPartialGuestsRelatedByGuestId($v = true)
    {
        $this->collGuestsRelatedByGuestIdPartial = $v;
    }

    /**
     * Initializes the collGuestsRelatedByGuestId collection.
     *
     * By default this just sets the collGuestsRelatedByGuestId collection to an empty array (like clearcollGuestsRelatedByGuestId());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initGuestsRelatedByGuestId($overrideExisting = true)
    {
        if (null !== $this->collGuestsRelatedByGuestId && !$overrideExisting) {
            return;
        }
        $this->collGuestsRelatedByGuestId = new PropelObjectCollection();
        $this->collGuestsRelatedByGuestId->setModel('Guest');
    }

    /**
     * Gets an array of Guest objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|Guest[] List of Guest objects
     * @throws PropelException
     */
    public function getGuestsRelatedByGuestId($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collGuestsRelatedByGuestIdPartial && !$this->isNew();
        if (null === $this->collGuestsRelatedByGuestId || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collGuestsRelatedByGuestId) {
                // return empty collection
                $this->initGuestsRelatedByGuestId();
            } else {
                $collGuestsRelatedByGuestId = GuestQuery::create(null, $criteria)
                    ->filterBysfGuardUserRelatedByGuestId($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collGuestsRelatedByGuestIdPartial && count($collGuestsRelatedByGuestId)) {
                      $this->initGuestsRelatedByGuestId(false);

                      foreach($collGuestsRelatedByGuestId as $obj) {
                        if (false == $this->collGuestsRelatedByGuestId->contains($obj)) {
                          $this->collGuestsRelatedByGuestId->append($obj);
                        }
                      }

                      $this->collGuestsRelatedByGuestIdPartial = true;
                    }

                    return $collGuestsRelatedByGuestId;
                }

                if($partial && $this->collGuestsRelatedByGuestId) {
                    foreach($this->collGuestsRelatedByGuestId as $obj) {
                        if($obj->isNew()) {
                            $collGuestsRelatedByGuestId[] = $obj;
                        }
                    }
                }

                $this->collGuestsRelatedByGuestId = $collGuestsRelatedByGuestId;
                $this->collGuestsRelatedByGuestIdPartial = false;
            }
        }

        return $this->collGuestsRelatedByGuestId;
    }

    /**
     * Sets a collection of GuestRelatedByGuestId objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $guestsRelatedByGuestId A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setGuestsRelatedByGuestId(PropelCollection $guestsRelatedByGuestId, PropelPDO $con = null)
    {
        $this->guestsRelatedByGuestIdScheduledForDeletion = $this->getGuestsRelatedByGuestId(new Criteria(), $con)->diff($guestsRelatedByGuestId);

        foreach ($this->guestsRelatedByGuestIdScheduledForDeletion as $guestRelatedByGuestIdRemoved) {
            $guestRelatedByGuestIdRemoved->setsfGuardUserRelatedByGuestId(null);
        }

        $this->collGuestsRelatedByGuestId = null;
        foreach ($guestsRelatedByGuestId as $guestRelatedByGuestId) {
            $this->addGuestRelatedByGuestId($guestRelatedByGuestId);
        }

        $this->collGuestsRelatedByGuestId = $guestsRelatedByGuestId;
        $this->collGuestsRelatedByGuestIdPartial = false;
    }

    /**
     * Returns the number of related Guest objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related Guest objects.
     * @throws PropelException
     */
    public function countGuestsRelatedByGuestId(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collGuestsRelatedByGuestIdPartial && !$this->isNew();
        if (null === $this->collGuestsRelatedByGuestId || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collGuestsRelatedByGuestId) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getGuestsRelatedByGuestId());
                }
                $query = GuestQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUserRelatedByGuestId($this)
                    ->count($con);
            }
        } else {
            return count($this->collGuestsRelatedByGuestId);
        }
    }

    /**
     * Method called to associate a Guest object to this object
     * through the Guest foreign key attribute.
     *
     * @param    Guest $l Guest
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addGuestRelatedByGuestId(Guest $l)
    {
        if ($this->collGuestsRelatedByGuestId === null) {
            $this->initGuestsRelatedByGuestId();
            $this->collGuestsRelatedByGuestIdPartial = true;
        }
        if (!$this->collGuestsRelatedByGuestId->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddGuestRelatedByGuestId($l);
        }

        return $this;
    }

    /**
     * @param	GuestRelatedByGuestId $guestRelatedByGuestId The guestRelatedByGuestId object to add.
     */
    protected function doAddGuestRelatedByGuestId($guestRelatedByGuestId)
    {
        $this->collGuestsRelatedByGuestId[]= $guestRelatedByGuestId;
        $guestRelatedByGuestId->setsfGuardUserRelatedByGuestId($this);
    }

    /**
     * @param	GuestRelatedByGuestId $guestRelatedByGuestId The guestRelatedByGuestId object to remove.
     */
    public function removeGuestRelatedByGuestId($guestRelatedByGuestId)
    {
        if ($this->getGuestsRelatedByGuestId()->contains($guestRelatedByGuestId)) {
            $this->collGuestsRelatedByGuestId->remove($this->collGuestsRelatedByGuestId->search($guestRelatedByGuestId));
            if (null === $this->guestsRelatedByGuestIdScheduledForDeletion) {
                $this->guestsRelatedByGuestIdScheduledForDeletion = clone $this->collGuestsRelatedByGuestId;
                $this->guestsRelatedByGuestIdScheduledForDeletion->clear();
            }
            $this->guestsRelatedByGuestIdScheduledForDeletion[]= $guestRelatedByGuestId;
            $guestRelatedByGuestId->setsfGuardUserRelatedByGuestId(null);
        }
    }

    /**
     * Clears out the collGameUsers collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addGameUsers()
     */
    public function clearGameUsers()
    {
        $this->collGameUsers = null; // important to set this to null since that means it is uninitialized
        $this->collGameUsersPartial = null;
    }

    /**
     * reset is the collGameUsers collection loaded partially
     *
     * @return void
     */
    public function resetPartialGameUsers($v = true)
    {
        $this->collGameUsersPartial = $v;
    }

    /**
     * Initializes the collGameUsers collection.
     *
     * By default this just sets the collGameUsers collection to an empty array (like clearcollGameUsers());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initGameUsers($overrideExisting = true)
    {
        if (null !== $this->collGameUsers && !$overrideExisting) {
            return;
        }
        $this->collGameUsers = new PropelObjectCollection();
        $this->collGameUsers->setModel('GameUser');
    }

    /**
     * Gets an array of GameUser objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|GameUser[] List of GameUser objects
     * @throws PropelException
     */
    public function getGameUsers($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collGameUsersPartial && !$this->isNew();
        if (null === $this->collGameUsers || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collGameUsers) {
                // return empty collection
                $this->initGameUsers();
            } else {
                $collGameUsers = GameUserQuery::create(null, $criteria)
                    ->filterBysfGuardUser($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collGameUsersPartial && count($collGameUsers)) {
                      $this->initGameUsers(false);

                      foreach($collGameUsers as $obj) {
                        if (false == $this->collGameUsers->contains($obj)) {
                          $this->collGameUsers->append($obj);
                        }
                      }

                      $this->collGameUsersPartial = true;
                    }

                    return $collGameUsers;
                }

                if($partial && $this->collGameUsers) {
                    foreach($this->collGameUsers as $obj) {
                        if($obj->isNew()) {
                            $collGameUsers[] = $obj;
                        }
                    }
                }

                $this->collGameUsers = $collGameUsers;
                $this->collGameUsersPartial = false;
            }
        }

        return $this->collGameUsers;
    }

    /**
     * Sets a collection of GameUser objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $gameUsers A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setGameUsers(PropelCollection $gameUsers, PropelPDO $con = null)
    {
        $this->gameUsersScheduledForDeletion = $this->getGameUsers(new Criteria(), $con)->diff($gameUsers);

        foreach ($this->gameUsersScheduledForDeletion as $gameUserRemoved) {
            $gameUserRemoved->setsfGuardUser(null);
        }

        $this->collGameUsers = null;
        foreach ($gameUsers as $gameUser) {
            $this->addGameUser($gameUser);
        }

        $this->collGameUsers = $gameUsers;
        $this->collGameUsersPartial = false;
    }

    /**
     * Returns the number of related GameUser objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related GameUser objects.
     * @throws PropelException
     */
    public function countGameUsers(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collGameUsersPartial && !$this->isNew();
        if (null === $this->collGameUsers || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collGameUsers) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getGameUsers());
                }
                $query = GameUserQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUser($this)
                    ->count($con);
            }
        } else {
            return count($this->collGameUsers);
        }
    }

    /**
     * Method called to associate a GameUser object to this object
     * through the GameUser foreign key attribute.
     *
     * @param    GameUser $l GameUser
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addGameUser(GameUser $l)
    {
        if ($this->collGameUsers === null) {
            $this->initGameUsers();
            $this->collGameUsersPartial = true;
        }
        if (!$this->collGameUsers->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddGameUser($l);
        }

        return $this;
    }

    /**
     * @param	GameUser $gameUser The gameUser object to add.
     */
    protected function doAddGameUser($gameUser)
    {
        $this->collGameUsers[]= $gameUser;
        $gameUser->setsfGuardUser($this);
    }

    /**
     * @param	GameUser $gameUser The gameUser object to remove.
     */
    public function removeGameUser($gameUser)
    {
        if ($this->getGameUsers()->contains($gameUser)) {
            $this->collGameUsers->remove($this->collGameUsers->search($gameUser));
            if (null === $this->gameUsersScheduledForDeletion) {
                $this->gameUsersScheduledForDeletion = clone $this->collGameUsers;
                $this->gameUsersScheduledForDeletion->clear();
            }
            $this->gameUsersScheduledForDeletion[]= $gameUser;
            $gameUser->setsfGuardUser(null);
        }
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this sfGuardUser is new, it will return
     * an empty collection; or if this sfGuardUser has previously
     * been saved, it will retrieve related GameUsers from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in sfGuardUser.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @param string $join_behavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return PropelObjectCollection|GameUser[] List of GameUser objects
     */
    public function getGameUsersJoinGame($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
    {
        $query = GameUserQuery::create(null, $criteria);
        $query->joinWith('Game', $join_behavior);

        return $this->getGameUsers($query, $con);
    }

    /**
     * Clears out the collMusics collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addMusics()
     */
    public function clearMusics()
    {
        $this->collMusics = null; // important to set this to null since that means it is uninitialized
        $this->collMusicsPartial = null;
    }

    /**
     * reset is the collMusics collection loaded partially
     *
     * @return void
     */
    public function resetPartialMusics($v = true)
    {
        $this->collMusicsPartial = $v;
    }

    /**
     * Initializes the collMusics collection.
     *
     * By default this just sets the collMusics collection to an empty array (like clearcollMusics());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initMusics($overrideExisting = true)
    {
        if (null !== $this->collMusics && !$overrideExisting) {
            return;
        }
        $this->collMusics = new PropelObjectCollection();
        $this->collMusics->setModel('Music');
    }

    /**
     * Gets an array of Music objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|Music[] List of Music objects
     * @throws PropelException
     */
    public function getMusics($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collMusicsPartial && !$this->isNew();
        if (null === $this->collMusics || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collMusics) {
                // return empty collection
                $this->initMusics();
            } else {
                $collMusics = MusicQuery::create(null, $criteria)
                    ->filterBysfGuardUser($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collMusicsPartial && count($collMusics)) {
                      $this->initMusics(false);

                      foreach($collMusics as $obj) {
                        if (false == $this->collMusics->contains($obj)) {
                          $this->collMusics->append($obj);
                        }
                      }

                      $this->collMusicsPartial = true;
                    }

                    return $collMusics;
                }

                if($partial && $this->collMusics) {
                    foreach($this->collMusics as $obj) {
                        if($obj->isNew()) {
                            $collMusics[] = $obj;
                        }
                    }
                }

                $this->collMusics = $collMusics;
                $this->collMusicsPartial = false;
            }
        }

        return $this->collMusics;
    }

    /**
     * Sets a collection of Music objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $musics A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setMusics(PropelCollection $musics, PropelPDO $con = null)
    {
        $this->musicsScheduledForDeletion = $this->getMusics(new Criteria(), $con)->diff($musics);

        foreach ($this->musicsScheduledForDeletion as $musicRemoved) {
            $musicRemoved->setsfGuardUser(null);
        }

        $this->collMusics = null;
        foreach ($musics as $music) {
            $this->addMusic($music);
        }

        $this->collMusics = $musics;
        $this->collMusicsPartial = false;
    }

    /**
     * Returns the number of related Music objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related Music objects.
     * @throws PropelException
     */
    public function countMusics(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collMusicsPartial && !$this->isNew();
        if (null === $this->collMusics || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collMusics) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getMusics());
                }
                $query = MusicQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUser($this)
                    ->count($con);
            }
        } else {
            return count($this->collMusics);
        }
    }

    /**
     * Method called to associate a Music object to this object
     * through the Music foreign key attribute.
     *
     * @param    Music $l Music
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addMusic(Music $l)
    {
        if ($this->collMusics === null) {
            $this->initMusics();
            $this->collMusicsPartial = true;
        }
        if (!$this->collMusics->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddMusic($l);
        }

        return $this;
    }

    /**
     * @param	Music $music The music object to add.
     */
    protected function doAddMusic($music)
    {
        $this->collMusics[]= $music;
        $music->setsfGuardUser($this);
    }

    /**
     * @param	Music $music The music object to remove.
     */
    public function removeMusic($music)
    {
        if ($this->getMusics()->contains($music)) {
            $this->collMusics->remove($this->collMusics->search($music));
            if (null === $this->musicsScheduledForDeletion) {
                $this->musicsScheduledForDeletion = clone $this->collMusics;
                $this->musicsScheduledForDeletion->clear();
            }
            $this->musicsScheduledForDeletion[]= $music;
            $music->setsfGuardUser(null);
        }
    }

    /**
     * Clears out the collPlaylists collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addPlaylists()
     */
    public function clearPlaylists()
    {
        $this->collPlaylists = null; // important to set this to null since that means it is uninitialized
        $this->collPlaylistsPartial = null;
    }

    /**
     * reset is the collPlaylists collection loaded partially
     *
     * @return void
     */
    public function resetPartialPlaylists($v = true)
    {
        $this->collPlaylistsPartial = $v;
    }

    /**
     * Initializes the collPlaylists collection.
     *
     * By default this just sets the collPlaylists collection to an empty array (like clearcollPlaylists());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initPlaylists($overrideExisting = true)
    {
        if (null !== $this->collPlaylists && !$overrideExisting) {
            return;
        }
        $this->collPlaylists = new PropelObjectCollection();
        $this->collPlaylists->setModel('Playlist');
    }

    /**
     * Gets an array of Playlist objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|Playlist[] List of Playlist objects
     * @throws PropelException
     */
    public function getPlaylists($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collPlaylistsPartial && !$this->isNew();
        if (null === $this->collPlaylists || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collPlaylists) {
                // return empty collection
                $this->initPlaylists();
            } else {
                $collPlaylists = PlaylistQuery::create(null, $criteria)
                    ->filterBysfGuardUser($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collPlaylistsPartial && count($collPlaylists)) {
                      $this->initPlaylists(false);

                      foreach($collPlaylists as $obj) {
                        if (false == $this->collPlaylists->contains($obj)) {
                          $this->collPlaylists->append($obj);
                        }
                      }

                      $this->collPlaylistsPartial = true;
                    }

                    return $collPlaylists;
                }

                if($partial && $this->collPlaylists) {
                    foreach($this->collPlaylists as $obj) {
                        if($obj->isNew()) {
                            $collPlaylists[] = $obj;
                        }
                    }
                }

                $this->collPlaylists = $collPlaylists;
                $this->collPlaylistsPartial = false;
            }
        }

        return $this->collPlaylists;
    }

    /**
     * Sets a collection of Playlist objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $playlists A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setPlaylists(PropelCollection $playlists, PropelPDO $con = null)
    {
        $this->playlistsScheduledForDeletion = $this->getPlaylists(new Criteria(), $con)->diff($playlists);

        foreach ($this->playlistsScheduledForDeletion as $playlistRemoved) {
            $playlistRemoved->setsfGuardUser(null);
        }

        $this->collPlaylists = null;
        foreach ($playlists as $playlist) {
            $this->addPlaylist($playlist);
        }

        $this->collPlaylists = $playlists;
        $this->collPlaylistsPartial = false;
    }

    /**
     * Returns the number of related Playlist objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related Playlist objects.
     * @throws PropelException
     */
    public function countPlaylists(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collPlaylistsPartial && !$this->isNew();
        if (null === $this->collPlaylists || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collPlaylists) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getPlaylists());
                }
                $query = PlaylistQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUser($this)
                    ->count($con);
            }
        } else {
            return count($this->collPlaylists);
        }
    }

    /**
     * Method called to associate a Playlist object to this object
     * through the Playlist foreign key attribute.
     *
     * @param    Playlist $l Playlist
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addPlaylist(Playlist $l)
    {
        if ($this->collPlaylists === null) {
            $this->initPlaylists();
            $this->collPlaylistsPartial = true;
        }
        if (!$this->collPlaylists->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddPlaylist($l);
        }

        return $this;
    }

    /**
     * @param	Playlist $playlist The playlist object to add.
     */
    protected function doAddPlaylist($playlist)
    {
        $this->collPlaylists[]= $playlist;
        $playlist->setsfGuardUser($this);
    }

    /**
     * @param	Playlist $playlist The playlist object to remove.
     */
    public function removePlaylist($playlist)
    {
        if ($this->getPlaylists()->contains($playlist)) {
            $this->collPlaylists->remove($this->collPlaylists->search($playlist));
            if (null === $this->playlistsScheduledForDeletion) {
                $this->playlistsScheduledForDeletion = clone $this->collPlaylists;
                $this->playlistsScheduledForDeletion->clear();
            }
            $this->playlistsScheduledForDeletion[]= $playlist;
            $playlist->setsfGuardUser(null);
        }
    }

    /**
     * Clears out the collPlaylistComments collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addPlaylistComments()
     */
    public function clearPlaylistComments()
    {
        $this->collPlaylistComments = null; // important to set this to null since that means it is uninitialized
        $this->collPlaylistCommentsPartial = null;
    }

    /**
     * reset is the collPlaylistComments collection loaded partially
     *
     * @return void
     */
    public function resetPartialPlaylistComments($v = true)
    {
        $this->collPlaylistCommentsPartial = $v;
    }

    /**
     * Initializes the collPlaylistComments collection.
     *
     * By default this just sets the collPlaylistComments collection to an empty array (like clearcollPlaylistComments());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initPlaylistComments($overrideExisting = true)
    {
        if (null !== $this->collPlaylistComments && !$overrideExisting) {
            return;
        }
        $this->collPlaylistComments = new PropelObjectCollection();
        $this->collPlaylistComments->setModel('PlaylistComment');
    }

    /**
     * Gets an array of PlaylistComment objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|PlaylistComment[] List of PlaylistComment objects
     * @throws PropelException
     */
    public function getPlaylistComments($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collPlaylistCommentsPartial && !$this->isNew();
        if (null === $this->collPlaylistComments || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collPlaylistComments) {
                // return empty collection
                $this->initPlaylistComments();
            } else {
                $collPlaylistComments = PlaylistCommentQuery::create(null, $criteria)
                    ->filterBysfGuardUser($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collPlaylistCommentsPartial && count($collPlaylistComments)) {
                      $this->initPlaylistComments(false);

                      foreach($collPlaylistComments as $obj) {
                        if (false == $this->collPlaylistComments->contains($obj)) {
                          $this->collPlaylistComments->append($obj);
                        }
                      }

                      $this->collPlaylistCommentsPartial = true;
                    }

                    return $collPlaylistComments;
                }

                if($partial && $this->collPlaylistComments) {
                    foreach($this->collPlaylistComments as $obj) {
                        if($obj->isNew()) {
                            $collPlaylistComments[] = $obj;
                        }
                    }
                }

                $this->collPlaylistComments = $collPlaylistComments;
                $this->collPlaylistCommentsPartial = false;
            }
        }

        return $this->collPlaylistComments;
    }

    /**
     * Sets a collection of PlaylistComment objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $playlistComments A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setPlaylistComments(PropelCollection $playlistComments, PropelPDO $con = null)
    {
        $this->playlistCommentsScheduledForDeletion = $this->getPlaylistComments(new Criteria(), $con)->diff($playlistComments);

        foreach ($this->playlistCommentsScheduledForDeletion as $playlistCommentRemoved) {
            $playlistCommentRemoved->setsfGuardUser(null);
        }

        $this->collPlaylistComments = null;
        foreach ($playlistComments as $playlistComment) {
            $this->addPlaylistComment($playlistComment);
        }

        $this->collPlaylistComments = $playlistComments;
        $this->collPlaylistCommentsPartial = false;
    }

    /**
     * Returns the number of related PlaylistComment objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related PlaylistComment objects.
     * @throws PropelException
     */
    public function countPlaylistComments(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collPlaylistCommentsPartial && !$this->isNew();
        if (null === $this->collPlaylistComments || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collPlaylistComments) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getPlaylistComments());
                }
                $query = PlaylistCommentQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUser($this)
                    ->count($con);
            }
        } else {
            return count($this->collPlaylistComments);
        }
    }

    /**
     * Method called to associate a PlaylistComment object to this object
     * through the PlaylistComment foreign key attribute.
     *
     * @param    PlaylistComment $l PlaylistComment
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addPlaylistComment(PlaylistComment $l)
    {
        if ($this->collPlaylistComments === null) {
            $this->initPlaylistComments();
            $this->collPlaylistCommentsPartial = true;
        }
        if (!$this->collPlaylistComments->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddPlaylistComment($l);
        }

        return $this;
    }

    /**
     * @param	PlaylistComment $playlistComment The playlistComment object to add.
     */
    protected function doAddPlaylistComment($playlistComment)
    {
        $this->collPlaylistComments[]= $playlistComment;
        $playlistComment->setsfGuardUser($this);
    }

    /**
     * @param	PlaylistComment $playlistComment The playlistComment object to remove.
     */
    public function removePlaylistComment($playlistComment)
    {
        if ($this->getPlaylistComments()->contains($playlistComment)) {
            $this->collPlaylistComments->remove($this->collPlaylistComments->search($playlistComment));
            if (null === $this->playlistCommentsScheduledForDeletion) {
                $this->playlistCommentsScheduledForDeletion = clone $this->collPlaylistComments;
                $this->playlistCommentsScheduledForDeletion->clear();
            }
            $this->playlistCommentsScheduledForDeletion[]= $playlistComment;
            $playlistComment->setsfGuardUser(null);
        }
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this sfGuardUser is new, it will return
     * an empty collection; or if this sfGuardUser has previously
     * been saved, it will retrieve related PlaylistComments from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in sfGuardUser.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @param string $join_behavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return PropelObjectCollection|PlaylistComment[] List of PlaylistComment objects
     */
    public function getPlaylistCommentsJoinPlaylist($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
    {
        $query = PlaylistCommentQuery::create(null, $criteria);
        $query->joinWith('Playlist', $join_behavior);

        return $this->getPlaylistComments($query, $con);
    }

    /**
     * Clears out the collPlaylistFavs collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addPlaylistFavs()
     */
    public function clearPlaylistFavs()
    {
        $this->collPlaylistFavs = null; // important to set this to null since that means it is uninitialized
        $this->collPlaylistFavsPartial = null;
    }

    /**
     * reset is the collPlaylistFavs collection loaded partially
     *
     * @return void
     */
    public function resetPartialPlaylistFavs($v = true)
    {
        $this->collPlaylistFavsPartial = $v;
    }

    /**
     * Initializes the collPlaylistFavs collection.
     *
     * By default this just sets the collPlaylistFavs collection to an empty array (like clearcollPlaylistFavs());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initPlaylistFavs($overrideExisting = true)
    {
        if (null !== $this->collPlaylistFavs && !$overrideExisting) {
            return;
        }
        $this->collPlaylistFavs = new PropelObjectCollection();
        $this->collPlaylistFavs->setModel('PlaylistFav');
    }

    /**
     * Gets an array of PlaylistFav objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|PlaylistFav[] List of PlaylistFav objects
     * @throws PropelException
     */
    public function getPlaylistFavs($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collPlaylistFavsPartial && !$this->isNew();
        if (null === $this->collPlaylistFavs || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collPlaylistFavs) {
                // return empty collection
                $this->initPlaylistFavs();
            } else {
                $collPlaylistFavs = PlaylistFavQuery::create(null, $criteria)
                    ->filterBysfGuardUser($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collPlaylistFavsPartial && count($collPlaylistFavs)) {
                      $this->initPlaylistFavs(false);

                      foreach($collPlaylistFavs as $obj) {
                        if (false == $this->collPlaylistFavs->contains($obj)) {
                          $this->collPlaylistFavs->append($obj);
                        }
                      }

                      $this->collPlaylistFavsPartial = true;
                    }

                    return $collPlaylistFavs;
                }

                if($partial && $this->collPlaylistFavs) {
                    foreach($this->collPlaylistFavs as $obj) {
                        if($obj->isNew()) {
                            $collPlaylistFavs[] = $obj;
                        }
                    }
                }

                $this->collPlaylistFavs = $collPlaylistFavs;
                $this->collPlaylistFavsPartial = false;
            }
        }

        return $this->collPlaylistFavs;
    }

    /**
     * Sets a collection of PlaylistFav objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $playlistFavs A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setPlaylistFavs(PropelCollection $playlistFavs, PropelPDO $con = null)
    {
        $this->playlistFavsScheduledForDeletion = $this->getPlaylistFavs(new Criteria(), $con)->diff($playlistFavs);

        foreach ($this->playlistFavsScheduledForDeletion as $playlistFavRemoved) {
            $playlistFavRemoved->setsfGuardUser(null);
        }

        $this->collPlaylistFavs = null;
        foreach ($playlistFavs as $playlistFav) {
            $this->addPlaylistFav($playlistFav);
        }

        $this->collPlaylistFavs = $playlistFavs;
        $this->collPlaylistFavsPartial = false;
    }

    /**
     * Returns the number of related PlaylistFav objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related PlaylistFav objects.
     * @throws PropelException
     */
    public function countPlaylistFavs(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collPlaylistFavsPartial && !$this->isNew();
        if (null === $this->collPlaylistFavs || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collPlaylistFavs) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getPlaylistFavs());
                }
                $query = PlaylistFavQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUser($this)
                    ->count($con);
            }
        } else {
            return count($this->collPlaylistFavs);
        }
    }

    /**
     * Method called to associate a PlaylistFav object to this object
     * through the PlaylistFav foreign key attribute.
     *
     * @param    PlaylistFav $l PlaylistFav
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addPlaylistFav(PlaylistFav $l)
    {
        if ($this->collPlaylistFavs === null) {
            $this->initPlaylistFavs();
            $this->collPlaylistFavsPartial = true;
        }
        if (!$this->collPlaylistFavs->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddPlaylistFav($l);
        }

        return $this;
    }

    /**
     * @param	PlaylistFav $playlistFav The playlistFav object to add.
     */
    protected function doAddPlaylistFav($playlistFav)
    {
        $this->collPlaylistFavs[]= $playlistFav;
        $playlistFav->setsfGuardUser($this);
    }

    /**
     * @param	PlaylistFav $playlistFav The playlistFav object to remove.
     */
    public function removePlaylistFav($playlistFav)
    {
        if ($this->getPlaylistFavs()->contains($playlistFav)) {
            $this->collPlaylistFavs->remove($this->collPlaylistFavs->search($playlistFav));
            if (null === $this->playlistFavsScheduledForDeletion) {
                $this->playlistFavsScheduledForDeletion = clone $this->collPlaylistFavs;
                $this->playlistFavsScheduledForDeletion->clear();
            }
            $this->playlistFavsScheduledForDeletion[]= $playlistFav;
            $playlistFav->setsfGuardUser(null);
        }
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this sfGuardUser is new, it will return
     * an empty collection; or if this sfGuardUser has previously
     * been saved, it will retrieve related PlaylistFavs from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in sfGuardUser.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @param string $join_behavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return PropelObjectCollection|PlaylistFav[] List of PlaylistFav objects
     */
    public function getPlaylistFavsJoinPlaylist($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
    {
        $query = PlaylistFavQuery::create(null, $criteria);
        $query->joinWith('Playlist', $join_behavior);

        return $this->getPlaylistFavs($query, $con);
    }

    /**
     * Clears out the collYtvideoFavs collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addYtvideoFavs()
     */
    public function clearYtvideoFavs()
    {
        $this->collYtvideoFavs = null; // important to set this to null since that means it is uninitialized
        $this->collYtvideoFavsPartial = null;
    }

    /**
     * reset is the collYtvideoFavs collection loaded partially
     *
     * @return void
     */
    public function resetPartialYtvideoFavs($v = true)
    {
        $this->collYtvideoFavsPartial = $v;
    }

    /**
     * Initializes the collYtvideoFavs collection.
     *
     * By default this just sets the collYtvideoFavs collection to an empty array (like clearcollYtvideoFavs());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initYtvideoFavs($overrideExisting = true)
    {
        if (null !== $this->collYtvideoFavs && !$overrideExisting) {
            return;
        }
        $this->collYtvideoFavs = new PropelObjectCollection();
        $this->collYtvideoFavs->setModel('YtvideoFav');
    }

    /**
     * Gets an array of YtvideoFav objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|YtvideoFav[] List of YtvideoFav objects
     * @throws PropelException
     */
    public function getYtvideoFavs($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collYtvideoFavsPartial && !$this->isNew();
        if (null === $this->collYtvideoFavs || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collYtvideoFavs) {
                // return empty collection
                $this->initYtvideoFavs();
            } else {
                $collYtvideoFavs = YtvideoFavQuery::create(null, $criteria)
                    ->filterBysfGuardUser($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collYtvideoFavsPartial && count($collYtvideoFavs)) {
                      $this->initYtvideoFavs(false);

                      foreach($collYtvideoFavs as $obj) {
                        if (false == $this->collYtvideoFavs->contains($obj)) {
                          $this->collYtvideoFavs->append($obj);
                        }
                      }

                      $this->collYtvideoFavsPartial = true;
                    }

                    return $collYtvideoFavs;
                }

                if($partial && $this->collYtvideoFavs) {
                    foreach($this->collYtvideoFavs as $obj) {
                        if($obj->isNew()) {
                            $collYtvideoFavs[] = $obj;
                        }
                    }
                }

                $this->collYtvideoFavs = $collYtvideoFavs;
                $this->collYtvideoFavsPartial = false;
            }
        }

        return $this->collYtvideoFavs;
    }

    /**
     * Sets a collection of YtvideoFav objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $ytvideoFavs A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setYtvideoFavs(PropelCollection $ytvideoFavs, PropelPDO $con = null)
    {
        $this->ytvideoFavsScheduledForDeletion = $this->getYtvideoFavs(new Criteria(), $con)->diff($ytvideoFavs);

        foreach ($this->ytvideoFavsScheduledForDeletion as $ytvideoFavRemoved) {
            $ytvideoFavRemoved->setsfGuardUser(null);
        }

        $this->collYtvideoFavs = null;
        foreach ($ytvideoFavs as $ytvideoFav) {
            $this->addYtvideoFav($ytvideoFav);
        }

        $this->collYtvideoFavs = $ytvideoFavs;
        $this->collYtvideoFavsPartial = false;
    }

    /**
     * Returns the number of related YtvideoFav objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related YtvideoFav objects.
     * @throws PropelException
     */
    public function countYtvideoFavs(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collYtvideoFavsPartial && !$this->isNew();
        if (null === $this->collYtvideoFavs || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collYtvideoFavs) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getYtvideoFavs());
                }
                $query = YtvideoFavQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUser($this)
                    ->count($con);
            }
        } else {
            return count($this->collYtvideoFavs);
        }
    }

    /**
     * Method called to associate a YtvideoFav object to this object
     * through the YtvideoFav foreign key attribute.
     *
     * @param    YtvideoFav $l YtvideoFav
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addYtvideoFav(YtvideoFav $l)
    {
        if ($this->collYtvideoFavs === null) {
            $this->initYtvideoFavs();
            $this->collYtvideoFavsPartial = true;
        }
        if (!$this->collYtvideoFavs->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddYtvideoFav($l);
        }

        return $this;
    }

    /**
     * @param	YtvideoFav $ytvideoFav The ytvideoFav object to add.
     */
    protected function doAddYtvideoFav($ytvideoFav)
    {
        $this->collYtvideoFavs[]= $ytvideoFav;
        $ytvideoFav->setsfGuardUser($this);
    }

    /**
     * @param	YtvideoFav $ytvideoFav The ytvideoFav object to remove.
     */
    public function removeYtvideoFav($ytvideoFav)
    {
        if ($this->getYtvideoFavs()->contains($ytvideoFav)) {
            $this->collYtvideoFavs->remove($this->collYtvideoFavs->search($ytvideoFav));
            if (null === $this->ytvideoFavsScheduledForDeletion) {
                $this->ytvideoFavsScheduledForDeletion = clone $this->collYtvideoFavs;
                $this->ytvideoFavsScheduledForDeletion->clear();
            }
            $this->ytvideoFavsScheduledForDeletion[]= $ytvideoFav;
            $ytvideoFav->setsfGuardUser(null);
        }
    }

    /**
     * Clears out the collVideolists collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addVideolists()
     */
    public function clearVideolists()
    {
        $this->collVideolists = null; // important to set this to null since that means it is uninitialized
        $this->collVideolistsPartial = null;
    }

    /**
     * reset is the collVideolists collection loaded partially
     *
     * @return void
     */
    public function resetPartialVideolists($v = true)
    {
        $this->collVideolistsPartial = $v;
    }

    /**
     * Initializes the collVideolists collection.
     *
     * By default this just sets the collVideolists collection to an empty array (like clearcollVideolists());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initVideolists($overrideExisting = true)
    {
        if (null !== $this->collVideolists && !$overrideExisting) {
            return;
        }
        $this->collVideolists = new PropelObjectCollection();
        $this->collVideolists->setModel('Videolist');
    }

    /**
     * Gets an array of Videolist objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|Videolist[] List of Videolist objects
     * @throws PropelException
     */
    public function getVideolists($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collVideolistsPartial && !$this->isNew();
        if (null === $this->collVideolists || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collVideolists) {
                // return empty collection
                $this->initVideolists();
            } else {
                $collVideolists = VideolistQuery::create(null, $criteria)
                    ->filterBysfGuardUser($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collVideolistsPartial && count($collVideolists)) {
                      $this->initVideolists(false);

                      foreach($collVideolists as $obj) {
                        if (false == $this->collVideolists->contains($obj)) {
                          $this->collVideolists->append($obj);
                        }
                      }

                      $this->collVideolistsPartial = true;
                    }

                    return $collVideolists;
                }

                if($partial && $this->collVideolists) {
                    foreach($this->collVideolists as $obj) {
                        if($obj->isNew()) {
                            $collVideolists[] = $obj;
                        }
                    }
                }

                $this->collVideolists = $collVideolists;
                $this->collVideolistsPartial = false;
            }
        }

        return $this->collVideolists;
    }

    /**
     * Sets a collection of Videolist objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $videolists A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setVideolists(PropelCollection $videolists, PropelPDO $con = null)
    {
        $this->videolistsScheduledForDeletion = $this->getVideolists(new Criteria(), $con)->diff($videolists);

        foreach ($this->videolistsScheduledForDeletion as $videolistRemoved) {
            $videolistRemoved->setsfGuardUser(null);
        }

        $this->collVideolists = null;
        foreach ($videolists as $videolist) {
            $this->addVideolist($videolist);
        }

        $this->collVideolists = $videolists;
        $this->collVideolistsPartial = false;
    }

    /**
     * Returns the number of related Videolist objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related Videolist objects.
     * @throws PropelException
     */
    public function countVideolists(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collVideolistsPartial && !$this->isNew();
        if (null === $this->collVideolists || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collVideolists) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getVideolists());
                }
                $query = VideolistQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUser($this)
                    ->count($con);
            }
        } else {
            return count($this->collVideolists);
        }
    }

    /**
     * Method called to associate a Videolist object to this object
     * through the Videolist foreign key attribute.
     *
     * @param    Videolist $l Videolist
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addVideolist(Videolist $l)
    {
        if ($this->collVideolists === null) {
            $this->initVideolists();
            $this->collVideolistsPartial = true;
        }
        if (!$this->collVideolists->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddVideolist($l);
        }

        return $this;
    }

    /**
     * @param	Videolist $videolist The videolist object to add.
     */
    protected function doAddVideolist($videolist)
    {
        $this->collVideolists[]= $videolist;
        $videolist->setsfGuardUser($this);
    }

    /**
     * @param	Videolist $videolist The videolist object to remove.
     */
    public function removeVideolist($videolist)
    {
        if ($this->getVideolists()->contains($videolist)) {
            $this->collVideolists->remove($this->collVideolists->search($videolist));
            if (null === $this->videolistsScheduledForDeletion) {
                $this->videolistsScheduledForDeletion = clone $this->collVideolists;
                $this->videolistsScheduledForDeletion->clear();
            }
            $this->videolistsScheduledForDeletion[]= $videolist;
            $videolist->setsfGuardUser(null);
        }
    }

    /**
     * Clears out the collUserLinks collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addUserLinks()
     */
    public function clearUserLinks()
    {
        $this->collUserLinks = null; // important to set this to null since that means it is uninitialized
        $this->collUserLinksPartial = null;
    }

    /**
     * reset is the collUserLinks collection loaded partially
     *
     * @return void
     */
    public function resetPartialUserLinks($v = true)
    {
        $this->collUserLinksPartial = $v;
    }

    /**
     * Initializes the collUserLinks collection.
     *
     * By default this just sets the collUserLinks collection to an empty array (like clearcollUserLinks());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initUserLinks($overrideExisting = true)
    {
        if (null !== $this->collUserLinks && !$overrideExisting) {
            return;
        }
        $this->collUserLinks = new PropelObjectCollection();
        $this->collUserLinks->setModel('UserLink');
    }

    /**
     * Gets an array of UserLink objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|UserLink[] List of UserLink objects
     * @throws PropelException
     */
    public function getUserLinks($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collUserLinksPartial && !$this->isNew();
        if (null === $this->collUserLinks || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collUserLinks) {
                // return empty collection
                $this->initUserLinks();
            } else {
                $collUserLinks = UserLinkQuery::create(null, $criteria)
                    ->filterBysfGuardUser($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collUserLinksPartial && count($collUserLinks)) {
                      $this->initUserLinks(false);

                      foreach($collUserLinks as $obj) {
                        if (false == $this->collUserLinks->contains($obj)) {
                          $this->collUserLinks->append($obj);
                        }
                      }

                      $this->collUserLinksPartial = true;
                    }

                    return $collUserLinks;
                }

                if($partial && $this->collUserLinks) {
                    foreach($this->collUserLinks as $obj) {
                        if($obj->isNew()) {
                            $collUserLinks[] = $obj;
                        }
                    }
                }

                $this->collUserLinks = $collUserLinks;
                $this->collUserLinksPartial = false;
            }
        }

        return $this->collUserLinks;
    }

    /**
     * Sets a collection of UserLink objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $userLinks A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setUserLinks(PropelCollection $userLinks, PropelPDO $con = null)
    {
        $this->userLinksScheduledForDeletion = $this->getUserLinks(new Criteria(), $con)->diff($userLinks);

        foreach ($this->userLinksScheduledForDeletion as $userLinkRemoved) {
            $userLinkRemoved->setsfGuardUser(null);
        }

        $this->collUserLinks = null;
        foreach ($userLinks as $userLink) {
            $this->addUserLink($userLink);
        }

        $this->collUserLinks = $userLinks;
        $this->collUserLinksPartial = false;
    }

    /**
     * Returns the number of related UserLink objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related UserLink objects.
     * @throws PropelException
     */
    public function countUserLinks(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collUserLinksPartial && !$this->isNew();
        if (null === $this->collUserLinks || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collUserLinks) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getUserLinks());
                }
                $query = UserLinkQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUser($this)
                    ->count($con);
            }
        } else {
            return count($this->collUserLinks);
        }
    }

    /**
     * Method called to associate a UserLink object to this object
     * through the UserLink foreign key attribute.
     *
     * @param    UserLink $l UserLink
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addUserLink(UserLink $l)
    {
        if ($this->collUserLinks === null) {
            $this->initUserLinks();
            $this->collUserLinksPartial = true;
        }
        if (!$this->collUserLinks->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddUserLink($l);
        }

        return $this;
    }

    /**
     * @param	UserLink $userLink The userLink object to add.
     */
    protected function doAddUserLink($userLink)
    {
        $this->collUserLinks[]= $userLink;
        $userLink->setsfGuardUser($this);
    }

    /**
     * @param	UserLink $userLink The userLink object to remove.
     */
    public function removeUserLink($userLink)
    {
        if ($this->getUserLinks()->contains($userLink)) {
            $this->collUserLinks->remove($this->collUserLinks->search($userLink));
            if (null === $this->userLinksScheduledForDeletion) {
                $this->userLinksScheduledForDeletion = clone $this->collUserLinks;
                $this->userLinksScheduledForDeletion->clear();
            }
            $this->userLinksScheduledForDeletion[]= $userLink;
            $userLink->setsfGuardUser(null);
        }
    }

    /**
     * Clears out the collUserLinkComments collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addUserLinkComments()
     */
    public function clearUserLinkComments()
    {
        $this->collUserLinkComments = null; // important to set this to null since that means it is uninitialized
        $this->collUserLinkCommentsPartial = null;
    }

    /**
     * reset is the collUserLinkComments collection loaded partially
     *
     * @return void
     */
    public function resetPartialUserLinkComments($v = true)
    {
        $this->collUserLinkCommentsPartial = $v;
    }

    /**
     * Initializes the collUserLinkComments collection.
     *
     * By default this just sets the collUserLinkComments collection to an empty array (like clearcollUserLinkComments());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initUserLinkComments($overrideExisting = true)
    {
        if (null !== $this->collUserLinkComments && !$overrideExisting) {
            return;
        }
        $this->collUserLinkComments = new PropelObjectCollection();
        $this->collUserLinkComments->setModel('UserLinkComment');
    }

    /**
     * Gets an array of UserLinkComment objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|UserLinkComment[] List of UserLinkComment objects
     * @throws PropelException
     */
    public function getUserLinkComments($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collUserLinkCommentsPartial && !$this->isNew();
        if (null === $this->collUserLinkComments || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collUserLinkComments) {
                // return empty collection
                $this->initUserLinkComments();
            } else {
                $collUserLinkComments = UserLinkCommentQuery::create(null, $criteria)
                    ->filterBysfGuardUser($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collUserLinkCommentsPartial && count($collUserLinkComments)) {
                      $this->initUserLinkComments(false);

                      foreach($collUserLinkComments as $obj) {
                        if (false == $this->collUserLinkComments->contains($obj)) {
                          $this->collUserLinkComments->append($obj);
                        }
                      }

                      $this->collUserLinkCommentsPartial = true;
                    }

                    return $collUserLinkComments;
                }

                if($partial && $this->collUserLinkComments) {
                    foreach($this->collUserLinkComments as $obj) {
                        if($obj->isNew()) {
                            $collUserLinkComments[] = $obj;
                        }
                    }
                }

                $this->collUserLinkComments = $collUserLinkComments;
                $this->collUserLinkCommentsPartial = false;
            }
        }

        return $this->collUserLinkComments;
    }

    /**
     * Sets a collection of UserLinkComment objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $userLinkComments A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setUserLinkComments(PropelCollection $userLinkComments, PropelPDO $con = null)
    {
        $this->userLinkCommentsScheduledForDeletion = $this->getUserLinkComments(new Criteria(), $con)->diff($userLinkComments);

        foreach ($this->userLinkCommentsScheduledForDeletion as $userLinkCommentRemoved) {
            $userLinkCommentRemoved->setsfGuardUser(null);
        }

        $this->collUserLinkComments = null;
        foreach ($userLinkComments as $userLinkComment) {
            $this->addUserLinkComment($userLinkComment);
        }

        $this->collUserLinkComments = $userLinkComments;
        $this->collUserLinkCommentsPartial = false;
    }

    /**
     * Returns the number of related UserLinkComment objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related UserLinkComment objects.
     * @throws PropelException
     */
    public function countUserLinkComments(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collUserLinkCommentsPartial && !$this->isNew();
        if (null === $this->collUserLinkComments || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collUserLinkComments) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getUserLinkComments());
                }
                $query = UserLinkCommentQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUser($this)
                    ->count($con);
            }
        } else {
            return count($this->collUserLinkComments);
        }
    }

    /**
     * Method called to associate a UserLinkComment object to this object
     * through the UserLinkComment foreign key attribute.
     *
     * @param    UserLinkComment $l UserLinkComment
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addUserLinkComment(UserLinkComment $l)
    {
        if ($this->collUserLinkComments === null) {
            $this->initUserLinkComments();
            $this->collUserLinkCommentsPartial = true;
        }
        if (!$this->collUserLinkComments->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddUserLinkComment($l);
        }

        return $this;
    }

    /**
     * @param	UserLinkComment $userLinkComment The userLinkComment object to add.
     */
    protected function doAddUserLinkComment($userLinkComment)
    {
        $this->collUserLinkComments[]= $userLinkComment;
        $userLinkComment->setsfGuardUser($this);
    }

    /**
     * @param	UserLinkComment $userLinkComment The userLinkComment object to remove.
     */
    public function removeUserLinkComment($userLinkComment)
    {
        if ($this->getUserLinkComments()->contains($userLinkComment)) {
            $this->collUserLinkComments->remove($this->collUserLinkComments->search($userLinkComment));
            if (null === $this->userLinkCommentsScheduledForDeletion) {
                $this->userLinkCommentsScheduledForDeletion = clone $this->collUserLinkComments;
                $this->userLinkCommentsScheduledForDeletion->clear();
            }
            $this->userLinkCommentsScheduledForDeletion[]= $userLinkComment;
            $userLinkComment->setsfGuardUser(null);
        }
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this sfGuardUser is new, it will return
     * an empty collection; or if this sfGuardUser has previously
     * been saved, it will retrieve related UserLinkComments from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in sfGuardUser.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @param string $join_behavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return PropelObjectCollection|UserLinkComment[] List of UserLinkComment objects
     */
    public function getUserLinkCommentsJoinUserLink($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
    {
        $query = UserLinkCommentQuery::create(null, $criteria);
        $query->joinWith('UserLink', $join_behavior);

        return $this->getUserLinkComments($query, $con);
    }

    /**
     * Clears out the collsfGuardUserPermissions collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addsfGuardUserPermissions()
     */
    public function clearsfGuardUserPermissions()
    {
        $this->collsfGuardUserPermissions = null; // important to set this to null since that means it is uninitialized
        $this->collsfGuardUserPermissionsPartial = null;
    }

    /**
     * reset is the collsfGuardUserPermissions collection loaded partially
     *
     * @return void
     */
    public function resetPartialsfGuardUserPermissions($v = true)
    {
        $this->collsfGuardUserPermissionsPartial = $v;
    }

    /**
     * Initializes the collsfGuardUserPermissions collection.
     *
     * By default this just sets the collsfGuardUserPermissions collection to an empty array (like clearcollsfGuardUserPermissions());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initsfGuardUserPermissions($overrideExisting = true)
    {
        if (null !== $this->collsfGuardUserPermissions && !$overrideExisting) {
            return;
        }
        $this->collsfGuardUserPermissions = new PropelObjectCollection();
        $this->collsfGuardUserPermissions->setModel('sfGuardUserPermission');
    }

    /**
     * Gets an array of sfGuardUserPermission objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|sfGuardUserPermission[] List of sfGuardUserPermission objects
     * @throws PropelException
     */
    public function getsfGuardUserPermissions($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collsfGuardUserPermissionsPartial && !$this->isNew();
        if (null === $this->collsfGuardUserPermissions || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collsfGuardUserPermissions) {
                // return empty collection
                $this->initsfGuardUserPermissions();
            } else {
                $collsfGuardUserPermissions = sfGuardUserPermissionQuery::create(null, $criteria)
                    ->filterBysfGuardUser($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collsfGuardUserPermissionsPartial && count($collsfGuardUserPermissions)) {
                      $this->initsfGuardUserPermissions(false);

                      foreach($collsfGuardUserPermissions as $obj) {
                        if (false == $this->collsfGuardUserPermissions->contains($obj)) {
                          $this->collsfGuardUserPermissions->append($obj);
                        }
                      }

                      $this->collsfGuardUserPermissionsPartial = true;
                    }

                    return $collsfGuardUserPermissions;
                }

                if($partial && $this->collsfGuardUserPermissions) {
                    foreach($this->collsfGuardUserPermissions as $obj) {
                        if($obj->isNew()) {
                            $collsfGuardUserPermissions[] = $obj;
                        }
                    }
                }

                $this->collsfGuardUserPermissions = $collsfGuardUserPermissions;
                $this->collsfGuardUserPermissionsPartial = false;
            }
        }

        return $this->collsfGuardUserPermissions;
    }

    /**
     * Sets a collection of sfGuardUserPermission objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $sfGuardUserPermissions A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setsfGuardUserPermissions(PropelCollection $sfGuardUserPermissions, PropelPDO $con = null)
    {
        $this->sfGuardUserPermissionsScheduledForDeletion = $this->getsfGuardUserPermissions(new Criteria(), $con)->diff($sfGuardUserPermissions);

        foreach ($this->sfGuardUserPermissionsScheduledForDeletion as $sfGuardUserPermissionRemoved) {
            $sfGuardUserPermissionRemoved->setsfGuardUser(null);
        }

        $this->collsfGuardUserPermissions = null;
        foreach ($sfGuardUserPermissions as $sfGuardUserPermission) {
            $this->addsfGuardUserPermission($sfGuardUserPermission);
        }

        $this->collsfGuardUserPermissions = $sfGuardUserPermissions;
        $this->collsfGuardUserPermissionsPartial = false;
    }

    /**
     * Returns the number of related sfGuardUserPermission objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related sfGuardUserPermission objects.
     * @throws PropelException
     */
    public function countsfGuardUserPermissions(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collsfGuardUserPermissionsPartial && !$this->isNew();
        if (null === $this->collsfGuardUserPermissions || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collsfGuardUserPermissions) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getsfGuardUserPermissions());
                }
                $query = sfGuardUserPermissionQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUser($this)
                    ->count($con);
            }
        } else {
            return count($this->collsfGuardUserPermissions);
        }
    }

    /**
     * Method called to associate a sfGuardUserPermission object to this object
     * through the sfGuardUserPermission foreign key attribute.
     *
     * @param    sfGuardUserPermission $l sfGuardUserPermission
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addsfGuardUserPermission(sfGuardUserPermission $l)
    {
        if ($this->collsfGuardUserPermissions === null) {
            $this->initsfGuardUserPermissions();
            $this->collsfGuardUserPermissionsPartial = true;
        }
        if (!$this->collsfGuardUserPermissions->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddsfGuardUserPermission($l);
        }

        return $this;
    }

    /**
     * @param	sfGuardUserPermission $sfGuardUserPermission The sfGuardUserPermission object to add.
     */
    protected function doAddsfGuardUserPermission($sfGuardUserPermission)
    {
        $this->collsfGuardUserPermissions[]= $sfGuardUserPermission;
        $sfGuardUserPermission->setsfGuardUser($this);
    }

    /**
     * @param	sfGuardUserPermission $sfGuardUserPermission The sfGuardUserPermission object to remove.
     */
    public function removesfGuardUserPermission($sfGuardUserPermission)
    {
        if ($this->getsfGuardUserPermissions()->contains($sfGuardUserPermission)) {
            $this->collsfGuardUserPermissions->remove($this->collsfGuardUserPermissions->search($sfGuardUserPermission));
            if (null === $this->sfGuardUserPermissionsScheduledForDeletion) {
                $this->sfGuardUserPermissionsScheduledForDeletion = clone $this->collsfGuardUserPermissions;
                $this->sfGuardUserPermissionsScheduledForDeletion->clear();
            }
            $this->sfGuardUserPermissionsScheduledForDeletion[]= $sfGuardUserPermission;
            $sfGuardUserPermission->setsfGuardUser(null);
        }
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this sfGuardUser is new, it will return
     * an empty collection; or if this sfGuardUser has previously
     * been saved, it will retrieve related sfGuardUserPermissions from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in sfGuardUser.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @param string $join_behavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return PropelObjectCollection|sfGuardUserPermission[] List of sfGuardUserPermission objects
     */
    public function getsfGuardUserPermissionsJoinsfGuardPermission($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
    {
        $query = sfGuardUserPermissionQuery::create(null, $criteria);
        $query->joinWith('sfGuardPermission', $join_behavior);

        return $this->getsfGuardUserPermissions($query, $con);
    }

    /**
     * Clears out the collsfGuardUserGroups collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addsfGuardUserGroups()
     */
    public function clearsfGuardUserGroups()
    {
        $this->collsfGuardUserGroups = null; // important to set this to null since that means it is uninitialized
        $this->collsfGuardUserGroupsPartial = null;
    }

    /**
     * reset is the collsfGuardUserGroups collection loaded partially
     *
     * @return void
     */
    public function resetPartialsfGuardUserGroups($v = true)
    {
        $this->collsfGuardUserGroupsPartial = $v;
    }

    /**
     * Initializes the collsfGuardUserGroups collection.
     *
     * By default this just sets the collsfGuardUserGroups collection to an empty array (like clearcollsfGuardUserGroups());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initsfGuardUserGroups($overrideExisting = true)
    {
        if (null !== $this->collsfGuardUserGroups && !$overrideExisting) {
            return;
        }
        $this->collsfGuardUserGroups = new PropelObjectCollection();
        $this->collsfGuardUserGroups->setModel('sfGuardUserGroup');
    }

    /**
     * Gets an array of sfGuardUserGroup objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|sfGuardUserGroup[] List of sfGuardUserGroup objects
     * @throws PropelException
     */
    public function getsfGuardUserGroups($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collsfGuardUserGroupsPartial && !$this->isNew();
        if (null === $this->collsfGuardUserGroups || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collsfGuardUserGroups) {
                // return empty collection
                $this->initsfGuardUserGroups();
            } else {
                $collsfGuardUserGroups = sfGuardUserGroupQuery::create(null, $criteria)
                    ->filterBysfGuardUser($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collsfGuardUserGroupsPartial && count($collsfGuardUserGroups)) {
                      $this->initsfGuardUserGroups(false);

                      foreach($collsfGuardUserGroups as $obj) {
                        if (false == $this->collsfGuardUserGroups->contains($obj)) {
                          $this->collsfGuardUserGroups->append($obj);
                        }
                      }

                      $this->collsfGuardUserGroupsPartial = true;
                    }

                    return $collsfGuardUserGroups;
                }

                if($partial && $this->collsfGuardUserGroups) {
                    foreach($this->collsfGuardUserGroups as $obj) {
                        if($obj->isNew()) {
                            $collsfGuardUserGroups[] = $obj;
                        }
                    }
                }

                $this->collsfGuardUserGroups = $collsfGuardUserGroups;
                $this->collsfGuardUserGroupsPartial = false;
            }
        }

        return $this->collsfGuardUserGroups;
    }

    /**
     * Sets a collection of sfGuardUserGroup objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $sfGuardUserGroups A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setsfGuardUserGroups(PropelCollection $sfGuardUserGroups, PropelPDO $con = null)
    {
        $this->sfGuardUserGroupsScheduledForDeletion = $this->getsfGuardUserGroups(new Criteria(), $con)->diff($sfGuardUserGroups);

        foreach ($this->sfGuardUserGroupsScheduledForDeletion as $sfGuardUserGroupRemoved) {
            $sfGuardUserGroupRemoved->setsfGuardUser(null);
        }

        $this->collsfGuardUserGroups = null;
        foreach ($sfGuardUserGroups as $sfGuardUserGroup) {
            $this->addsfGuardUserGroup($sfGuardUserGroup);
        }

        $this->collsfGuardUserGroups = $sfGuardUserGroups;
        $this->collsfGuardUserGroupsPartial = false;
    }

    /**
     * Returns the number of related sfGuardUserGroup objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related sfGuardUserGroup objects.
     * @throws PropelException
     */
    public function countsfGuardUserGroups(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collsfGuardUserGroupsPartial && !$this->isNew();
        if (null === $this->collsfGuardUserGroups || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collsfGuardUserGroups) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getsfGuardUserGroups());
                }
                $query = sfGuardUserGroupQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUser($this)
                    ->count($con);
            }
        } else {
            return count($this->collsfGuardUserGroups);
        }
    }

    /**
     * Method called to associate a sfGuardUserGroup object to this object
     * through the sfGuardUserGroup foreign key attribute.
     *
     * @param    sfGuardUserGroup $l sfGuardUserGroup
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addsfGuardUserGroup(sfGuardUserGroup $l)
    {
        if ($this->collsfGuardUserGroups === null) {
            $this->initsfGuardUserGroups();
            $this->collsfGuardUserGroupsPartial = true;
        }
        if (!$this->collsfGuardUserGroups->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddsfGuardUserGroup($l);
        }

        return $this;
    }

    /**
     * @param	sfGuardUserGroup $sfGuardUserGroup The sfGuardUserGroup object to add.
     */
    protected function doAddsfGuardUserGroup($sfGuardUserGroup)
    {
        $this->collsfGuardUserGroups[]= $sfGuardUserGroup;
        $sfGuardUserGroup->setsfGuardUser($this);
    }

    /**
     * @param	sfGuardUserGroup $sfGuardUserGroup The sfGuardUserGroup object to remove.
     */
    public function removesfGuardUserGroup($sfGuardUserGroup)
    {
        if ($this->getsfGuardUserGroups()->contains($sfGuardUserGroup)) {
            $this->collsfGuardUserGroups->remove($this->collsfGuardUserGroups->search($sfGuardUserGroup));
            if (null === $this->sfGuardUserGroupsScheduledForDeletion) {
                $this->sfGuardUserGroupsScheduledForDeletion = clone $this->collsfGuardUserGroups;
                $this->sfGuardUserGroupsScheduledForDeletion->clear();
            }
            $this->sfGuardUserGroupsScheduledForDeletion[]= $sfGuardUserGroup;
            $sfGuardUserGroup->setsfGuardUser(null);
        }
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this sfGuardUser is new, it will return
     * an empty collection; or if this sfGuardUser has previously
     * been saved, it will retrieve related sfGuardUserGroups from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in sfGuardUser.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @param string $join_behavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return PropelObjectCollection|sfGuardUserGroup[] List of sfGuardUserGroup objects
     */
    public function getsfGuardUserGroupsJoinsfGuardGroup($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
    {
        $query = sfGuardUserGroupQuery::create(null, $criteria);
        $query->joinWith('sfGuardGroup', $join_behavior);

        return $this->getsfGuardUserGroups($query, $con);
    }

    /**
     * Clears out the collsfGuardRememberKeys collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addsfGuardRememberKeys()
     */
    public function clearsfGuardRememberKeys()
    {
        $this->collsfGuardRememberKeys = null; // important to set this to null since that means it is uninitialized
        $this->collsfGuardRememberKeysPartial = null;
    }

    /**
     * reset is the collsfGuardRememberKeys collection loaded partially
     *
     * @return void
     */
    public function resetPartialsfGuardRememberKeys($v = true)
    {
        $this->collsfGuardRememberKeysPartial = $v;
    }

    /**
     * Initializes the collsfGuardRememberKeys collection.
     *
     * By default this just sets the collsfGuardRememberKeys collection to an empty array (like clearcollsfGuardRememberKeys());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initsfGuardRememberKeys($overrideExisting = true)
    {
        if (null !== $this->collsfGuardRememberKeys && !$overrideExisting) {
            return;
        }
        $this->collsfGuardRememberKeys = new PropelObjectCollection();
        $this->collsfGuardRememberKeys->setModel('sfGuardRememberKey');
    }

    /**
     * Gets an array of sfGuardRememberKey objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|sfGuardRememberKey[] List of sfGuardRememberKey objects
     * @throws PropelException
     */
    public function getsfGuardRememberKeys($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collsfGuardRememberKeysPartial && !$this->isNew();
        if (null === $this->collsfGuardRememberKeys || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collsfGuardRememberKeys) {
                // return empty collection
                $this->initsfGuardRememberKeys();
            } else {
                $collsfGuardRememberKeys = sfGuardRememberKeyQuery::create(null, $criteria)
                    ->filterBysfGuardUser($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collsfGuardRememberKeysPartial && count($collsfGuardRememberKeys)) {
                      $this->initsfGuardRememberKeys(false);

                      foreach($collsfGuardRememberKeys as $obj) {
                        if (false == $this->collsfGuardRememberKeys->contains($obj)) {
                          $this->collsfGuardRememberKeys->append($obj);
                        }
                      }

                      $this->collsfGuardRememberKeysPartial = true;
                    }

                    return $collsfGuardRememberKeys;
                }

                if($partial && $this->collsfGuardRememberKeys) {
                    foreach($this->collsfGuardRememberKeys as $obj) {
                        if($obj->isNew()) {
                            $collsfGuardRememberKeys[] = $obj;
                        }
                    }
                }

                $this->collsfGuardRememberKeys = $collsfGuardRememberKeys;
                $this->collsfGuardRememberKeysPartial = false;
            }
        }

        return $this->collsfGuardRememberKeys;
    }

    /**
     * Sets a collection of sfGuardRememberKey objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $sfGuardRememberKeys A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setsfGuardRememberKeys(PropelCollection $sfGuardRememberKeys, PropelPDO $con = null)
    {
        $this->sfGuardRememberKeysScheduledForDeletion = $this->getsfGuardRememberKeys(new Criteria(), $con)->diff($sfGuardRememberKeys);

        foreach ($this->sfGuardRememberKeysScheduledForDeletion as $sfGuardRememberKeyRemoved) {
            $sfGuardRememberKeyRemoved->setsfGuardUser(null);
        }

        $this->collsfGuardRememberKeys = null;
        foreach ($sfGuardRememberKeys as $sfGuardRememberKey) {
            $this->addsfGuardRememberKey($sfGuardRememberKey);
        }

        $this->collsfGuardRememberKeys = $sfGuardRememberKeys;
        $this->collsfGuardRememberKeysPartial = false;
    }

    /**
     * Returns the number of related sfGuardRememberKey objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related sfGuardRememberKey objects.
     * @throws PropelException
     */
    public function countsfGuardRememberKeys(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collsfGuardRememberKeysPartial && !$this->isNew();
        if (null === $this->collsfGuardRememberKeys || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collsfGuardRememberKeys) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getsfGuardRememberKeys());
                }
                $query = sfGuardRememberKeyQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUser($this)
                    ->count($con);
            }
        } else {
            return count($this->collsfGuardRememberKeys);
        }
    }

    /**
     * Method called to associate a sfGuardRememberKey object to this object
     * through the sfGuardRememberKey foreign key attribute.
     *
     * @param    sfGuardRememberKey $l sfGuardRememberKey
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addsfGuardRememberKey(sfGuardRememberKey $l)
    {
        if ($this->collsfGuardRememberKeys === null) {
            $this->initsfGuardRememberKeys();
            $this->collsfGuardRememberKeysPartial = true;
        }
        if (!$this->collsfGuardRememberKeys->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddsfGuardRememberKey($l);
        }

        return $this;
    }

    /**
     * @param	sfGuardRememberKey $sfGuardRememberKey The sfGuardRememberKey object to add.
     */
    protected function doAddsfGuardRememberKey($sfGuardRememberKey)
    {
        $this->collsfGuardRememberKeys[]= $sfGuardRememberKey;
        $sfGuardRememberKey->setsfGuardUser($this);
    }

    /**
     * @param	sfGuardRememberKey $sfGuardRememberKey The sfGuardRememberKey object to remove.
     */
    public function removesfGuardRememberKey($sfGuardRememberKey)
    {
        if ($this->getsfGuardRememberKeys()->contains($sfGuardRememberKey)) {
            $this->collsfGuardRememberKeys->remove($this->collsfGuardRememberKeys->search($sfGuardRememberKey));
            if (null === $this->sfGuardRememberKeysScheduledForDeletion) {
                $this->sfGuardRememberKeysScheduledForDeletion = clone $this->collsfGuardRememberKeys;
                $this->sfGuardRememberKeysScheduledForDeletion->clear();
            }
            $this->sfGuardRememberKeysScheduledForDeletion[]= $sfGuardRememberKey;
            $sfGuardRememberKey->setsfGuardUser(null);
        }
    }

    /**
     * Clears out the collsfGuardUserProfiles collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addsfGuardUserProfiles()
     */
    public function clearsfGuardUserProfiles()
    {
        $this->collsfGuardUserProfiles = null; // important to set this to null since that means it is uninitialized
        $this->collsfGuardUserProfilesPartial = null;
    }

    /**
     * reset is the collsfGuardUserProfiles collection loaded partially
     *
     * @return void
     */
    public function resetPartialsfGuardUserProfiles($v = true)
    {
        $this->collsfGuardUserProfilesPartial = $v;
    }

    /**
     * Initializes the collsfGuardUserProfiles collection.
     *
     * By default this just sets the collsfGuardUserProfiles collection to an empty array (like clearcollsfGuardUserProfiles());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initsfGuardUserProfiles($overrideExisting = true)
    {
        if (null !== $this->collsfGuardUserProfiles && !$overrideExisting) {
            return;
        }
        $this->collsfGuardUserProfiles = new PropelObjectCollection();
        $this->collsfGuardUserProfiles->setModel('sfGuardUserProfile');
    }

    /**
     * Gets an array of sfGuardUserProfile objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|sfGuardUserProfile[] List of sfGuardUserProfile objects
     * @throws PropelException
     */
    public function getsfGuardUserProfiles($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collsfGuardUserProfilesPartial && !$this->isNew();
        if (null === $this->collsfGuardUserProfiles || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collsfGuardUserProfiles) {
                // return empty collection
                $this->initsfGuardUserProfiles();
            } else {
                $collsfGuardUserProfiles = sfGuardUserProfileQuery::create(null, $criteria)
                    ->filterBysfGuardUser($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collsfGuardUserProfilesPartial && count($collsfGuardUserProfiles)) {
                      $this->initsfGuardUserProfiles(false);

                      foreach($collsfGuardUserProfiles as $obj) {
                        if (false == $this->collsfGuardUserProfiles->contains($obj)) {
                          $this->collsfGuardUserProfiles->append($obj);
                        }
                      }

                      $this->collsfGuardUserProfilesPartial = true;
                    }

                    return $collsfGuardUserProfiles;
                }

                if($partial && $this->collsfGuardUserProfiles) {
                    foreach($this->collsfGuardUserProfiles as $obj) {
                        if($obj->isNew()) {
                            $collsfGuardUserProfiles[] = $obj;
                        }
                    }
                }

                $this->collsfGuardUserProfiles = $collsfGuardUserProfiles;
                $this->collsfGuardUserProfilesPartial = false;
            }
        }

        return $this->collsfGuardUserProfiles;
    }

    /**
     * Sets a collection of sfGuardUserProfile objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $sfGuardUserProfiles A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setsfGuardUserProfiles(PropelCollection $sfGuardUserProfiles, PropelPDO $con = null)
    {
        $this->sfGuardUserProfilesScheduledForDeletion = $this->getsfGuardUserProfiles(new Criteria(), $con)->diff($sfGuardUserProfiles);

        foreach ($this->sfGuardUserProfilesScheduledForDeletion as $sfGuardUserProfileRemoved) {
            $sfGuardUserProfileRemoved->setsfGuardUser(null);
        }

        $this->collsfGuardUserProfiles = null;
        foreach ($sfGuardUserProfiles as $sfGuardUserProfile) {
            $this->addsfGuardUserProfile($sfGuardUserProfile);
        }

        $this->collsfGuardUserProfiles = $sfGuardUserProfiles;
        $this->collsfGuardUserProfilesPartial = false;
    }

    /**
     * Returns the number of related sfGuardUserProfile objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related sfGuardUserProfile objects.
     * @throws PropelException
     */
    public function countsfGuardUserProfiles(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collsfGuardUserProfilesPartial && !$this->isNew();
        if (null === $this->collsfGuardUserProfiles || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collsfGuardUserProfiles) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getsfGuardUserProfiles());
                }
                $query = sfGuardUserProfileQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUser($this)
                    ->count($con);
            }
        } else {
            return count($this->collsfGuardUserProfiles);
        }
    }

    /**
     * Method called to associate a sfGuardUserProfile object to this object
     * through the sfGuardUserProfile foreign key attribute.
     *
     * @param    sfGuardUserProfile $l sfGuardUserProfile
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addsfGuardUserProfile(sfGuardUserProfile $l)
    {
        if ($this->collsfGuardUserProfiles === null) {
            $this->initsfGuardUserProfiles();
            $this->collsfGuardUserProfilesPartial = true;
        }
        if (!$this->collsfGuardUserProfiles->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddsfGuardUserProfile($l);
        }

        return $this;
    }

    /**
     * @param	sfGuardUserProfile $sfGuardUserProfile The sfGuardUserProfile object to add.
     */
    protected function doAddsfGuardUserProfile($sfGuardUserProfile)
    {
        $this->collsfGuardUserProfiles[]= $sfGuardUserProfile;
        $sfGuardUserProfile->setsfGuardUser($this);
    }

    /**
     * @param	sfGuardUserProfile $sfGuardUserProfile The sfGuardUserProfile object to remove.
     */
    public function removesfGuardUserProfile($sfGuardUserProfile)
    {
        if ($this->getsfGuardUserProfiles()->contains($sfGuardUserProfile)) {
            $this->collsfGuardUserProfiles->remove($this->collsfGuardUserProfiles->search($sfGuardUserProfile));
            if (null === $this->sfGuardUserProfilesScheduledForDeletion) {
                $this->sfGuardUserProfilesScheduledForDeletion = clone $this->collsfGuardUserProfiles;
                $this->sfGuardUserProfilesScheduledForDeletion->clear();
            }
            $this->sfGuardUserProfilesScheduledForDeletion[]= $sfGuardUserProfile;
            $sfGuardUserProfile->setsfGuardUser(null);
        }
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this sfGuardUser is new, it will return
     * an empty collection; or if this sfGuardUser has previously
     * been saved, it will retrieve related sfGuardUserProfiles from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in sfGuardUser.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @param string $join_behavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return PropelObjectCollection|sfGuardUserProfile[] List of sfGuardUserProfile objects
     */
    public function getsfGuardUserProfilesJoinCountry($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
    {
        $query = sfGuardUserProfileQuery::create(null, $criteria);
        $query->joinWith('Country', $join_behavior);

        return $this->getsfGuardUserProfiles($query, $con);
    }

    /**
     * Clears out the collsfGuardUserStatuss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addsfGuardUserStatuss()
     */
    public function clearsfGuardUserStatuss()
    {
        $this->collsfGuardUserStatuss = null; // important to set this to null since that means it is uninitialized
        $this->collsfGuardUserStatussPartial = null;
    }

    /**
     * reset is the collsfGuardUserStatuss collection loaded partially
     *
     * @return void
     */
    public function resetPartialsfGuardUserStatuss($v = true)
    {
        $this->collsfGuardUserStatussPartial = $v;
    }

    /**
     * Initializes the collsfGuardUserStatuss collection.
     *
     * By default this just sets the collsfGuardUserStatuss collection to an empty array (like clearcollsfGuardUserStatuss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initsfGuardUserStatuss($overrideExisting = true)
    {
        if (null !== $this->collsfGuardUserStatuss && !$overrideExisting) {
            return;
        }
        $this->collsfGuardUserStatuss = new PropelObjectCollection();
        $this->collsfGuardUserStatuss->setModel('sfGuardUserStatus');
    }

    /**
     * Gets an array of sfGuardUserStatus objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|sfGuardUserStatus[] List of sfGuardUserStatus objects
     * @throws PropelException
     */
    public function getsfGuardUserStatuss($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collsfGuardUserStatussPartial && !$this->isNew();
        if (null === $this->collsfGuardUserStatuss || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collsfGuardUserStatuss) {
                // return empty collection
                $this->initsfGuardUserStatuss();
            } else {
                $collsfGuardUserStatuss = sfGuardUserStatusQuery::create(null, $criteria)
                    ->filterBysfGuardUser($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collsfGuardUserStatussPartial && count($collsfGuardUserStatuss)) {
                      $this->initsfGuardUserStatuss(false);

                      foreach($collsfGuardUserStatuss as $obj) {
                        if (false == $this->collsfGuardUserStatuss->contains($obj)) {
                          $this->collsfGuardUserStatuss->append($obj);
                        }
                      }

                      $this->collsfGuardUserStatussPartial = true;
                    }

                    return $collsfGuardUserStatuss;
                }

                if($partial && $this->collsfGuardUserStatuss) {
                    foreach($this->collsfGuardUserStatuss as $obj) {
                        if($obj->isNew()) {
                            $collsfGuardUserStatuss[] = $obj;
                        }
                    }
                }

                $this->collsfGuardUserStatuss = $collsfGuardUserStatuss;
                $this->collsfGuardUserStatussPartial = false;
            }
        }

        return $this->collsfGuardUserStatuss;
    }

    /**
     * Sets a collection of sfGuardUserStatus objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $sfGuardUserStatuss A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setsfGuardUserStatuss(PropelCollection $sfGuardUserStatuss, PropelPDO $con = null)
    {
        $this->sfGuardUserStatussScheduledForDeletion = $this->getsfGuardUserStatuss(new Criteria(), $con)->diff($sfGuardUserStatuss);

        foreach ($this->sfGuardUserStatussScheduledForDeletion as $sfGuardUserStatusRemoved) {
            $sfGuardUserStatusRemoved->setsfGuardUser(null);
        }

        $this->collsfGuardUserStatuss = null;
        foreach ($sfGuardUserStatuss as $sfGuardUserStatus) {
            $this->addsfGuardUserStatus($sfGuardUserStatus);
        }

        $this->collsfGuardUserStatuss = $sfGuardUserStatuss;
        $this->collsfGuardUserStatussPartial = false;
    }

    /**
     * Returns the number of related sfGuardUserStatus objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related sfGuardUserStatus objects.
     * @throws PropelException
     */
    public function countsfGuardUserStatuss(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collsfGuardUserStatussPartial && !$this->isNew();
        if (null === $this->collsfGuardUserStatuss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collsfGuardUserStatuss) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getsfGuardUserStatuss());
                }
                $query = sfGuardUserStatusQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUser($this)
                    ->count($con);
            }
        } else {
            return count($this->collsfGuardUserStatuss);
        }
    }

    /**
     * Method called to associate a sfGuardUserStatus object to this object
     * through the sfGuardUserStatus foreign key attribute.
     *
     * @param    sfGuardUserStatus $l sfGuardUserStatus
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addsfGuardUserStatus(sfGuardUserStatus $l)
    {
        if ($this->collsfGuardUserStatuss === null) {
            $this->initsfGuardUserStatuss();
            $this->collsfGuardUserStatussPartial = true;
        }
        if (!$this->collsfGuardUserStatuss->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddsfGuardUserStatus($l);
        }

        return $this;
    }

    /**
     * @param	sfGuardUserStatus $sfGuardUserStatus The sfGuardUserStatus object to add.
     */
    protected function doAddsfGuardUserStatus($sfGuardUserStatus)
    {
        $this->collsfGuardUserStatuss[]= $sfGuardUserStatus;
        $sfGuardUserStatus->setsfGuardUser($this);
    }

    /**
     * @param	sfGuardUserStatus $sfGuardUserStatus The sfGuardUserStatus object to remove.
     */
    public function removesfGuardUserStatus($sfGuardUserStatus)
    {
        if ($this->getsfGuardUserStatuss()->contains($sfGuardUserStatus)) {
            $this->collsfGuardUserStatuss->remove($this->collsfGuardUserStatuss->search($sfGuardUserStatus));
            if (null === $this->sfGuardUserStatussScheduledForDeletion) {
                $this->sfGuardUserStatussScheduledForDeletion = clone $this->collsfGuardUserStatuss;
                $this->sfGuardUserStatussScheduledForDeletion->clear();
            }
            $this->sfGuardUserStatussScheduledForDeletion[]= $sfGuardUserStatus;
            $sfGuardUserStatus->setsfGuardUser(null);
        }
    }

    /**
     * Clears out the collsfGuardUserStatusComments collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addsfGuardUserStatusComments()
     */
    public function clearsfGuardUserStatusComments()
    {
        $this->collsfGuardUserStatusComments = null; // important to set this to null since that means it is uninitialized
        $this->collsfGuardUserStatusCommentsPartial = null;
    }

    /**
     * reset is the collsfGuardUserStatusComments collection loaded partially
     *
     * @return void
     */
    public function resetPartialsfGuardUserStatusComments($v = true)
    {
        $this->collsfGuardUserStatusCommentsPartial = $v;
    }

    /**
     * Initializes the collsfGuardUserStatusComments collection.
     *
     * By default this just sets the collsfGuardUserStatusComments collection to an empty array (like clearcollsfGuardUserStatusComments());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initsfGuardUserStatusComments($overrideExisting = true)
    {
        if (null !== $this->collsfGuardUserStatusComments && !$overrideExisting) {
            return;
        }
        $this->collsfGuardUserStatusComments = new PropelObjectCollection();
        $this->collsfGuardUserStatusComments->setModel('sfGuardUserStatusComment');
    }

    /**
     * Gets an array of sfGuardUserStatusComment objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|sfGuardUserStatusComment[] List of sfGuardUserStatusComment objects
     * @throws PropelException
     */
    public function getsfGuardUserStatusComments($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collsfGuardUserStatusCommentsPartial && !$this->isNew();
        if (null === $this->collsfGuardUserStatusComments || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collsfGuardUserStatusComments) {
                // return empty collection
                $this->initsfGuardUserStatusComments();
            } else {
                $collsfGuardUserStatusComments = sfGuardUserStatusCommentQuery::create(null, $criteria)
                    ->filterBysfGuardUser($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collsfGuardUserStatusCommentsPartial && count($collsfGuardUserStatusComments)) {
                      $this->initsfGuardUserStatusComments(false);

                      foreach($collsfGuardUserStatusComments as $obj) {
                        if (false == $this->collsfGuardUserStatusComments->contains($obj)) {
                          $this->collsfGuardUserStatusComments->append($obj);
                        }
                      }

                      $this->collsfGuardUserStatusCommentsPartial = true;
                    }

                    return $collsfGuardUserStatusComments;
                }

                if($partial && $this->collsfGuardUserStatusComments) {
                    foreach($this->collsfGuardUserStatusComments as $obj) {
                        if($obj->isNew()) {
                            $collsfGuardUserStatusComments[] = $obj;
                        }
                    }
                }

                $this->collsfGuardUserStatusComments = $collsfGuardUserStatusComments;
                $this->collsfGuardUserStatusCommentsPartial = false;
            }
        }

        return $this->collsfGuardUserStatusComments;
    }

    /**
     * Sets a collection of sfGuardUserStatusComment objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $sfGuardUserStatusComments A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setsfGuardUserStatusComments(PropelCollection $sfGuardUserStatusComments, PropelPDO $con = null)
    {
        $this->sfGuardUserStatusCommentsScheduledForDeletion = $this->getsfGuardUserStatusComments(new Criteria(), $con)->diff($sfGuardUserStatusComments);

        foreach ($this->sfGuardUserStatusCommentsScheduledForDeletion as $sfGuardUserStatusCommentRemoved) {
            $sfGuardUserStatusCommentRemoved->setsfGuardUser(null);
        }

        $this->collsfGuardUserStatusComments = null;
        foreach ($sfGuardUserStatusComments as $sfGuardUserStatusComment) {
            $this->addsfGuardUserStatusComment($sfGuardUserStatusComment);
        }

        $this->collsfGuardUserStatusComments = $sfGuardUserStatusComments;
        $this->collsfGuardUserStatusCommentsPartial = false;
    }

    /**
     * Returns the number of related sfGuardUserStatusComment objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related sfGuardUserStatusComment objects.
     * @throws PropelException
     */
    public function countsfGuardUserStatusComments(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collsfGuardUserStatusCommentsPartial && !$this->isNew();
        if (null === $this->collsfGuardUserStatusComments || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collsfGuardUserStatusComments) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getsfGuardUserStatusComments());
                }
                $query = sfGuardUserStatusCommentQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUser($this)
                    ->count($con);
            }
        } else {
            return count($this->collsfGuardUserStatusComments);
        }
    }

    /**
     * Method called to associate a sfGuardUserStatusComment object to this object
     * through the sfGuardUserStatusComment foreign key attribute.
     *
     * @param    sfGuardUserStatusComment $l sfGuardUserStatusComment
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addsfGuardUserStatusComment(sfGuardUserStatusComment $l)
    {
        if ($this->collsfGuardUserStatusComments === null) {
            $this->initsfGuardUserStatusComments();
            $this->collsfGuardUserStatusCommentsPartial = true;
        }
        if (!$this->collsfGuardUserStatusComments->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddsfGuardUserStatusComment($l);
        }

        return $this;
    }

    /**
     * @param	sfGuardUserStatusComment $sfGuardUserStatusComment The sfGuardUserStatusComment object to add.
     */
    protected function doAddsfGuardUserStatusComment($sfGuardUserStatusComment)
    {
        $this->collsfGuardUserStatusComments[]= $sfGuardUserStatusComment;
        $sfGuardUserStatusComment->setsfGuardUser($this);
    }

    /**
     * @param	sfGuardUserStatusComment $sfGuardUserStatusComment The sfGuardUserStatusComment object to remove.
     */
    public function removesfGuardUserStatusComment($sfGuardUserStatusComment)
    {
        if ($this->getsfGuardUserStatusComments()->contains($sfGuardUserStatusComment)) {
            $this->collsfGuardUserStatusComments->remove($this->collsfGuardUserStatusComments->search($sfGuardUserStatusComment));
            if (null === $this->sfGuardUserStatusCommentsScheduledForDeletion) {
                $this->sfGuardUserStatusCommentsScheduledForDeletion = clone $this->collsfGuardUserStatusComments;
                $this->sfGuardUserStatusCommentsScheduledForDeletion->clear();
            }
            $this->sfGuardUserStatusCommentsScheduledForDeletion[]= $sfGuardUserStatusComment;
            $sfGuardUserStatusComment->setsfGuardUser(null);
        }
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this sfGuardUser is new, it will return
     * an empty collection; or if this sfGuardUser has previously
     * been saved, it will retrieve related sfGuardUserStatusComments from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in sfGuardUser.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @param string $join_behavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return PropelObjectCollection|sfGuardUserStatusComment[] List of sfGuardUserStatusComment objects
     */
    public function getsfGuardUserStatusCommentsJoinsfGuardUserStatus($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
    {
        $query = sfGuardUserStatusCommentQuery::create(null, $criteria);
        $query->joinWith('sfGuardUserStatus', $join_behavior);

        return $this->getsfGuardUserStatusComments($query, $con);
    }

    /**
     * Clears out the collsfSocialEvents collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addsfSocialEvents()
     */
    public function clearsfSocialEvents()
    {
        $this->collsfSocialEvents = null; // important to set this to null since that means it is uninitialized
        $this->collsfSocialEventsPartial = null;
    }

    /**
     * reset is the collsfSocialEvents collection loaded partially
     *
     * @return void
     */
    public function resetPartialsfSocialEvents($v = true)
    {
        $this->collsfSocialEventsPartial = $v;
    }

    /**
     * Initializes the collsfSocialEvents collection.
     *
     * By default this just sets the collsfSocialEvents collection to an empty array (like clearcollsfSocialEvents());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initsfSocialEvents($overrideExisting = true)
    {
        if (null !== $this->collsfSocialEvents && !$overrideExisting) {
            return;
        }
        $this->collsfSocialEvents = new PropelObjectCollection();
        $this->collsfSocialEvents->setModel('sfSocialEvent');
    }

    /**
     * Gets an array of sfSocialEvent objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|sfSocialEvent[] List of sfSocialEvent objects
     * @throws PropelException
     */
    public function getsfSocialEvents($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collsfSocialEventsPartial && !$this->isNew();
        if (null === $this->collsfSocialEvents || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collsfSocialEvents) {
                // return empty collection
                $this->initsfSocialEvents();
            } else {
                $collsfSocialEvents = sfSocialEventQuery::create(null, $criteria)
                    ->filterBysfGuardUser($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collsfSocialEventsPartial && count($collsfSocialEvents)) {
                      $this->initsfSocialEvents(false);

                      foreach($collsfSocialEvents as $obj) {
                        if (false == $this->collsfSocialEvents->contains($obj)) {
                          $this->collsfSocialEvents->append($obj);
                        }
                      }

                      $this->collsfSocialEventsPartial = true;
                    }

                    return $collsfSocialEvents;
                }

                if($partial && $this->collsfSocialEvents) {
                    foreach($this->collsfSocialEvents as $obj) {
                        if($obj->isNew()) {
                            $collsfSocialEvents[] = $obj;
                        }
                    }
                }

                $this->collsfSocialEvents = $collsfSocialEvents;
                $this->collsfSocialEventsPartial = false;
            }
        }

        return $this->collsfSocialEvents;
    }

    /**
     * Sets a collection of sfSocialEvent objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $sfSocialEvents A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setsfSocialEvents(PropelCollection $sfSocialEvents, PropelPDO $con = null)
    {
        $this->sfSocialEventsScheduledForDeletion = $this->getsfSocialEvents(new Criteria(), $con)->diff($sfSocialEvents);

        foreach ($this->sfSocialEventsScheduledForDeletion as $sfSocialEventRemoved) {
            $sfSocialEventRemoved->setsfGuardUser(null);
        }

        $this->collsfSocialEvents = null;
        foreach ($sfSocialEvents as $sfSocialEvent) {
            $this->addsfSocialEvent($sfSocialEvent);
        }

        $this->collsfSocialEvents = $sfSocialEvents;
        $this->collsfSocialEventsPartial = false;
    }

    /**
     * Returns the number of related sfSocialEvent objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related sfSocialEvent objects.
     * @throws PropelException
     */
    public function countsfSocialEvents(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collsfSocialEventsPartial && !$this->isNew();
        if (null === $this->collsfSocialEvents || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collsfSocialEvents) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getsfSocialEvents());
                }
                $query = sfSocialEventQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUser($this)
                    ->count($con);
            }
        } else {
            return count($this->collsfSocialEvents);
        }
    }

    /**
     * Method called to associate a sfSocialEvent object to this object
     * through the sfSocialEvent foreign key attribute.
     *
     * @param    sfSocialEvent $l sfSocialEvent
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addsfSocialEvent(sfSocialEvent $l)
    {
        if ($this->collsfSocialEvents === null) {
            $this->initsfSocialEvents();
            $this->collsfSocialEventsPartial = true;
        }
        if (!$this->collsfSocialEvents->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddsfSocialEvent($l);
        }

        return $this;
    }

    /**
     * @param	sfSocialEvent $sfSocialEvent The sfSocialEvent object to add.
     */
    protected function doAddsfSocialEvent($sfSocialEvent)
    {
        $this->collsfSocialEvents[]= $sfSocialEvent;
        $sfSocialEvent->setsfGuardUser($this);
    }

    /**
     * @param	sfSocialEvent $sfSocialEvent The sfSocialEvent object to remove.
     */
    public function removesfSocialEvent($sfSocialEvent)
    {
        if ($this->getsfSocialEvents()->contains($sfSocialEvent)) {
            $this->collsfSocialEvents->remove($this->collsfSocialEvents->search($sfSocialEvent));
            if (null === $this->sfSocialEventsScheduledForDeletion) {
                $this->sfSocialEventsScheduledForDeletion = clone $this->collsfSocialEvents;
                $this->sfSocialEventsScheduledForDeletion->clear();
            }
            $this->sfSocialEventsScheduledForDeletion[]= $sfSocialEvent;
            $sfSocialEvent->setsfGuardUser(null);
        }
    }

    /**
     * Clears out the collsfSocialEventInvitesRelatedByUserId collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addsfSocialEventInvitesRelatedByUserId()
     */
    public function clearsfSocialEventInvitesRelatedByUserId()
    {
        $this->collsfSocialEventInvitesRelatedByUserId = null; // important to set this to null since that means it is uninitialized
        $this->collsfSocialEventInvitesRelatedByUserIdPartial = null;
    }

    /**
     * reset is the collsfSocialEventInvitesRelatedByUserId collection loaded partially
     *
     * @return void
     */
    public function resetPartialsfSocialEventInvitesRelatedByUserId($v = true)
    {
        $this->collsfSocialEventInvitesRelatedByUserIdPartial = $v;
    }

    /**
     * Initializes the collsfSocialEventInvitesRelatedByUserId collection.
     *
     * By default this just sets the collsfSocialEventInvitesRelatedByUserId collection to an empty array (like clearcollsfSocialEventInvitesRelatedByUserId());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initsfSocialEventInvitesRelatedByUserId($overrideExisting = true)
    {
        if (null !== $this->collsfSocialEventInvitesRelatedByUserId && !$overrideExisting) {
            return;
        }
        $this->collsfSocialEventInvitesRelatedByUserId = new PropelObjectCollection();
        $this->collsfSocialEventInvitesRelatedByUserId->setModel('sfSocialEventInvite');
    }

    /**
     * Gets an array of sfSocialEventInvite objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|sfSocialEventInvite[] List of sfSocialEventInvite objects
     * @throws PropelException
     */
    public function getsfSocialEventInvitesRelatedByUserId($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collsfSocialEventInvitesRelatedByUserIdPartial && !$this->isNew();
        if (null === $this->collsfSocialEventInvitesRelatedByUserId || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collsfSocialEventInvitesRelatedByUserId) {
                // return empty collection
                $this->initsfSocialEventInvitesRelatedByUserId();
            } else {
                $collsfSocialEventInvitesRelatedByUserId = sfSocialEventInviteQuery::create(null, $criteria)
                    ->filterBysfGuardUserRelatedByUserId($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collsfSocialEventInvitesRelatedByUserIdPartial && count($collsfSocialEventInvitesRelatedByUserId)) {
                      $this->initsfSocialEventInvitesRelatedByUserId(false);

                      foreach($collsfSocialEventInvitesRelatedByUserId as $obj) {
                        if (false == $this->collsfSocialEventInvitesRelatedByUserId->contains($obj)) {
                          $this->collsfSocialEventInvitesRelatedByUserId->append($obj);
                        }
                      }

                      $this->collsfSocialEventInvitesRelatedByUserIdPartial = true;
                    }

                    return $collsfSocialEventInvitesRelatedByUserId;
                }

                if($partial && $this->collsfSocialEventInvitesRelatedByUserId) {
                    foreach($this->collsfSocialEventInvitesRelatedByUserId as $obj) {
                        if($obj->isNew()) {
                            $collsfSocialEventInvitesRelatedByUserId[] = $obj;
                        }
                    }
                }

                $this->collsfSocialEventInvitesRelatedByUserId = $collsfSocialEventInvitesRelatedByUserId;
                $this->collsfSocialEventInvitesRelatedByUserIdPartial = false;
            }
        }

        return $this->collsfSocialEventInvitesRelatedByUserId;
    }

    /**
     * Sets a collection of sfSocialEventInviteRelatedByUserId objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $sfSocialEventInvitesRelatedByUserId A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setsfSocialEventInvitesRelatedByUserId(PropelCollection $sfSocialEventInvitesRelatedByUserId, PropelPDO $con = null)
    {
        $this->sfSocialEventInvitesRelatedByUserIdScheduledForDeletion = $this->getsfSocialEventInvitesRelatedByUserId(new Criteria(), $con)->diff($sfSocialEventInvitesRelatedByUserId);

        foreach ($this->sfSocialEventInvitesRelatedByUserIdScheduledForDeletion as $sfSocialEventInviteRelatedByUserIdRemoved) {
            $sfSocialEventInviteRelatedByUserIdRemoved->setsfGuardUserRelatedByUserId(null);
        }

        $this->collsfSocialEventInvitesRelatedByUserId = null;
        foreach ($sfSocialEventInvitesRelatedByUserId as $sfSocialEventInviteRelatedByUserId) {
            $this->addsfSocialEventInviteRelatedByUserId($sfSocialEventInviteRelatedByUserId);
        }

        $this->collsfSocialEventInvitesRelatedByUserId = $sfSocialEventInvitesRelatedByUserId;
        $this->collsfSocialEventInvitesRelatedByUserIdPartial = false;
    }

    /**
     * Returns the number of related sfSocialEventInvite objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related sfSocialEventInvite objects.
     * @throws PropelException
     */
    public function countsfSocialEventInvitesRelatedByUserId(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collsfSocialEventInvitesRelatedByUserIdPartial && !$this->isNew();
        if (null === $this->collsfSocialEventInvitesRelatedByUserId || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collsfSocialEventInvitesRelatedByUserId) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getsfSocialEventInvitesRelatedByUserId());
                }
                $query = sfSocialEventInviteQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUserRelatedByUserId($this)
                    ->count($con);
            }
        } else {
            return count($this->collsfSocialEventInvitesRelatedByUserId);
        }
    }

    /**
     * Method called to associate a sfSocialEventInvite object to this object
     * through the sfSocialEventInvite foreign key attribute.
     *
     * @param    sfSocialEventInvite $l sfSocialEventInvite
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addsfSocialEventInviteRelatedByUserId(sfSocialEventInvite $l)
    {
        if ($this->collsfSocialEventInvitesRelatedByUserId === null) {
            $this->initsfSocialEventInvitesRelatedByUserId();
            $this->collsfSocialEventInvitesRelatedByUserIdPartial = true;
        }
        if (!$this->collsfSocialEventInvitesRelatedByUserId->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddsfSocialEventInviteRelatedByUserId($l);
        }

        return $this;
    }

    /**
     * @param	sfSocialEventInviteRelatedByUserId $sfSocialEventInviteRelatedByUserId The sfSocialEventInviteRelatedByUserId object to add.
     */
    protected function doAddsfSocialEventInviteRelatedByUserId($sfSocialEventInviteRelatedByUserId)
    {
        $this->collsfSocialEventInvitesRelatedByUserId[]= $sfSocialEventInviteRelatedByUserId;
        $sfSocialEventInviteRelatedByUserId->setsfGuardUserRelatedByUserId($this);
    }

    /**
     * @param	sfSocialEventInviteRelatedByUserId $sfSocialEventInviteRelatedByUserId The sfSocialEventInviteRelatedByUserId object to remove.
     */
    public function removesfSocialEventInviteRelatedByUserId($sfSocialEventInviteRelatedByUserId)
    {
        if ($this->getsfSocialEventInvitesRelatedByUserId()->contains($sfSocialEventInviteRelatedByUserId)) {
            $this->collsfSocialEventInvitesRelatedByUserId->remove($this->collsfSocialEventInvitesRelatedByUserId->search($sfSocialEventInviteRelatedByUserId));
            if (null === $this->sfSocialEventInvitesRelatedByUserIdScheduledForDeletion) {
                $this->sfSocialEventInvitesRelatedByUserIdScheduledForDeletion = clone $this->collsfSocialEventInvitesRelatedByUserId;
                $this->sfSocialEventInvitesRelatedByUserIdScheduledForDeletion->clear();
            }
            $this->sfSocialEventInvitesRelatedByUserIdScheduledForDeletion[]= $sfSocialEventInviteRelatedByUserId;
            $sfSocialEventInviteRelatedByUserId->setsfGuardUserRelatedByUserId(null);
        }
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this sfGuardUser is new, it will return
     * an empty collection; or if this sfGuardUser has previously
     * been saved, it will retrieve related sfSocialEventInvitesRelatedByUserId from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in sfGuardUser.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @param string $join_behavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return PropelObjectCollection|sfSocialEventInvite[] List of sfSocialEventInvite objects
     */
    public function getsfSocialEventInvitesRelatedByUserIdJoinsfSocialEvent($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
    {
        $query = sfSocialEventInviteQuery::create(null, $criteria);
        $query->joinWith('sfSocialEvent', $join_behavior);

        return $this->getsfSocialEventInvitesRelatedByUserId($query, $con);
    }

    /**
     * Clears out the collsfSocialEventInvitesRelatedByUserFrom collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addsfSocialEventInvitesRelatedByUserFrom()
     */
    public function clearsfSocialEventInvitesRelatedByUserFrom()
    {
        $this->collsfSocialEventInvitesRelatedByUserFrom = null; // important to set this to null since that means it is uninitialized
        $this->collsfSocialEventInvitesRelatedByUserFromPartial = null;
    }

    /**
     * reset is the collsfSocialEventInvitesRelatedByUserFrom collection loaded partially
     *
     * @return void
     */
    public function resetPartialsfSocialEventInvitesRelatedByUserFrom($v = true)
    {
        $this->collsfSocialEventInvitesRelatedByUserFromPartial = $v;
    }

    /**
     * Initializes the collsfSocialEventInvitesRelatedByUserFrom collection.
     *
     * By default this just sets the collsfSocialEventInvitesRelatedByUserFrom collection to an empty array (like clearcollsfSocialEventInvitesRelatedByUserFrom());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initsfSocialEventInvitesRelatedByUserFrom($overrideExisting = true)
    {
        if (null !== $this->collsfSocialEventInvitesRelatedByUserFrom && !$overrideExisting) {
            return;
        }
        $this->collsfSocialEventInvitesRelatedByUserFrom = new PropelObjectCollection();
        $this->collsfSocialEventInvitesRelatedByUserFrom->setModel('sfSocialEventInvite');
    }

    /**
     * Gets an array of sfSocialEventInvite objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|sfSocialEventInvite[] List of sfSocialEventInvite objects
     * @throws PropelException
     */
    public function getsfSocialEventInvitesRelatedByUserFrom($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collsfSocialEventInvitesRelatedByUserFromPartial && !$this->isNew();
        if (null === $this->collsfSocialEventInvitesRelatedByUserFrom || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collsfSocialEventInvitesRelatedByUserFrom) {
                // return empty collection
                $this->initsfSocialEventInvitesRelatedByUserFrom();
            } else {
                $collsfSocialEventInvitesRelatedByUserFrom = sfSocialEventInviteQuery::create(null, $criteria)
                    ->filterBysfGuardUserRelatedByUserFrom($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collsfSocialEventInvitesRelatedByUserFromPartial && count($collsfSocialEventInvitesRelatedByUserFrom)) {
                      $this->initsfSocialEventInvitesRelatedByUserFrom(false);

                      foreach($collsfSocialEventInvitesRelatedByUserFrom as $obj) {
                        if (false == $this->collsfSocialEventInvitesRelatedByUserFrom->contains($obj)) {
                          $this->collsfSocialEventInvitesRelatedByUserFrom->append($obj);
                        }
                      }

                      $this->collsfSocialEventInvitesRelatedByUserFromPartial = true;
                    }

                    return $collsfSocialEventInvitesRelatedByUserFrom;
                }

                if($partial && $this->collsfSocialEventInvitesRelatedByUserFrom) {
                    foreach($this->collsfSocialEventInvitesRelatedByUserFrom as $obj) {
                        if($obj->isNew()) {
                            $collsfSocialEventInvitesRelatedByUserFrom[] = $obj;
                        }
                    }
                }

                $this->collsfSocialEventInvitesRelatedByUserFrom = $collsfSocialEventInvitesRelatedByUserFrom;
                $this->collsfSocialEventInvitesRelatedByUserFromPartial = false;
            }
        }

        return $this->collsfSocialEventInvitesRelatedByUserFrom;
    }

    /**
     * Sets a collection of sfSocialEventInviteRelatedByUserFrom objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $sfSocialEventInvitesRelatedByUserFrom A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setsfSocialEventInvitesRelatedByUserFrom(PropelCollection $sfSocialEventInvitesRelatedByUserFrom, PropelPDO $con = null)
    {
        $this->sfSocialEventInvitesRelatedByUserFromScheduledForDeletion = $this->getsfSocialEventInvitesRelatedByUserFrom(new Criteria(), $con)->diff($sfSocialEventInvitesRelatedByUserFrom);

        foreach ($this->sfSocialEventInvitesRelatedByUserFromScheduledForDeletion as $sfSocialEventInviteRelatedByUserFromRemoved) {
            $sfSocialEventInviteRelatedByUserFromRemoved->setsfGuardUserRelatedByUserFrom(null);
        }

        $this->collsfSocialEventInvitesRelatedByUserFrom = null;
        foreach ($sfSocialEventInvitesRelatedByUserFrom as $sfSocialEventInviteRelatedByUserFrom) {
            $this->addsfSocialEventInviteRelatedByUserFrom($sfSocialEventInviteRelatedByUserFrom);
        }

        $this->collsfSocialEventInvitesRelatedByUserFrom = $sfSocialEventInvitesRelatedByUserFrom;
        $this->collsfSocialEventInvitesRelatedByUserFromPartial = false;
    }

    /**
     * Returns the number of related sfSocialEventInvite objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related sfSocialEventInvite objects.
     * @throws PropelException
     */
    public function countsfSocialEventInvitesRelatedByUserFrom(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collsfSocialEventInvitesRelatedByUserFromPartial && !$this->isNew();
        if (null === $this->collsfSocialEventInvitesRelatedByUserFrom || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collsfSocialEventInvitesRelatedByUserFrom) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getsfSocialEventInvitesRelatedByUserFrom());
                }
                $query = sfSocialEventInviteQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUserRelatedByUserFrom($this)
                    ->count($con);
            }
        } else {
            return count($this->collsfSocialEventInvitesRelatedByUserFrom);
        }
    }

    /**
     * Method called to associate a sfSocialEventInvite object to this object
     * through the sfSocialEventInvite foreign key attribute.
     *
     * @param    sfSocialEventInvite $l sfSocialEventInvite
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addsfSocialEventInviteRelatedByUserFrom(sfSocialEventInvite $l)
    {
        if ($this->collsfSocialEventInvitesRelatedByUserFrom === null) {
            $this->initsfSocialEventInvitesRelatedByUserFrom();
            $this->collsfSocialEventInvitesRelatedByUserFromPartial = true;
        }
        if (!$this->collsfSocialEventInvitesRelatedByUserFrom->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddsfSocialEventInviteRelatedByUserFrom($l);
        }

        return $this;
    }

    /**
     * @param	sfSocialEventInviteRelatedByUserFrom $sfSocialEventInviteRelatedByUserFrom The sfSocialEventInviteRelatedByUserFrom object to add.
     */
    protected function doAddsfSocialEventInviteRelatedByUserFrom($sfSocialEventInviteRelatedByUserFrom)
    {
        $this->collsfSocialEventInvitesRelatedByUserFrom[]= $sfSocialEventInviteRelatedByUserFrom;
        $sfSocialEventInviteRelatedByUserFrom->setsfGuardUserRelatedByUserFrom($this);
    }

    /**
     * @param	sfSocialEventInviteRelatedByUserFrom $sfSocialEventInviteRelatedByUserFrom The sfSocialEventInviteRelatedByUserFrom object to remove.
     */
    public function removesfSocialEventInviteRelatedByUserFrom($sfSocialEventInviteRelatedByUserFrom)
    {
        if ($this->getsfSocialEventInvitesRelatedByUserFrom()->contains($sfSocialEventInviteRelatedByUserFrom)) {
            $this->collsfSocialEventInvitesRelatedByUserFrom->remove($this->collsfSocialEventInvitesRelatedByUserFrom->search($sfSocialEventInviteRelatedByUserFrom));
            if (null === $this->sfSocialEventInvitesRelatedByUserFromScheduledForDeletion) {
                $this->sfSocialEventInvitesRelatedByUserFromScheduledForDeletion = clone $this->collsfSocialEventInvitesRelatedByUserFrom;
                $this->sfSocialEventInvitesRelatedByUserFromScheduledForDeletion->clear();
            }
            $this->sfSocialEventInvitesRelatedByUserFromScheduledForDeletion[]= $sfSocialEventInviteRelatedByUserFrom;
            $sfSocialEventInviteRelatedByUserFrom->setsfGuardUserRelatedByUserFrom(null);
        }
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this sfGuardUser is new, it will return
     * an empty collection; or if this sfGuardUser has previously
     * been saved, it will retrieve related sfSocialEventInvitesRelatedByUserFrom from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in sfGuardUser.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @param string $join_behavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return PropelObjectCollection|sfSocialEventInvite[] List of sfSocialEventInvite objects
     */
    public function getsfSocialEventInvitesRelatedByUserFromJoinsfSocialEvent($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
    {
        $query = sfSocialEventInviteQuery::create(null, $criteria);
        $query->joinWith('sfSocialEvent', $join_behavior);

        return $this->getsfSocialEventInvitesRelatedByUserFrom($query, $con);
    }

    /**
     * Clears out the collsfSocialEventUsers collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addsfSocialEventUsers()
     */
    public function clearsfSocialEventUsers()
    {
        $this->collsfSocialEventUsers = null; // important to set this to null since that means it is uninitialized
        $this->collsfSocialEventUsersPartial = null;
    }

    /**
     * reset is the collsfSocialEventUsers collection loaded partially
     *
     * @return void
     */
    public function resetPartialsfSocialEventUsers($v = true)
    {
        $this->collsfSocialEventUsersPartial = $v;
    }

    /**
     * Initializes the collsfSocialEventUsers collection.
     *
     * By default this just sets the collsfSocialEventUsers collection to an empty array (like clearcollsfSocialEventUsers());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initsfSocialEventUsers($overrideExisting = true)
    {
        if (null !== $this->collsfSocialEventUsers && !$overrideExisting) {
            return;
        }
        $this->collsfSocialEventUsers = new PropelObjectCollection();
        $this->collsfSocialEventUsers->setModel('sfSocialEventUser');
    }

    /**
     * Gets an array of sfSocialEventUser objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|sfSocialEventUser[] List of sfSocialEventUser objects
     * @throws PropelException
     */
    public function getsfSocialEventUsers($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collsfSocialEventUsersPartial && !$this->isNew();
        if (null === $this->collsfSocialEventUsers || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collsfSocialEventUsers) {
                // return empty collection
                $this->initsfSocialEventUsers();
            } else {
                $collsfSocialEventUsers = sfSocialEventUserQuery::create(null, $criteria)
                    ->filterBysfGuardUser($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collsfSocialEventUsersPartial && count($collsfSocialEventUsers)) {
                      $this->initsfSocialEventUsers(false);

                      foreach($collsfSocialEventUsers as $obj) {
                        if (false == $this->collsfSocialEventUsers->contains($obj)) {
                          $this->collsfSocialEventUsers->append($obj);
                        }
                      }

                      $this->collsfSocialEventUsersPartial = true;
                    }

                    return $collsfSocialEventUsers;
                }

                if($partial && $this->collsfSocialEventUsers) {
                    foreach($this->collsfSocialEventUsers as $obj) {
                        if($obj->isNew()) {
                            $collsfSocialEventUsers[] = $obj;
                        }
                    }
                }

                $this->collsfSocialEventUsers = $collsfSocialEventUsers;
                $this->collsfSocialEventUsersPartial = false;
            }
        }

        return $this->collsfSocialEventUsers;
    }

    /**
     * Sets a collection of sfSocialEventUser objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $sfSocialEventUsers A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setsfSocialEventUsers(PropelCollection $sfSocialEventUsers, PropelPDO $con = null)
    {
        $this->sfSocialEventUsersScheduledForDeletion = $this->getsfSocialEventUsers(new Criteria(), $con)->diff($sfSocialEventUsers);

        foreach ($this->sfSocialEventUsersScheduledForDeletion as $sfSocialEventUserRemoved) {
            $sfSocialEventUserRemoved->setsfGuardUser(null);
        }

        $this->collsfSocialEventUsers = null;
        foreach ($sfSocialEventUsers as $sfSocialEventUser) {
            $this->addsfSocialEventUser($sfSocialEventUser);
        }

        $this->collsfSocialEventUsers = $sfSocialEventUsers;
        $this->collsfSocialEventUsersPartial = false;
    }

    /**
     * Returns the number of related sfSocialEventUser objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related sfSocialEventUser objects.
     * @throws PropelException
     */
    public function countsfSocialEventUsers(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collsfSocialEventUsersPartial && !$this->isNew();
        if (null === $this->collsfSocialEventUsers || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collsfSocialEventUsers) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getsfSocialEventUsers());
                }
                $query = sfSocialEventUserQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUser($this)
                    ->count($con);
            }
        } else {
            return count($this->collsfSocialEventUsers);
        }
    }

    /**
     * Method called to associate a sfSocialEventUser object to this object
     * through the sfSocialEventUser foreign key attribute.
     *
     * @param    sfSocialEventUser $l sfSocialEventUser
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addsfSocialEventUser(sfSocialEventUser $l)
    {
        if ($this->collsfSocialEventUsers === null) {
            $this->initsfSocialEventUsers();
            $this->collsfSocialEventUsersPartial = true;
        }
        if (!$this->collsfSocialEventUsers->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddsfSocialEventUser($l);
        }

        return $this;
    }

    /**
     * @param	sfSocialEventUser $sfSocialEventUser The sfSocialEventUser object to add.
     */
    protected function doAddsfSocialEventUser($sfSocialEventUser)
    {
        $this->collsfSocialEventUsers[]= $sfSocialEventUser;
        $sfSocialEventUser->setsfGuardUser($this);
    }

    /**
     * @param	sfSocialEventUser $sfSocialEventUser The sfSocialEventUser object to remove.
     */
    public function removesfSocialEventUser($sfSocialEventUser)
    {
        if ($this->getsfSocialEventUsers()->contains($sfSocialEventUser)) {
            $this->collsfSocialEventUsers->remove($this->collsfSocialEventUsers->search($sfSocialEventUser));
            if (null === $this->sfSocialEventUsersScheduledForDeletion) {
                $this->sfSocialEventUsersScheduledForDeletion = clone $this->collsfSocialEventUsers;
                $this->sfSocialEventUsersScheduledForDeletion->clear();
            }
            $this->sfSocialEventUsersScheduledForDeletion[]= $sfSocialEventUser;
            $sfSocialEventUser->setsfGuardUser(null);
        }
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this sfGuardUser is new, it will return
     * an empty collection; or if this sfGuardUser has previously
     * been saved, it will retrieve related sfSocialEventUsers from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in sfGuardUser.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @param string $join_behavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return PropelObjectCollection|sfSocialEventUser[] List of sfSocialEventUser objects
     */
    public function getsfSocialEventUsersJoinsfSocialEvent($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
    {
        $query = sfSocialEventUserQuery::create(null, $criteria);
        $query->joinWith('sfSocialEvent', $join_behavior);

        return $this->getsfSocialEventUsers($query, $con);
    }

    /**
     * Clears out the collsfSocialGroups collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addsfSocialGroups()
     */
    public function clearsfSocialGroups()
    {
        $this->collsfSocialGroups = null; // important to set this to null since that means it is uninitialized
        $this->collsfSocialGroupsPartial = null;
    }

    /**
     * reset is the collsfSocialGroups collection loaded partially
     *
     * @return void
     */
    public function resetPartialsfSocialGroups($v = true)
    {
        $this->collsfSocialGroupsPartial = $v;
    }

    /**
     * Initializes the collsfSocialGroups collection.
     *
     * By default this just sets the collsfSocialGroups collection to an empty array (like clearcollsfSocialGroups());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initsfSocialGroups($overrideExisting = true)
    {
        if (null !== $this->collsfSocialGroups && !$overrideExisting) {
            return;
        }
        $this->collsfSocialGroups = new PropelObjectCollection();
        $this->collsfSocialGroups->setModel('sfSocialGroup');
    }

    /**
     * Gets an array of sfSocialGroup objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|sfSocialGroup[] List of sfSocialGroup objects
     * @throws PropelException
     */
    public function getsfSocialGroups($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collsfSocialGroupsPartial && !$this->isNew();
        if (null === $this->collsfSocialGroups || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collsfSocialGroups) {
                // return empty collection
                $this->initsfSocialGroups();
            } else {
                $collsfSocialGroups = sfSocialGroupQuery::create(null, $criteria)
                    ->filterBysfGuardUser($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collsfSocialGroupsPartial && count($collsfSocialGroups)) {
                      $this->initsfSocialGroups(false);

                      foreach($collsfSocialGroups as $obj) {
                        if (false == $this->collsfSocialGroups->contains($obj)) {
                          $this->collsfSocialGroups->append($obj);
                        }
                      }

                      $this->collsfSocialGroupsPartial = true;
                    }

                    return $collsfSocialGroups;
                }

                if($partial && $this->collsfSocialGroups) {
                    foreach($this->collsfSocialGroups as $obj) {
                        if($obj->isNew()) {
                            $collsfSocialGroups[] = $obj;
                        }
                    }
                }

                $this->collsfSocialGroups = $collsfSocialGroups;
                $this->collsfSocialGroupsPartial = false;
            }
        }

        return $this->collsfSocialGroups;
    }

    /**
     * Sets a collection of sfSocialGroup objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $sfSocialGroups A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setsfSocialGroups(PropelCollection $sfSocialGroups, PropelPDO $con = null)
    {
        $this->sfSocialGroupsScheduledForDeletion = $this->getsfSocialGroups(new Criteria(), $con)->diff($sfSocialGroups);

        foreach ($this->sfSocialGroupsScheduledForDeletion as $sfSocialGroupRemoved) {
            $sfSocialGroupRemoved->setsfGuardUser(null);
        }

        $this->collsfSocialGroups = null;
        foreach ($sfSocialGroups as $sfSocialGroup) {
            $this->addsfSocialGroup($sfSocialGroup);
        }

        $this->collsfSocialGroups = $sfSocialGroups;
        $this->collsfSocialGroupsPartial = false;
    }

    /**
     * Returns the number of related sfSocialGroup objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related sfSocialGroup objects.
     * @throws PropelException
     */
    public function countsfSocialGroups(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collsfSocialGroupsPartial && !$this->isNew();
        if (null === $this->collsfSocialGroups || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collsfSocialGroups) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getsfSocialGroups());
                }
                $query = sfSocialGroupQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUser($this)
                    ->count($con);
            }
        } else {
            return count($this->collsfSocialGroups);
        }
    }

    /**
     * Method called to associate a sfSocialGroup object to this object
     * through the sfSocialGroup foreign key attribute.
     *
     * @param    sfSocialGroup $l sfSocialGroup
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addsfSocialGroup(sfSocialGroup $l)
    {
        if ($this->collsfSocialGroups === null) {
            $this->initsfSocialGroups();
            $this->collsfSocialGroupsPartial = true;
        }
        if (!$this->collsfSocialGroups->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddsfSocialGroup($l);
        }

        return $this;
    }

    /**
     * @param	sfSocialGroup $sfSocialGroup The sfSocialGroup object to add.
     */
    protected function doAddsfSocialGroup($sfSocialGroup)
    {
        $this->collsfSocialGroups[]= $sfSocialGroup;
        $sfSocialGroup->setsfGuardUser($this);
    }

    /**
     * @param	sfSocialGroup $sfSocialGroup The sfSocialGroup object to remove.
     */
    public function removesfSocialGroup($sfSocialGroup)
    {
        if ($this->getsfSocialGroups()->contains($sfSocialGroup)) {
            $this->collsfSocialGroups->remove($this->collsfSocialGroups->search($sfSocialGroup));
            if (null === $this->sfSocialGroupsScheduledForDeletion) {
                $this->sfSocialGroupsScheduledForDeletion = clone $this->collsfSocialGroups;
                $this->sfSocialGroupsScheduledForDeletion->clear();
            }
            $this->sfSocialGroupsScheduledForDeletion[]= $sfSocialGroup;
            $sfSocialGroup->setsfGuardUser(null);
        }
    }

    /**
     * Clears out the collsfSocialGroupInvitesRelatedByUserId collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addsfSocialGroupInvitesRelatedByUserId()
     */
    public function clearsfSocialGroupInvitesRelatedByUserId()
    {
        $this->collsfSocialGroupInvitesRelatedByUserId = null; // important to set this to null since that means it is uninitialized
        $this->collsfSocialGroupInvitesRelatedByUserIdPartial = null;
    }

    /**
     * reset is the collsfSocialGroupInvitesRelatedByUserId collection loaded partially
     *
     * @return void
     */
    public function resetPartialsfSocialGroupInvitesRelatedByUserId($v = true)
    {
        $this->collsfSocialGroupInvitesRelatedByUserIdPartial = $v;
    }

    /**
     * Initializes the collsfSocialGroupInvitesRelatedByUserId collection.
     *
     * By default this just sets the collsfSocialGroupInvitesRelatedByUserId collection to an empty array (like clearcollsfSocialGroupInvitesRelatedByUserId());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initsfSocialGroupInvitesRelatedByUserId($overrideExisting = true)
    {
        if (null !== $this->collsfSocialGroupInvitesRelatedByUserId && !$overrideExisting) {
            return;
        }
        $this->collsfSocialGroupInvitesRelatedByUserId = new PropelObjectCollection();
        $this->collsfSocialGroupInvitesRelatedByUserId->setModel('sfSocialGroupInvite');
    }

    /**
     * Gets an array of sfSocialGroupInvite objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|sfSocialGroupInvite[] List of sfSocialGroupInvite objects
     * @throws PropelException
     */
    public function getsfSocialGroupInvitesRelatedByUserId($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collsfSocialGroupInvitesRelatedByUserIdPartial && !$this->isNew();
        if (null === $this->collsfSocialGroupInvitesRelatedByUserId || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collsfSocialGroupInvitesRelatedByUserId) {
                // return empty collection
                $this->initsfSocialGroupInvitesRelatedByUserId();
            } else {
                $collsfSocialGroupInvitesRelatedByUserId = sfSocialGroupInviteQuery::create(null, $criteria)
                    ->filterBysfGuardUserRelatedByUserId($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collsfSocialGroupInvitesRelatedByUserIdPartial && count($collsfSocialGroupInvitesRelatedByUserId)) {
                      $this->initsfSocialGroupInvitesRelatedByUserId(false);

                      foreach($collsfSocialGroupInvitesRelatedByUserId as $obj) {
                        if (false == $this->collsfSocialGroupInvitesRelatedByUserId->contains($obj)) {
                          $this->collsfSocialGroupInvitesRelatedByUserId->append($obj);
                        }
                      }

                      $this->collsfSocialGroupInvitesRelatedByUserIdPartial = true;
                    }

                    return $collsfSocialGroupInvitesRelatedByUserId;
                }

                if($partial && $this->collsfSocialGroupInvitesRelatedByUserId) {
                    foreach($this->collsfSocialGroupInvitesRelatedByUserId as $obj) {
                        if($obj->isNew()) {
                            $collsfSocialGroupInvitesRelatedByUserId[] = $obj;
                        }
                    }
                }

                $this->collsfSocialGroupInvitesRelatedByUserId = $collsfSocialGroupInvitesRelatedByUserId;
                $this->collsfSocialGroupInvitesRelatedByUserIdPartial = false;
            }
        }

        return $this->collsfSocialGroupInvitesRelatedByUserId;
    }

    /**
     * Sets a collection of sfSocialGroupInviteRelatedByUserId objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $sfSocialGroupInvitesRelatedByUserId A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setsfSocialGroupInvitesRelatedByUserId(PropelCollection $sfSocialGroupInvitesRelatedByUserId, PropelPDO $con = null)
    {
        $this->sfSocialGroupInvitesRelatedByUserIdScheduledForDeletion = $this->getsfSocialGroupInvitesRelatedByUserId(new Criteria(), $con)->diff($sfSocialGroupInvitesRelatedByUserId);

        foreach ($this->sfSocialGroupInvitesRelatedByUserIdScheduledForDeletion as $sfSocialGroupInviteRelatedByUserIdRemoved) {
            $sfSocialGroupInviteRelatedByUserIdRemoved->setsfGuardUserRelatedByUserId(null);
        }

        $this->collsfSocialGroupInvitesRelatedByUserId = null;
        foreach ($sfSocialGroupInvitesRelatedByUserId as $sfSocialGroupInviteRelatedByUserId) {
            $this->addsfSocialGroupInviteRelatedByUserId($sfSocialGroupInviteRelatedByUserId);
        }

        $this->collsfSocialGroupInvitesRelatedByUserId = $sfSocialGroupInvitesRelatedByUserId;
        $this->collsfSocialGroupInvitesRelatedByUserIdPartial = false;
    }

    /**
     * Returns the number of related sfSocialGroupInvite objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related sfSocialGroupInvite objects.
     * @throws PropelException
     */
    public function countsfSocialGroupInvitesRelatedByUserId(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collsfSocialGroupInvitesRelatedByUserIdPartial && !$this->isNew();
        if (null === $this->collsfSocialGroupInvitesRelatedByUserId || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collsfSocialGroupInvitesRelatedByUserId) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getsfSocialGroupInvitesRelatedByUserId());
                }
                $query = sfSocialGroupInviteQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUserRelatedByUserId($this)
                    ->count($con);
            }
        } else {
            return count($this->collsfSocialGroupInvitesRelatedByUserId);
        }
    }

    /**
     * Method called to associate a sfSocialGroupInvite object to this object
     * through the sfSocialGroupInvite foreign key attribute.
     *
     * @param    sfSocialGroupInvite $l sfSocialGroupInvite
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addsfSocialGroupInviteRelatedByUserId(sfSocialGroupInvite $l)
    {
        if ($this->collsfSocialGroupInvitesRelatedByUserId === null) {
            $this->initsfSocialGroupInvitesRelatedByUserId();
            $this->collsfSocialGroupInvitesRelatedByUserIdPartial = true;
        }
        if (!$this->collsfSocialGroupInvitesRelatedByUserId->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddsfSocialGroupInviteRelatedByUserId($l);
        }

        return $this;
    }

    /**
     * @param	sfSocialGroupInviteRelatedByUserId $sfSocialGroupInviteRelatedByUserId The sfSocialGroupInviteRelatedByUserId object to add.
     */
    protected function doAddsfSocialGroupInviteRelatedByUserId($sfSocialGroupInviteRelatedByUserId)
    {
        $this->collsfSocialGroupInvitesRelatedByUserId[]= $sfSocialGroupInviteRelatedByUserId;
        $sfSocialGroupInviteRelatedByUserId->setsfGuardUserRelatedByUserId($this);
    }

    /**
     * @param	sfSocialGroupInviteRelatedByUserId $sfSocialGroupInviteRelatedByUserId The sfSocialGroupInviteRelatedByUserId object to remove.
     */
    public function removesfSocialGroupInviteRelatedByUserId($sfSocialGroupInviteRelatedByUserId)
    {
        if ($this->getsfSocialGroupInvitesRelatedByUserId()->contains($sfSocialGroupInviteRelatedByUserId)) {
            $this->collsfSocialGroupInvitesRelatedByUserId->remove($this->collsfSocialGroupInvitesRelatedByUserId->search($sfSocialGroupInviteRelatedByUserId));
            if (null === $this->sfSocialGroupInvitesRelatedByUserIdScheduledForDeletion) {
                $this->sfSocialGroupInvitesRelatedByUserIdScheduledForDeletion = clone $this->collsfSocialGroupInvitesRelatedByUserId;
                $this->sfSocialGroupInvitesRelatedByUserIdScheduledForDeletion->clear();
            }
            $this->sfSocialGroupInvitesRelatedByUserIdScheduledForDeletion[]= $sfSocialGroupInviteRelatedByUserId;
            $sfSocialGroupInviteRelatedByUserId->setsfGuardUserRelatedByUserId(null);
        }
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this sfGuardUser is new, it will return
     * an empty collection; or if this sfGuardUser has previously
     * been saved, it will retrieve related sfSocialGroupInvitesRelatedByUserId from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in sfGuardUser.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @param string $join_behavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return PropelObjectCollection|sfSocialGroupInvite[] List of sfSocialGroupInvite objects
     */
    public function getsfSocialGroupInvitesRelatedByUserIdJoinsfSocialGroup($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
    {
        $query = sfSocialGroupInviteQuery::create(null, $criteria);
        $query->joinWith('sfSocialGroup', $join_behavior);

        return $this->getsfSocialGroupInvitesRelatedByUserId($query, $con);
    }

    /**
     * Clears out the collsfSocialGroupInvitesRelatedByUserFrom collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addsfSocialGroupInvitesRelatedByUserFrom()
     */
    public function clearsfSocialGroupInvitesRelatedByUserFrom()
    {
        $this->collsfSocialGroupInvitesRelatedByUserFrom = null; // important to set this to null since that means it is uninitialized
        $this->collsfSocialGroupInvitesRelatedByUserFromPartial = null;
    }

    /**
     * reset is the collsfSocialGroupInvitesRelatedByUserFrom collection loaded partially
     *
     * @return void
     */
    public function resetPartialsfSocialGroupInvitesRelatedByUserFrom($v = true)
    {
        $this->collsfSocialGroupInvitesRelatedByUserFromPartial = $v;
    }

    /**
     * Initializes the collsfSocialGroupInvitesRelatedByUserFrom collection.
     *
     * By default this just sets the collsfSocialGroupInvitesRelatedByUserFrom collection to an empty array (like clearcollsfSocialGroupInvitesRelatedByUserFrom());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initsfSocialGroupInvitesRelatedByUserFrom($overrideExisting = true)
    {
        if (null !== $this->collsfSocialGroupInvitesRelatedByUserFrom && !$overrideExisting) {
            return;
        }
        $this->collsfSocialGroupInvitesRelatedByUserFrom = new PropelObjectCollection();
        $this->collsfSocialGroupInvitesRelatedByUserFrom->setModel('sfSocialGroupInvite');
    }

    /**
     * Gets an array of sfSocialGroupInvite objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|sfSocialGroupInvite[] List of sfSocialGroupInvite objects
     * @throws PropelException
     */
    public function getsfSocialGroupInvitesRelatedByUserFrom($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collsfSocialGroupInvitesRelatedByUserFromPartial && !$this->isNew();
        if (null === $this->collsfSocialGroupInvitesRelatedByUserFrom || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collsfSocialGroupInvitesRelatedByUserFrom) {
                // return empty collection
                $this->initsfSocialGroupInvitesRelatedByUserFrom();
            } else {
                $collsfSocialGroupInvitesRelatedByUserFrom = sfSocialGroupInviteQuery::create(null, $criteria)
                    ->filterBysfGuardUserRelatedByUserFrom($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collsfSocialGroupInvitesRelatedByUserFromPartial && count($collsfSocialGroupInvitesRelatedByUserFrom)) {
                      $this->initsfSocialGroupInvitesRelatedByUserFrom(false);

                      foreach($collsfSocialGroupInvitesRelatedByUserFrom as $obj) {
                        if (false == $this->collsfSocialGroupInvitesRelatedByUserFrom->contains($obj)) {
                          $this->collsfSocialGroupInvitesRelatedByUserFrom->append($obj);
                        }
                      }

                      $this->collsfSocialGroupInvitesRelatedByUserFromPartial = true;
                    }

                    return $collsfSocialGroupInvitesRelatedByUserFrom;
                }

                if($partial && $this->collsfSocialGroupInvitesRelatedByUserFrom) {
                    foreach($this->collsfSocialGroupInvitesRelatedByUserFrom as $obj) {
                        if($obj->isNew()) {
                            $collsfSocialGroupInvitesRelatedByUserFrom[] = $obj;
                        }
                    }
                }

                $this->collsfSocialGroupInvitesRelatedByUserFrom = $collsfSocialGroupInvitesRelatedByUserFrom;
                $this->collsfSocialGroupInvitesRelatedByUserFromPartial = false;
            }
        }

        return $this->collsfSocialGroupInvitesRelatedByUserFrom;
    }

    /**
     * Sets a collection of sfSocialGroupInviteRelatedByUserFrom objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $sfSocialGroupInvitesRelatedByUserFrom A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setsfSocialGroupInvitesRelatedByUserFrom(PropelCollection $sfSocialGroupInvitesRelatedByUserFrom, PropelPDO $con = null)
    {
        $this->sfSocialGroupInvitesRelatedByUserFromScheduledForDeletion = $this->getsfSocialGroupInvitesRelatedByUserFrom(new Criteria(), $con)->diff($sfSocialGroupInvitesRelatedByUserFrom);

        foreach ($this->sfSocialGroupInvitesRelatedByUserFromScheduledForDeletion as $sfSocialGroupInviteRelatedByUserFromRemoved) {
            $sfSocialGroupInviteRelatedByUserFromRemoved->setsfGuardUserRelatedByUserFrom(null);
        }

        $this->collsfSocialGroupInvitesRelatedByUserFrom = null;
        foreach ($sfSocialGroupInvitesRelatedByUserFrom as $sfSocialGroupInviteRelatedByUserFrom) {
            $this->addsfSocialGroupInviteRelatedByUserFrom($sfSocialGroupInviteRelatedByUserFrom);
        }

        $this->collsfSocialGroupInvitesRelatedByUserFrom = $sfSocialGroupInvitesRelatedByUserFrom;
        $this->collsfSocialGroupInvitesRelatedByUserFromPartial = false;
    }

    /**
     * Returns the number of related sfSocialGroupInvite objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related sfSocialGroupInvite objects.
     * @throws PropelException
     */
    public function countsfSocialGroupInvitesRelatedByUserFrom(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collsfSocialGroupInvitesRelatedByUserFromPartial && !$this->isNew();
        if (null === $this->collsfSocialGroupInvitesRelatedByUserFrom || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collsfSocialGroupInvitesRelatedByUserFrom) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getsfSocialGroupInvitesRelatedByUserFrom());
                }
                $query = sfSocialGroupInviteQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUserRelatedByUserFrom($this)
                    ->count($con);
            }
        } else {
            return count($this->collsfSocialGroupInvitesRelatedByUserFrom);
        }
    }

    /**
     * Method called to associate a sfSocialGroupInvite object to this object
     * through the sfSocialGroupInvite foreign key attribute.
     *
     * @param    sfSocialGroupInvite $l sfSocialGroupInvite
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addsfSocialGroupInviteRelatedByUserFrom(sfSocialGroupInvite $l)
    {
        if ($this->collsfSocialGroupInvitesRelatedByUserFrom === null) {
            $this->initsfSocialGroupInvitesRelatedByUserFrom();
            $this->collsfSocialGroupInvitesRelatedByUserFromPartial = true;
        }
        if (!$this->collsfSocialGroupInvitesRelatedByUserFrom->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddsfSocialGroupInviteRelatedByUserFrom($l);
        }

        return $this;
    }

    /**
     * @param	sfSocialGroupInviteRelatedByUserFrom $sfSocialGroupInviteRelatedByUserFrom The sfSocialGroupInviteRelatedByUserFrom object to add.
     */
    protected function doAddsfSocialGroupInviteRelatedByUserFrom($sfSocialGroupInviteRelatedByUserFrom)
    {
        $this->collsfSocialGroupInvitesRelatedByUserFrom[]= $sfSocialGroupInviteRelatedByUserFrom;
        $sfSocialGroupInviteRelatedByUserFrom->setsfGuardUserRelatedByUserFrom($this);
    }

    /**
     * @param	sfSocialGroupInviteRelatedByUserFrom $sfSocialGroupInviteRelatedByUserFrom The sfSocialGroupInviteRelatedByUserFrom object to remove.
     */
    public function removesfSocialGroupInviteRelatedByUserFrom($sfSocialGroupInviteRelatedByUserFrom)
    {
        if ($this->getsfSocialGroupInvitesRelatedByUserFrom()->contains($sfSocialGroupInviteRelatedByUserFrom)) {
            $this->collsfSocialGroupInvitesRelatedByUserFrom->remove($this->collsfSocialGroupInvitesRelatedByUserFrom->search($sfSocialGroupInviteRelatedByUserFrom));
            if (null === $this->sfSocialGroupInvitesRelatedByUserFromScheduledForDeletion) {
                $this->sfSocialGroupInvitesRelatedByUserFromScheduledForDeletion = clone $this->collsfSocialGroupInvitesRelatedByUserFrom;
                $this->sfSocialGroupInvitesRelatedByUserFromScheduledForDeletion->clear();
            }
            $this->sfSocialGroupInvitesRelatedByUserFromScheduledForDeletion[]= $sfSocialGroupInviteRelatedByUserFrom;
            $sfSocialGroupInviteRelatedByUserFrom->setsfGuardUserRelatedByUserFrom(null);
        }
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this sfGuardUser is new, it will return
     * an empty collection; or if this sfGuardUser has previously
     * been saved, it will retrieve related sfSocialGroupInvitesRelatedByUserFrom from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in sfGuardUser.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @param string $join_behavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return PropelObjectCollection|sfSocialGroupInvite[] List of sfSocialGroupInvite objects
     */
    public function getsfSocialGroupInvitesRelatedByUserFromJoinsfSocialGroup($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
    {
        $query = sfSocialGroupInviteQuery::create(null, $criteria);
        $query->joinWith('sfSocialGroup', $join_behavior);

        return $this->getsfSocialGroupInvitesRelatedByUserFrom($query, $con);
    }

    /**
     * Clears out the collsfSocialGroupUsers collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addsfSocialGroupUsers()
     */
    public function clearsfSocialGroupUsers()
    {
        $this->collsfSocialGroupUsers = null; // important to set this to null since that means it is uninitialized
        $this->collsfSocialGroupUsersPartial = null;
    }

    /**
     * reset is the collsfSocialGroupUsers collection loaded partially
     *
     * @return void
     */
    public function resetPartialsfSocialGroupUsers($v = true)
    {
        $this->collsfSocialGroupUsersPartial = $v;
    }

    /**
     * Initializes the collsfSocialGroupUsers collection.
     *
     * By default this just sets the collsfSocialGroupUsers collection to an empty array (like clearcollsfSocialGroupUsers());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initsfSocialGroupUsers($overrideExisting = true)
    {
        if (null !== $this->collsfSocialGroupUsers && !$overrideExisting) {
            return;
        }
        $this->collsfSocialGroupUsers = new PropelObjectCollection();
        $this->collsfSocialGroupUsers->setModel('sfSocialGroupUser');
    }

    /**
     * Gets an array of sfSocialGroupUser objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|sfSocialGroupUser[] List of sfSocialGroupUser objects
     * @throws PropelException
     */
    public function getsfSocialGroupUsers($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collsfSocialGroupUsersPartial && !$this->isNew();
        if (null === $this->collsfSocialGroupUsers || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collsfSocialGroupUsers) {
                // return empty collection
                $this->initsfSocialGroupUsers();
            } else {
                $collsfSocialGroupUsers = sfSocialGroupUserQuery::create(null, $criteria)
                    ->filterBysfGuardUser($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collsfSocialGroupUsersPartial && count($collsfSocialGroupUsers)) {
                      $this->initsfSocialGroupUsers(false);

                      foreach($collsfSocialGroupUsers as $obj) {
                        if (false == $this->collsfSocialGroupUsers->contains($obj)) {
                          $this->collsfSocialGroupUsers->append($obj);
                        }
                      }

                      $this->collsfSocialGroupUsersPartial = true;
                    }

                    return $collsfSocialGroupUsers;
                }

                if($partial && $this->collsfSocialGroupUsers) {
                    foreach($this->collsfSocialGroupUsers as $obj) {
                        if($obj->isNew()) {
                            $collsfSocialGroupUsers[] = $obj;
                        }
                    }
                }

                $this->collsfSocialGroupUsers = $collsfSocialGroupUsers;
                $this->collsfSocialGroupUsersPartial = false;
            }
        }

        return $this->collsfSocialGroupUsers;
    }

    /**
     * Sets a collection of sfSocialGroupUser objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $sfSocialGroupUsers A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setsfSocialGroupUsers(PropelCollection $sfSocialGroupUsers, PropelPDO $con = null)
    {
        $this->sfSocialGroupUsersScheduledForDeletion = $this->getsfSocialGroupUsers(new Criteria(), $con)->diff($sfSocialGroupUsers);

        foreach ($this->sfSocialGroupUsersScheduledForDeletion as $sfSocialGroupUserRemoved) {
            $sfSocialGroupUserRemoved->setsfGuardUser(null);
        }

        $this->collsfSocialGroupUsers = null;
        foreach ($sfSocialGroupUsers as $sfSocialGroupUser) {
            $this->addsfSocialGroupUser($sfSocialGroupUser);
        }

        $this->collsfSocialGroupUsers = $sfSocialGroupUsers;
        $this->collsfSocialGroupUsersPartial = false;
    }

    /**
     * Returns the number of related sfSocialGroupUser objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related sfSocialGroupUser objects.
     * @throws PropelException
     */
    public function countsfSocialGroupUsers(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collsfSocialGroupUsersPartial && !$this->isNew();
        if (null === $this->collsfSocialGroupUsers || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collsfSocialGroupUsers) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getsfSocialGroupUsers());
                }
                $query = sfSocialGroupUserQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUser($this)
                    ->count($con);
            }
        } else {
            return count($this->collsfSocialGroupUsers);
        }
    }

    /**
     * Method called to associate a sfSocialGroupUser object to this object
     * through the sfSocialGroupUser foreign key attribute.
     *
     * @param    sfSocialGroupUser $l sfSocialGroupUser
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addsfSocialGroupUser(sfSocialGroupUser $l)
    {
        if ($this->collsfSocialGroupUsers === null) {
            $this->initsfSocialGroupUsers();
            $this->collsfSocialGroupUsersPartial = true;
        }
        if (!$this->collsfSocialGroupUsers->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddsfSocialGroupUser($l);
        }

        return $this;
    }

    /**
     * @param	sfSocialGroupUser $sfSocialGroupUser The sfSocialGroupUser object to add.
     */
    protected function doAddsfSocialGroupUser($sfSocialGroupUser)
    {
        $this->collsfSocialGroupUsers[]= $sfSocialGroupUser;
        $sfSocialGroupUser->setsfGuardUser($this);
    }

    /**
     * @param	sfSocialGroupUser $sfSocialGroupUser The sfSocialGroupUser object to remove.
     */
    public function removesfSocialGroupUser($sfSocialGroupUser)
    {
        if ($this->getsfSocialGroupUsers()->contains($sfSocialGroupUser)) {
            $this->collsfSocialGroupUsers->remove($this->collsfSocialGroupUsers->search($sfSocialGroupUser));
            if (null === $this->sfSocialGroupUsersScheduledForDeletion) {
                $this->sfSocialGroupUsersScheduledForDeletion = clone $this->collsfSocialGroupUsers;
                $this->sfSocialGroupUsersScheduledForDeletion->clear();
            }
            $this->sfSocialGroupUsersScheduledForDeletion[]= $sfSocialGroupUser;
            $sfSocialGroupUser->setsfGuardUser(null);
        }
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this sfGuardUser is new, it will return
     * an empty collection; or if this sfGuardUser has previously
     * been saved, it will retrieve related sfSocialGroupUsers from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in sfGuardUser.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @param string $join_behavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return PropelObjectCollection|sfSocialGroupUser[] List of sfSocialGroupUser objects
     */
    public function getsfSocialGroupUsersJoinsfSocialGroup($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
    {
        $query = sfSocialGroupUserQuery::create(null, $criteria);
        $query->joinWith('sfSocialGroup', $join_behavior);

        return $this->getsfSocialGroupUsers($query, $con);
    }

    /**
     * Clears out the collGroupStatusComments collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addGroupStatusComments()
     */
    public function clearGroupStatusComments()
    {
        $this->collGroupStatusComments = null; // important to set this to null since that means it is uninitialized
        $this->collGroupStatusCommentsPartial = null;
    }

    /**
     * reset is the collGroupStatusComments collection loaded partially
     *
     * @return void
     */
    public function resetPartialGroupStatusComments($v = true)
    {
        $this->collGroupStatusCommentsPartial = $v;
    }

    /**
     * Initializes the collGroupStatusComments collection.
     *
     * By default this just sets the collGroupStatusComments collection to an empty array (like clearcollGroupStatusComments());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initGroupStatusComments($overrideExisting = true)
    {
        if (null !== $this->collGroupStatusComments && !$overrideExisting) {
            return;
        }
        $this->collGroupStatusComments = new PropelObjectCollection();
        $this->collGroupStatusComments->setModel('GroupStatusComment');
    }

    /**
     * Gets an array of GroupStatusComment objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|GroupStatusComment[] List of GroupStatusComment objects
     * @throws PropelException
     */
    public function getGroupStatusComments($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collGroupStatusCommentsPartial && !$this->isNew();
        if (null === $this->collGroupStatusComments || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collGroupStatusComments) {
                // return empty collection
                $this->initGroupStatusComments();
            } else {
                $collGroupStatusComments = GroupStatusCommentQuery::create(null, $criteria)
                    ->filterBysfGuardUser($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collGroupStatusCommentsPartial && count($collGroupStatusComments)) {
                      $this->initGroupStatusComments(false);

                      foreach($collGroupStatusComments as $obj) {
                        if (false == $this->collGroupStatusComments->contains($obj)) {
                          $this->collGroupStatusComments->append($obj);
                        }
                      }

                      $this->collGroupStatusCommentsPartial = true;
                    }

                    return $collGroupStatusComments;
                }

                if($partial && $this->collGroupStatusComments) {
                    foreach($this->collGroupStatusComments as $obj) {
                        if($obj->isNew()) {
                            $collGroupStatusComments[] = $obj;
                        }
                    }
                }

                $this->collGroupStatusComments = $collGroupStatusComments;
                $this->collGroupStatusCommentsPartial = false;
            }
        }

        return $this->collGroupStatusComments;
    }

    /**
     * Sets a collection of GroupStatusComment objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $groupStatusComments A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setGroupStatusComments(PropelCollection $groupStatusComments, PropelPDO $con = null)
    {
        $this->groupStatusCommentsScheduledForDeletion = $this->getGroupStatusComments(new Criteria(), $con)->diff($groupStatusComments);

        foreach ($this->groupStatusCommentsScheduledForDeletion as $groupStatusCommentRemoved) {
            $groupStatusCommentRemoved->setsfGuardUser(null);
        }

        $this->collGroupStatusComments = null;
        foreach ($groupStatusComments as $groupStatusComment) {
            $this->addGroupStatusComment($groupStatusComment);
        }

        $this->collGroupStatusComments = $groupStatusComments;
        $this->collGroupStatusCommentsPartial = false;
    }

    /**
     * Returns the number of related GroupStatusComment objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related GroupStatusComment objects.
     * @throws PropelException
     */
    public function countGroupStatusComments(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collGroupStatusCommentsPartial && !$this->isNew();
        if (null === $this->collGroupStatusComments || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collGroupStatusComments) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getGroupStatusComments());
                }
                $query = GroupStatusCommentQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUser($this)
                    ->count($con);
            }
        } else {
            return count($this->collGroupStatusComments);
        }
    }

    /**
     * Method called to associate a GroupStatusComment object to this object
     * through the GroupStatusComment foreign key attribute.
     *
     * @param    GroupStatusComment $l GroupStatusComment
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addGroupStatusComment(GroupStatusComment $l)
    {
        if ($this->collGroupStatusComments === null) {
            $this->initGroupStatusComments();
            $this->collGroupStatusCommentsPartial = true;
        }
        if (!$this->collGroupStatusComments->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddGroupStatusComment($l);
        }

        return $this;
    }

    /**
     * @param	GroupStatusComment $groupStatusComment The groupStatusComment object to add.
     */
    protected function doAddGroupStatusComment($groupStatusComment)
    {
        $this->collGroupStatusComments[]= $groupStatusComment;
        $groupStatusComment->setsfGuardUser($this);
    }

    /**
     * @param	GroupStatusComment $groupStatusComment The groupStatusComment object to remove.
     */
    public function removeGroupStatusComment($groupStatusComment)
    {
        if ($this->getGroupStatusComments()->contains($groupStatusComment)) {
            $this->collGroupStatusComments->remove($this->collGroupStatusComments->search($groupStatusComment));
            if (null === $this->groupStatusCommentsScheduledForDeletion) {
                $this->groupStatusCommentsScheduledForDeletion = clone $this->collGroupStatusComments;
                $this->groupStatusCommentsScheduledForDeletion->clear();
            }
            $this->groupStatusCommentsScheduledForDeletion[]= $groupStatusComment;
            $groupStatusComment->setsfGuardUser(null);
        }
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this sfGuardUser is new, it will return
     * an empty collection; or if this sfGuardUser has previously
     * been saved, it will retrieve related GroupStatusComments from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in sfGuardUser.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @param string $join_behavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return PropelObjectCollection|GroupStatusComment[] List of GroupStatusComment objects
     */
    public function getGroupStatusCommentsJoinGroupStatus($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
    {
        $query = GroupStatusCommentQuery::create(null, $criteria);
        $query->joinWith('GroupStatus', $join_behavior);

        return $this->getGroupStatusComments($query, $con);
    }

    /**
     * Clears out the collEventStatuss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return void
     * @see        addEventStatuss()
     */
    public function clearEventStatuss()
    {
        $this->collEventStatuss = null; // important to set this to null since that means it is uninitialized
        $this->collEventStatussPartial = null;
    }

    /**
     * reset is the collEventStatuss collection loaded partially
     *
     * @return void
     */
    public function resetPartialEventStatuss($v = true)
    {
        $this->collEventStatussPartial = $v;
    }

    /**
     * Initializes the collEventStatuss collection.
     *
     * By default this just sets the collEventStatuss collection to an empty array (like clearcollEventStatuss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param boolean $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initEventStatuss($overrideExisting = true)
    {
        if (null !== $this->collEventStatuss && !$overrideExisting) {
            return;
        }
        $this->collEventStatuss = new PropelObjectCollection();
        $this->collEventStatuss->setModel('EventStatus');
    }

    /**
     * Gets an array of EventStatus objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this sfGuardUser is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @return PropelObjectCollection|EventStatus[] List of EventStatus objects
     * @throws PropelException
     */
    public function getEventStatuss($criteria = null, PropelPDO $con = null)
    {
        $partial = $this->collEventStatussPartial && !$this->isNew();
        if (null === $this->collEventStatuss || null !== $criteria  || $partial) {
            if ($this->isNew() && null === $this->collEventStatuss) {
                // return empty collection
                $this->initEventStatuss();
            } else {
                $collEventStatuss = EventStatusQuery::create(null, $criteria)
                    ->filterBysfGuardUser($this)
                    ->find($con);
                if (null !== $criteria) {
                    if (false !== $this->collEventStatussPartial && count($collEventStatuss)) {
                      $this->initEventStatuss(false);

                      foreach($collEventStatuss as $obj) {
                        if (false == $this->collEventStatuss->contains($obj)) {
                          $this->collEventStatuss->append($obj);
                        }
                      }

                      $this->collEventStatussPartial = true;
                    }

                    return $collEventStatuss;
                }

                if($partial && $this->collEventStatuss) {
                    foreach($this->collEventStatuss as $obj) {
                        if($obj->isNew()) {
                            $collEventStatuss[] = $obj;
                        }
                    }
                }

                $this->collEventStatuss = $collEventStatuss;
                $this->collEventStatussPartial = false;
            }
        }

        return $this->collEventStatuss;
    }

    /**
     * Sets a collection of EventStatus objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param PropelCollection $eventStatuss A Propel collection.
     * @param PropelPDO $con Optional connection object
     */
    public function setEventStatuss(PropelCollection $eventStatuss, PropelPDO $con = null)
    {
        $this->eventStatussScheduledForDeletion = $this->getEventStatuss(new Criteria(), $con)->diff($eventStatuss);

        foreach ($this->eventStatussScheduledForDeletion as $eventStatusRemoved) {
            $eventStatusRemoved->setsfGuardUser(null);
        }

        $this->collEventStatuss = null;
        foreach ($eventStatuss as $eventStatus) {
            $this->addEventStatus($eventStatus);
        }

        $this->collEventStatuss = $eventStatuss;
        $this->collEventStatussPartial = false;
    }

    /**
     * Returns the number of related EventStatus objects.
     *
     * @param Criteria $criteria
     * @param boolean $distinct
     * @param PropelPDO $con
     * @return int             Count of related EventStatus objects.
     * @throws PropelException
     */
    public function countEventStatuss(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
    {
        $partial = $this->collEventStatussPartial && !$this->isNew();
        if (null === $this->collEventStatuss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collEventStatuss) {
                return 0;
            } else {
                if($partial && !$criteria) {
                    return count($this->getEventStatuss());
                }
                $query = EventStatusQuery::create(null, $criteria);
                if ($distinct) {
                    $query->distinct();
                }

                return $query
                    ->filterBysfGuardUser($this)
                    ->count($con);
            }
        } else {
            return count($this->collEventStatuss);
        }
    }

    /**
     * Method called to associate a EventStatus object to this object
     * through the EventStatus foreign key attribute.
     *
     * @param    EventStatus $l EventStatus
     * @return sfGuardUser The current object (for fluent API support)
     */
    public function addEventStatus(EventStatus $l)
    {
        if ($this->collEventStatuss === null) {
            $this->initEventStatuss();
            $this->collEventStatussPartial = true;
        }
        if (!$this->collEventStatuss->contains($l)) { // only add it if the **same** object is not already associated
            $this->doAddEventStatus($l);
        }

        return $this;
    }

    /**
     * @param	EventStatus $eventStatus The eventStatus object to add.
     */
    protected function doAddEventStatus($eventStatus)
    {
        $this->collEventStatuss[]= $eventStatus;
        $eventStatus->setsfGuardUser($this);
    }

    /**
     * @param	EventStatus $eventStatus The eventStatus object to remove.
     */
    public function removeEventStatus($eventStatus)
    {
        if ($this->getEventStatuss()->contains($eventStatus)) {
            $this->collEventStatuss->remove($this->collEventStatuss->search($eventStatus));
            if (null === $this->eventStatussScheduledForDeletion) {
                $this->eventStatussScheduledForDeletion = clone $this->collEventStatuss;
                $this->eventStatussScheduledForDeletion->clear();
            }
            $this->eventStatussScheduledForDeletion[]= $eventStatus;
            $eventStatus->setsfGuardUser(null);
        }
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this sfGuardUser is new, it will return
     * an empty collection; or if this sfGuardUser has previously
     * been saved, it will retrieve related EventStatuss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in sfGuardUser.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param PropelPDO $con optional connection object
     * @param string $join_behavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return PropelObjectCollection|EventStatus[] List of EventStatus objects
     */
    public function getEventStatussJoinsfSocialEvent($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
    {
        $query = EventStatusQuery::create(null, $criteria);
        $query->joinWith('sfSocialEvent', $join_behavior);

        return $this->getEventStatuss($query, $con);
    }

    /**
     * Clears the current object and sets all attributes to their default values
     */
    public function clear()
    {
        $this->id = null;
        $this->username = null;
        $this->algorithm = null;
        $this->salt = null;
        $this->password = null;
        $this->email = null;
        $this->password_hint = null;
        $this->created_at = null;
        $this->last_login = null;
        $this->is_active = null;
        $this->is_super_admin = null;
        $this->alreadyInSave = false;
        $this->alreadyInValidation = false;
        $this->clearAllReferences();
        $this->applyDefaultValues();
        $this->resetModified();
        $this->setNew(true);
        $this->setDeleted(false);
    }

    /**
     * Resets all references to other model objects or collections of model objects.
     *
     * This method is a user-space workaround for PHP's inability to garbage collect
     * objects with circular references (even in PHP 5.3). This is currently necessary
     * when using Propel in certain daemon or large-volumne/high-memory operations.
     *
     * @param boolean $deep Whether to also clear the references on all referrer objects.
     */
    public function clearAllReferences($deep = false)
    {
        if ($deep) {
            if ($this->collBizness) {
                foreach ($this->collBizness as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collBiznesComments) {
                foreach ($this->collBiznesComments as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collBiznesTags) {
                foreach ($this->collBiznesTags as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collBiznesFavs) {
                foreach ($this->collBiznesFavs as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collBiznesRates) {
                foreach ($this->collBiznesRates as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collAlbums) {
                foreach ($this->collAlbums as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collFriendsRelatedByUserId) {
                foreach ($this->collFriendsRelatedByUserId as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collFriendsRelatedByFriendId) {
                foreach ($this->collFriendsRelatedByFriendId as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collMessagesRelatedByFromUserid) {
                foreach ($this->collMessagesRelatedByFromUserid as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collMessagesRelatedByToUserid) {
                foreach ($this->collMessagesRelatedByToUserid as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collPhotos) {
                foreach ($this->collPhotos as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collPhotoComments) {
                foreach ($this->collPhotoComments as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collPhotoTags) {
                foreach ($this->collPhotoTags as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collPhotoFavs) {
                foreach ($this->collPhotoFavs as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collPhotoVotes) {
                foreach ($this->collPhotoVotes as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collPhotoRates) {
                foreach ($this->collPhotoRates as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collSchoolUsers) {
                foreach ($this->collSchoolUsers as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collUpdatess) {
                foreach ($this->collUpdatess as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collIgnorelistsRelatedByUserId) {
                foreach ($this->collIgnorelistsRelatedByUserId as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collIgnorelistsRelatedByIgnoredUserId) {
                foreach ($this->collIgnorelistsRelatedByIgnoredUserId as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collSessionss) {
                foreach ($this->collSessionss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collGuestsRelatedByUserId) {
                foreach ($this->collGuestsRelatedByUserId as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collGuestsRelatedByGuestId) {
                foreach ($this->collGuestsRelatedByGuestId as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collGameUsers) {
                foreach ($this->collGameUsers as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collMusics) {
                foreach ($this->collMusics as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collPlaylists) {
                foreach ($this->collPlaylists as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collPlaylistComments) {
                foreach ($this->collPlaylistComments as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collPlaylistFavs) {
                foreach ($this->collPlaylistFavs as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collYtvideoFavs) {
                foreach ($this->collYtvideoFavs as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collVideolists) {
                foreach ($this->collVideolists as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collUserLinks) {
                foreach ($this->collUserLinks as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collUserLinkComments) {
                foreach ($this->collUserLinkComments as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collsfGuardUserPermissions) {
                foreach ($this->collsfGuardUserPermissions as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collsfGuardUserGroups) {
                foreach ($this->collsfGuardUserGroups as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collsfGuardRememberKeys) {
                foreach ($this->collsfGuardRememberKeys as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collsfGuardUserProfiles) {
                foreach ($this->collsfGuardUserProfiles as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collsfGuardUserStatuss) {
                foreach ($this->collsfGuardUserStatuss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collsfGuardUserStatusComments) {
                foreach ($this->collsfGuardUserStatusComments as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collsfSocialEvents) {
                foreach ($this->collsfSocialEvents as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collsfSocialEventInvitesRelatedByUserId) {
                foreach ($this->collsfSocialEventInvitesRelatedByUserId as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collsfSocialEventInvitesRelatedByUserFrom) {
                foreach ($this->collsfSocialEventInvitesRelatedByUserFrom as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collsfSocialEventUsers) {
                foreach ($this->collsfSocialEventUsers as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collsfSocialGroups) {
                foreach ($this->collsfSocialGroups as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collsfSocialGroupInvitesRelatedByUserId) {
                foreach ($this->collsfSocialGroupInvitesRelatedByUserId as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collsfSocialGroupInvitesRelatedByUserFrom) {
                foreach ($this->collsfSocialGroupInvitesRelatedByUserFrom as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collsfSocialGroupUsers) {
                foreach ($this->collsfSocialGroupUsers as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collGroupStatusComments) {
                foreach ($this->collGroupStatusComments as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collEventStatuss) {
                foreach ($this->collEventStatuss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
        } // if ($deep)

        if ($this->collBizness instanceof PropelCollection) {
            $this->collBizness->clearIterator();
        }
        $this->collBizness = null;
        if ($this->collBiznesComments instanceof PropelCollection) {
            $this->collBiznesComments->clearIterator();
        }
        $this->collBiznesComments = null;
        if ($this->collBiznesTags instanceof PropelCollection) {
            $this->collBiznesTags->clearIterator();
        }
        $this->collBiznesTags = null;
        if ($this->collBiznesFavs instanceof PropelCollection) {
            $this->collBiznesFavs->clearIterator();
        }
        $this->collBiznesFavs = null;
        if ($this->collBiznesRates instanceof PropelCollection) {
            $this->collBiznesRates->clearIterator();
        }
        $this->collBiznesRates = null;
        if ($this->collAlbums instanceof PropelCollection) {
            $this->collAlbums->clearIterator();
        }
        $this->collAlbums = null;
        if ($this->collFriendsRelatedByUserId instanceof PropelCollection) {
            $this->collFriendsRelatedByUserId->clearIterator();
        }
        $this->collFriendsRelatedByUserId = null;
        if ($this->collFriendsRelatedByFriendId instanceof PropelCollection) {
            $this->collFriendsRelatedByFriendId->clearIterator();
        }
        $this->collFriendsRelatedByFriendId = null;
        if ($this->collMessagesRelatedByFromUserid instanceof PropelCollection) {
            $this->collMessagesRelatedByFromUserid->clearIterator();
        }
        $this->collMessagesRelatedByFromUserid = null;
        if ($this->collMessagesRelatedByToUserid instanceof PropelCollection) {
            $this->collMessagesRelatedByToUserid->clearIterator();
        }
        $this->collMessagesRelatedByToUserid = null;
        if ($this->collPhotos instanceof PropelCollection) {
            $this->collPhotos->clearIterator();
        }
        $this->collPhotos = null;
        if ($this->collPhotoComments instanceof PropelCollection) {
            $this->collPhotoComments->clearIterator();
        }
        $this->collPhotoComments = null;
        if ($this->collPhotoTags instanceof PropelCollection) {
            $this->collPhotoTags->clearIterator();
        }
        $this->collPhotoTags = null;
        if ($this->collPhotoFavs instanceof PropelCollection) {
            $this->collPhotoFavs->clearIterator();
        }
        $this->collPhotoFavs = null;
        if ($this->collPhotoVotes instanceof PropelCollection) {
            $this->collPhotoVotes->clearIterator();
        }
        $this->collPhotoVotes = null;
        if ($this->collPhotoRates instanceof PropelCollection) {
            $this->collPhotoRates->clearIterator();
        }
        $this->collPhotoRates = null;
        if ($this->collSchoolUsers instanceof PropelCollection) {
            $this->collSchoolUsers->clearIterator();
        }
        $this->collSchoolUsers = null;
        if ($this->collUpdatess instanceof PropelCollection) {
            $this->collUpdatess->clearIterator();
        }
        $this->collUpdatess = null;
        if ($this->collIgnorelistsRelatedByUserId instanceof PropelCollection) {
            $this->collIgnorelistsRelatedByUserId->clearIterator();
        }
        $this->collIgnorelistsRelatedByUserId = null;
        if ($this->collIgnorelistsRelatedByIgnoredUserId instanceof PropelCollection) {
            $this->collIgnorelistsRelatedByIgnoredUserId->clearIterator();
        }
        $this->collIgnorelistsRelatedByIgnoredUserId = null;
        if ($this->collSessionss instanceof PropelCollection) {
            $this->collSessionss->clearIterator();
        }
        $this->collSessionss = null;
        if ($this->collGuestsRelatedByUserId instanceof PropelCollection) {
            $this->collGuestsRelatedByUserId->clearIterator();
        }
        $this->collGuestsRelatedByUserId = null;
        if ($this->collGuestsRelatedByGuestId instanceof PropelCollection) {
            $this->collGuestsRelatedByGuestId->clearIterator();
        }
        $this->collGuestsRelatedByGuestId = null;
        if ($this->collGameUsers instanceof PropelCollection) {
            $this->collGameUsers->clearIterator();
        }
        $this->collGameUsers = null;
        if ($this->collMusics instanceof PropelCollection) {
            $this->collMusics->clearIterator();
        }
        $this->collMusics = null;
        if ($this->collPlaylists instanceof PropelCollection) {
            $this->collPlaylists->clearIterator();
        }
        $this->collPlaylists = null;
        if ($this->collPlaylistComments instanceof PropelCollection) {
            $this->collPlaylistComments->clearIterator();
        }
        $this->collPlaylistComments = null;
        if ($this->collPlaylistFavs instanceof PropelCollection) {
            $this->collPlaylistFavs->clearIterator();
        }
        $this->collPlaylistFavs = null;
        if ($this->collYtvideoFavs instanceof PropelCollection) {
            $this->collYtvideoFavs->clearIterator();
        }
        $this->collYtvideoFavs = null;
        if ($this->collVideolists instanceof PropelCollection) {
            $this->collVideolists->clearIterator();
        }
        $this->collVideolists = null;
        if ($this->collUserLinks instanceof PropelCollection) {
            $this->collUserLinks->clearIterator();
        }
        $this->collUserLinks = null;
        if ($this->collUserLinkComments instanceof PropelCollection) {
            $this->collUserLinkComments->clearIterator();
        }
        $this->collUserLinkComments = null;
        if ($this->collsfGuardUserPermissions instanceof PropelCollection) {
            $this->collsfGuardUserPermissions->clearIterator();
        }
        $this->collsfGuardUserPermissions = null;
        if ($this->collsfGuardUserGroups instanceof PropelCollection) {
            $this->collsfGuardUserGroups->clearIterator();
        }
        $this->collsfGuardUserGroups = null;
        if ($this->collsfGuardRememberKeys instanceof PropelCollection) {
            $this->collsfGuardRememberKeys->clearIterator();
        }
        $this->collsfGuardRememberKeys = null;
        if ($this->collsfGuardUserProfiles instanceof PropelCollection) {
            $this->collsfGuardUserProfiles->clearIterator();
        }
        $this->collsfGuardUserProfiles = null;
        if ($this->collsfGuardUserStatuss instanceof PropelCollection) {
            $this->collsfGuardUserStatuss->clearIterator();
        }
        $this->collsfGuardUserStatuss = null;
        if ($this->collsfGuardUserStatusComments instanceof PropelCollection) {
            $this->collsfGuardUserStatusComments->clearIterator();
        }
        $this->collsfGuardUserStatusComments = null;
        if ($this->collsfSocialEvents instanceof PropelCollection) {
            $this->collsfSocialEvents->clearIterator();
        }
        $this->collsfSocialEvents = null;
        if ($this->collsfSocialEventInvitesRelatedByUserId instanceof PropelCollection) {
            $this->collsfSocialEventInvitesRelatedByUserId->clearIterator();
        }
        $this->collsfSocialEventInvitesRelatedByUserId = null;
        if ($this->collsfSocialEventInvitesRelatedByUserFrom instanceof PropelCollection) {
            $this->collsfSocialEventInvitesRelatedByUserFrom->clearIterator();
        }
        $this->collsfSocialEventInvitesRelatedByUserFrom = null;
        if ($this->collsfSocialEventUsers instanceof PropelCollection) {
            $this->collsfSocialEventUsers->clearIterator();
        }
        $this->collsfSocialEventUsers = null;
        if ($this->collsfSocialGroups instanceof PropelCollection) {
            $this->collsfSocialGroups->clearIterator();
        }
        $this->collsfSocialGroups = null;
        if ($this->collsfSocialGroupInvitesRelatedByUserId instanceof PropelCollection) {
            $this->collsfSocialGroupInvitesRelatedByUserId->clearIterator();
        }
        $this->collsfSocialGroupInvitesRelatedByUserId = null;
        if ($this->collsfSocialGroupInvitesRelatedByUserFrom instanceof PropelCollection) {
            $this->collsfSocialGroupInvitesRelatedByUserFrom->clearIterator();
        }
        $this->collsfSocialGroupInvitesRelatedByUserFrom = null;
        if ($this->collsfSocialGroupUsers instanceof PropelCollection) {
            $this->collsfSocialGroupUsers->clearIterator();
        }
        $this->collsfSocialGroupUsers = null;
        if ($this->collGroupStatusComments instanceof PropelCollection) {
            $this->collGroupStatusComments->clearIterator();
        }
        $this->collGroupStatusComments = null;
        if ($this->collEventStatuss instanceof PropelCollection) {
            $this->collEventStatuss->clearIterator();
        }
        $this->collEventStatuss = null;
    }

    /**
     * return the string representation of this object
     *
     * @return string
     */
    public function __toString()
    {
        return (string) $this->exportTo(sfGuardUserPeer::DEFAULT_STRING_FORMAT);
    }

    /**
     * return true is the object is in saving state
     *
     * @return boolean
     */
    public function isAlreadyInSave()
    {
        return $this->alreadyInSave;
    }

    /**
     * Catches calls to virtual methods
     */
    public function __call($name, $params)
    {

        // symfony_behaviors behavior
        if ($callable = sfMixer::getCallable('BasesfGuardUser:' . $name))
        {
          array_unshift($params, $this);
          return call_user_func_array($callable, $params);
        }


        return parent::__call($name, $params);
    }

}
