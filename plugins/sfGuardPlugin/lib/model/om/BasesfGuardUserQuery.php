<?php


/**
 * Base class that represents a query for the 'sf_guard_user' table.
 *
 *
 *
 * This class was autogenerated by Propel 1.6.7 on:
 *
 * Fri Jan  9 05:18:53 2015
 *
 * @method sfGuardUserQuery orderById($order = Criteria::ASC) Order by the id column
 * @method sfGuardUserQuery orderByUsername($order = Criteria::ASC) Order by the username column
 * @method sfGuardUserQuery orderByAlgorithm($order = Criteria::ASC) Order by the algorithm column
 * @method sfGuardUserQuery orderBySalt($order = Criteria::ASC) Order by the salt column
 * @method sfGuardUserQuery orderByPassword($order = Criteria::ASC) Order by the password column
 * @method sfGuardUserQuery orderByEmail($order = Criteria::ASC) Order by the email column
 * @method sfGuardUserQuery orderByPasswordHint($order = Criteria::ASC) Order by the password_hint column
 * @method sfGuardUserQuery orderByCreatedAt($order = Criteria::ASC) Order by the created_at column
 * @method sfGuardUserQuery orderByLastLogin($order = Criteria::ASC) Order by the last_login column
 * @method sfGuardUserQuery orderByIsActive($order = Criteria::ASC) Order by the is_active column
 * @method sfGuardUserQuery orderByIsSuperAdmin($order = Criteria::ASC) Order by the is_super_admin column
 *
 * @method sfGuardUserQuery groupById() Group by the id column
 * @method sfGuardUserQuery groupByUsername() Group by the username column
 * @method sfGuardUserQuery groupByAlgorithm() Group by the algorithm column
 * @method sfGuardUserQuery groupBySalt() Group by the salt column
 * @method sfGuardUserQuery groupByPassword() Group by the password column
 * @method sfGuardUserQuery groupByEmail() Group by the email column
 * @method sfGuardUserQuery groupByPasswordHint() Group by the password_hint column
 * @method sfGuardUserQuery groupByCreatedAt() Group by the created_at column
 * @method sfGuardUserQuery groupByLastLogin() Group by the last_login column
 * @method sfGuardUserQuery groupByIsActive() Group by the is_active column
 * @method sfGuardUserQuery groupByIsSuperAdmin() Group by the is_super_admin column
 *
 * @method sfGuardUserQuery leftJoin($relation) Adds a LEFT JOIN clause to the query
 * @method sfGuardUserQuery rightJoin($relation) Adds a RIGHT JOIN clause to the query
 * @method sfGuardUserQuery innerJoin($relation) Adds a INNER JOIN clause to the query
 *
 * @method sfGuardUserQuery leftJoinBiznes($relationAlias = null) Adds a LEFT JOIN clause to the query using the Biznes relation
 * @method sfGuardUserQuery rightJoinBiznes($relationAlias = null) Adds a RIGHT JOIN clause to the query using the Biznes relation
 * @method sfGuardUserQuery innerJoinBiznes($relationAlias = null) Adds a INNER JOIN clause to the query using the Biznes relation
 *
 * @method sfGuardUserQuery leftJoinBiznesComment($relationAlias = null) Adds a LEFT JOIN clause to the query using the BiznesComment relation
 * @method sfGuardUserQuery rightJoinBiznesComment($relationAlias = null) Adds a RIGHT JOIN clause to the query using the BiznesComment relation
 * @method sfGuardUserQuery innerJoinBiznesComment($relationAlias = null) Adds a INNER JOIN clause to the query using the BiznesComment relation
 *
 * @method sfGuardUserQuery leftJoinBiznesTag($relationAlias = null) Adds a LEFT JOIN clause to the query using the BiznesTag relation
 * @method sfGuardUserQuery rightJoinBiznesTag($relationAlias = null) Adds a RIGHT JOIN clause to the query using the BiznesTag relation
 * @method sfGuardUserQuery innerJoinBiznesTag($relationAlias = null) Adds a INNER JOIN clause to the query using the BiznesTag relation
 *
 * @method sfGuardUserQuery leftJoinBiznesFav($relationAlias = null) Adds a LEFT JOIN clause to the query using the BiznesFav relation
 * @method sfGuardUserQuery rightJoinBiznesFav($relationAlias = null) Adds a RIGHT JOIN clause to the query using the BiznesFav relation
 * @method sfGuardUserQuery innerJoinBiznesFav($relationAlias = null) Adds a INNER JOIN clause to the query using the BiznesFav relation
 *
 * @method sfGuardUserQuery leftJoinBiznesRate($relationAlias = null) Adds a LEFT JOIN clause to the query using the BiznesRate relation
 * @method sfGuardUserQuery rightJoinBiznesRate($relationAlias = null) Adds a RIGHT JOIN clause to the query using the BiznesRate relation
 * @method sfGuardUserQuery innerJoinBiznesRate($relationAlias = null) Adds a INNER JOIN clause to the query using the BiznesRate relation
 *
 * @method sfGuardUserQuery leftJoinAlbum($relationAlias = null) Adds a LEFT JOIN clause to the query using the Album relation
 * @method sfGuardUserQuery rightJoinAlbum($relationAlias = null) Adds a RIGHT JOIN clause to the query using the Album relation
 * @method sfGuardUserQuery innerJoinAlbum($relationAlias = null) Adds a INNER JOIN clause to the query using the Album relation
 *
 * @method sfGuardUserQuery leftJoinFriendRelatedByUserId($relationAlias = null) Adds a LEFT JOIN clause to the query using the FriendRelatedByUserId relation
 * @method sfGuardUserQuery rightJoinFriendRelatedByUserId($relationAlias = null) Adds a RIGHT JOIN clause to the query using the FriendRelatedByUserId relation
 * @method sfGuardUserQuery innerJoinFriendRelatedByUserId($relationAlias = null) Adds a INNER JOIN clause to the query using the FriendRelatedByUserId relation
 *
 * @method sfGuardUserQuery leftJoinFriendRelatedByFriendId($relationAlias = null) Adds a LEFT JOIN clause to the query using the FriendRelatedByFriendId relation
 * @method sfGuardUserQuery rightJoinFriendRelatedByFriendId($relationAlias = null) Adds a RIGHT JOIN clause to the query using the FriendRelatedByFriendId relation
 * @method sfGuardUserQuery innerJoinFriendRelatedByFriendId($relationAlias = null) Adds a INNER JOIN clause to the query using the FriendRelatedByFriendId relation
 *
 * @method sfGuardUserQuery leftJoinMessageRelatedByFromUserid($relationAlias = null) Adds a LEFT JOIN clause to the query using the MessageRelatedByFromUserid relation
 * @method sfGuardUserQuery rightJoinMessageRelatedByFromUserid($relationAlias = null) Adds a RIGHT JOIN clause to the query using the MessageRelatedByFromUserid relation
 * @method sfGuardUserQuery innerJoinMessageRelatedByFromUserid($relationAlias = null) Adds a INNER JOIN clause to the query using the MessageRelatedByFromUserid relation
 *
 * @method sfGuardUserQuery leftJoinMessageRelatedByToUserid($relationAlias = null) Adds a LEFT JOIN clause to the query using the MessageRelatedByToUserid relation
 * @method sfGuardUserQuery rightJoinMessageRelatedByToUserid($relationAlias = null) Adds a RIGHT JOIN clause to the query using the MessageRelatedByToUserid relation
 * @method sfGuardUserQuery innerJoinMessageRelatedByToUserid($relationAlias = null) Adds a INNER JOIN clause to the query using the MessageRelatedByToUserid relation
 *
 * @method sfGuardUserQuery leftJoinPhoto($relationAlias = null) Adds a LEFT JOIN clause to the query using the Photo relation
 * @method sfGuardUserQuery rightJoinPhoto($relationAlias = null) Adds a RIGHT JOIN clause to the query using the Photo relation
 * @method sfGuardUserQuery innerJoinPhoto($relationAlias = null) Adds a INNER JOIN clause to the query using the Photo relation
 *
 * @method sfGuardUserQuery leftJoinPhotoComment($relationAlias = null) Adds a LEFT JOIN clause to the query using the PhotoComment relation
 * @method sfGuardUserQuery rightJoinPhotoComment($relationAlias = null) Adds a RIGHT JOIN clause to the query using the PhotoComment relation
 * @method sfGuardUserQuery innerJoinPhotoComment($relationAlias = null) Adds a INNER JOIN clause to the query using the PhotoComment relation
 *
 * @method sfGuardUserQuery leftJoinPhotoTag($relationAlias = null) Adds a LEFT JOIN clause to the query using the PhotoTag relation
 * @method sfGuardUserQuery rightJoinPhotoTag($relationAlias = null) Adds a RIGHT JOIN clause to the query using the PhotoTag relation
 * @method sfGuardUserQuery innerJoinPhotoTag($relationAlias = null) Adds a INNER JOIN clause to the query using the PhotoTag relation
 *
 * @method sfGuardUserQuery leftJoinPhotoFav($relationAlias = null) Adds a LEFT JOIN clause to the query using the PhotoFav relation
 * @method sfGuardUserQuery rightJoinPhotoFav($relationAlias = null) Adds a RIGHT JOIN clause to the query using the PhotoFav relation
 * @method sfGuardUserQuery innerJoinPhotoFav($relationAlias = null) Adds a INNER JOIN clause to the query using the PhotoFav relation
 *
 * @method sfGuardUserQuery leftJoinPhotoVote($relationAlias = null) Adds a LEFT JOIN clause to the query using the PhotoVote relation
 * @method sfGuardUserQuery rightJoinPhotoVote($relationAlias = null) Adds a RIGHT JOIN clause to the query using the PhotoVote relation
 * @method sfGuardUserQuery innerJoinPhotoVote($relationAlias = null) Adds a INNER JOIN clause to the query using the PhotoVote relation
 *
 * @method sfGuardUserQuery leftJoinPhotoRate($relationAlias = null) Adds a LEFT JOIN clause to the query using the PhotoRate relation
 * @method sfGuardUserQuery rightJoinPhotoRate($relationAlias = null) Adds a RIGHT JOIN clause to the query using the PhotoRate relation
 * @method sfGuardUserQuery innerJoinPhotoRate($relationAlias = null) Adds a INNER JOIN clause to the query using the PhotoRate relation
 *
 * @method sfGuardUserQuery leftJoinSchoolUser($relationAlias = null) Adds a LEFT JOIN clause to the query using the SchoolUser relation
 * @method sfGuardUserQuery rightJoinSchoolUser($relationAlias = null) Adds a RIGHT JOIN clause to the query using the SchoolUser relation
 * @method sfGuardUserQuery innerJoinSchoolUser($relationAlias = null) Adds a INNER JOIN clause to the query using the SchoolUser relation
 *
 * @method sfGuardUserQuery leftJoinUpdates($relationAlias = null) Adds a LEFT JOIN clause to the query using the Updates relation
 * @method sfGuardUserQuery rightJoinUpdates($relationAlias = null) Adds a RIGHT JOIN clause to the query using the Updates relation
 * @method sfGuardUserQuery innerJoinUpdates($relationAlias = null) Adds a INNER JOIN clause to the query using the Updates relation
 *
 * @method sfGuardUserQuery leftJoinIgnorelistRelatedByUserId($relationAlias = null) Adds a LEFT JOIN clause to the query using the IgnorelistRelatedByUserId relation
 * @method sfGuardUserQuery rightJoinIgnorelistRelatedByUserId($relationAlias = null) Adds a RIGHT JOIN clause to the query using the IgnorelistRelatedByUserId relation
 * @method sfGuardUserQuery innerJoinIgnorelistRelatedByUserId($relationAlias = null) Adds a INNER JOIN clause to the query using the IgnorelistRelatedByUserId relation
 *
 * @method sfGuardUserQuery leftJoinIgnorelistRelatedByIgnoredUserId($relationAlias = null) Adds a LEFT JOIN clause to the query using the IgnorelistRelatedByIgnoredUserId relation
 * @method sfGuardUserQuery rightJoinIgnorelistRelatedByIgnoredUserId($relationAlias = null) Adds a RIGHT JOIN clause to the query using the IgnorelistRelatedByIgnoredUserId relation
 * @method sfGuardUserQuery innerJoinIgnorelistRelatedByIgnoredUserId($relationAlias = null) Adds a INNER JOIN clause to the query using the IgnorelistRelatedByIgnoredUserId relation
 *
 * @method sfGuardUserQuery leftJoinSessions($relationAlias = null) Adds a LEFT JOIN clause to the query using the Sessions relation
 * @method sfGuardUserQuery rightJoinSessions($relationAlias = null) Adds a RIGHT JOIN clause to the query using the Sessions relation
 * @method sfGuardUserQuery innerJoinSessions($relationAlias = null) Adds a INNER JOIN clause to the query using the Sessions relation
 *
 * @method sfGuardUserQuery leftJoinGuestRelatedByUserId($relationAlias = null) Adds a LEFT JOIN clause to the query using the GuestRelatedByUserId relation
 * @method sfGuardUserQuery rightJoinGuestRelatedByUserId($relationAlias = null) Adds a RIGHT JOIN clause to the query using the GuestRelatedByUserId relation
 * @method sfGuardUserQuery innerJoinGuestRelatedByUserId($relationAlias = null) Adds a INNER JOIN clause to the query using the GuestRelatedByUserId relation
 *
 * @method sfGuardUserQuery leftJoinGuestRelatedByGuestId($relationAlias = null) Adds a LEFT JOIN clause to the query using the GuestRelatedByGuestId relation
 * @method sfGuardUserQuery rightJoinGuestRelatedByGuestId($relationAlias = null) Adds a RIGHT JOIN clause to the query using the GuestRelatedByGuestId relation
 * @method sfGuardUserQuery innerJoinGuestRelatedByGuestId($relationAlias = null) Adds a INNER JOIN clause to the query using the GuestRelatedByGuestId relation
 *
 * @method sfGuardUserQuery leftJoinGameUser($relationAlias = null) Adds a LEFT JOIN clause to the query using the GameUser relation
 * @method sfGuardUserQuery rightJoinGameUser($relationAlias = null) Adds a RIGHT JOIN clause to the query using the GameUser relation
 * @method sfGuardUserQuery innerJoinGameUser($relationAlias = null) Adds a INNER JOIN clause to the query using the GameUser relation
 *
 * @method sfGuardUserQuery leftJoinMusic($relationAlias = null) Adds a LEFT JOIN clause to the query using the Music relation
 * @method sfGuardUserQuery rightJoinMusic($relationAlias = null) Adds a RIGHT JOIN clause to the query using the Music relation
 * @method sfGuardUserQuery innerJoinMusic($relationAlias = null) Adds a INNER JOIN clause to the query using the Music relation
 *
 * @method sfGuardUserQuery leftJoinPlaylist($relationAlias = null) Adds a LEFT JOIN clause to the query using the Playlist relation
 * @method sfGuardUserQuery rightJoinPlaylist($relationAlias = null) Adds a RIGHT JOIN clause to the query using the Playlist relation
 * @method sfGuardUserQuery innerJoinPlaylist($relationAlias = null) Adds a INNER JOIN clause to the query using the Playlist relation
 *
 * @method sfGuardUserQuery leftJoinPlaylistComment($relationAlias = null) Adds a LEFT JOIN clause to the query using the PlaylistComment relation
 * @method sfGuardUserQuery rightJoinPlaylistComment($relationAlias = null) Adds a RIGHT JOIN clause to the query using the PlaylistComment relation
 * @method sfGuardUserQuery innerJoinPlaylistComment($relationAlias = null) Adds a INNER JOIN clause to the query using the PlaylistComment relation
 *
 * @method sfGuardUserQuery leftJoinPlaylistFav($relationAlias = null) Adds a LEFT JOIN clause to the query using the PlaylistFav relation
 * @method sfGuardUserQuery rightJoinPlaylistFav($relationAlias = null) Adds a RIGHT JOIN clause to the query using the PlaylistFav relation
 * @method sfGuardUserQuery innerJoinPlaylistFav($relationAlias = null) Adds a INNER JOIN clause to the query using the PlaylistFav relation
 *
 * @method sfGuardUserQuery leftJoinYtvideoFav($relationAlias = null) Adds a LEFT JOIN clause to the query using the YtvideoFav relation
 * @method sfGuardUserQuery rightJoinYtvideoFav($relationAlias = null) Adds a RIGHT JOIN clause to the query using the YtvideoFav relation
 * @method sfGuardUserQuery innerJoinYtvideoFav($relationAlias = null) Adds a INNER JOIN clause to the query using the YtvideoFav relation
 *
 * @method sfGuardUserQuery leftJoinVideolist($relationAlias = null) Adds a LEFT JOIN clause to the query using the Videolist relation
 * @method sfGuardUserQuery rightJoinVideolist($relationAlias = null) Adds a RIGHT JOIN clause to the query using the Videolist relation
 * @method sfGuardUserQuery innerJoinVideolist($relationAlias = null) Adds a INNER JOIN clause to the query using the Videolist relation
 *
 * @method sfGuardUserQuery leftJoinUserLink($relationAlias = null) Adds a LEFT JOIN clause to the query using the UserLink relation
 * @method sfGuardUserQuery rightJoinUserLink($relationAlias = null) Adds a RIGHT JOIN clause to the query using the UserLink relation
 * @method sfGuardUserQuery innerJoinUserLink($relationAlias = null) Adds a INNER JOIN clause to the query using the UserLink relation
 *
 * @method sfGuardUserQuery leftJoinUserLinkComment($relationAlias = null) Adds a LEFT JOIN clause to the query using the UserLinkComment relation
 * @method sfGuardUserQuery rightJoinUserLinkComment($relationAlias = null) Adds a RIGHT JOIN clause to the query using the UserLinkComment relation
 * @method sfGuardUserQuery innerJoinUserLinkComment($relationAlias = null) Adds a INNER JOIN clause to the query using the UserLinkComment relation
 *
 * @method sfGuardUserQuery leftJoinsfGuardUserPermission($relationAlias = null) Adds a LEFT JOIN clause to the query using the sfGuardUserPermission relation
 * @method sfGuardUserQuery rightJoinsfGuardUserPermission($relationAlias = null) Adds a RIGHT JOIN clause to the query using the sfGuardUserPermission relation
 * @method sfGuardUserQuery innerJoinsfGuardUserPermission($relationAlias = null) Adds a INNER JOIN clause to the query using the sfGuardUserPermission relation
 *
 * @method sfGuardUserQuery leftJoinsfGuardUserGroup($relationAlias = null) Adds a LEFT JOIN clause to the query using the sfGuardUserGroup relation
 * @method sfGuardUserQuery rightJoinsfGuardUserGroup($relationAlias = null) Adds a RIGHT JOIN clause to the query using the sfGuardUserGroup relation
 * @method sfGuardUserQuery innerJoinsfGuardUserGroup($relationAlias = null) Adds a INNER JOIN clause to the query using the sfGuardUserGroup relation
 *
 * @method sfGuardUserQuery leftJoinsfGuardRememberKey($relationAlias = null) Adds a LEFT JOIN clause to the query using the sfGuardRememberKey relation
 * @method sfGuardUserQuery rightJoinsfGuardRememberKey($relationAlias = null) Adds a RIGHT JOIN clause to the query using the sfGuardRememberKey relation
 * @method sfGuardUserQuery innerJoinsfGuardRememberKey($relationAlias = null) Adds a INNER JOIN clause to the query using the sfGuardRememberKey relation
 *
 * @method sfGuardUserQuery leftJoinsfGuardUserProfile($relationAlias = null) Adds a LEFT JOIN clause to the query using the sfGuardUserProfile relation
 * @method sfGuardUserQuery rightJoinsfGuardUserProfile($relationAlias = null) Adds a RIGHT JOIN clause to the query using the sfGuardUserProfile relation
 * @method sfGuardUserQuery innerJoinsfGuardUserProfile($relationAlias = null) Adds a INNER JOIN clause to the query using the sfGuardUserProfile relation
 *
 * @method sfGuardUserQuery leftJoinsfGuardUserStatus($relationAlias = null) Adds a LEFT JOIN clause to the query using the sfGuardUserStatus relation
 * @method sfGuardUserQuery rightJoinsfGuardUserStatus($relationAlias = null) Adds a RIGHT JOIN clause to the query using the sfGuardUserStatus relation
 * @method sfGuardUserQuery innerJoinsfGuardUserStatus($relationAlias = null) Adds a INNER JOIN clause to the query using the sfGuardUserStatus relation
 *
 * @method sfGuardUserQuery leftJoinsfGuardUserStatusComment($relationAlias = null) Adds a LEFT JOIN clause to the query using the sfGuardUserStatusComment relation
 * @method sfGuardUserQuery rightJoinsfGuardUserStatusComment($relationAlias = null) Adds a RIGHT JOIN clause to the query using the sfGuardUserStatusComment relation
 * @method sfGuardUserQuery innerJoinsfGuardUserStatusComment($relationAlias = null) Adds a INNER JOIN clause to the query using the sfGuardUserStatusComment relation
 *
 * @method sfGuardUserQuery leftJoinsfSocialEvent($relationAlias = null) Adds a LEFT JOIN clause to the query using the sfSocialEvent relation
 * @method sfGuardUserQuery rightJoinsfSocialEvent($relationAlias = null) Adds a RIGHT JOIN clause to the query using the sfSocialEvent relation
 * @method sfGuardUserQuery innerJoinsfSocialEvent($relationAlias = null) Adds a INNER JOIN clause to the query using the sfSocialEvent relation
 *
 * @method sfGuardUserQuery leftJoinsfSocialEventInviteRelatedByUserId($relationAlias = null) Adds a LEFT JOIN clause to the query using the sfSocialEventInviteRelatedByUserId relation
 * @method sfGuardUserQuery rightJoinsfSocialEventInviteRelatedByUserId($relationAlias = null) Adds a RIGHT JOIN clause to the query using the sfSocialEventInviteRelatedByUserId relation
 * @method sfGuardUserQuery innerJoinsfSocialEventInviteRelatedByUserId($relationAlias = null) Adds a INNER JOIN clause to the query using the sfSocialEventInviteRelatedByUserId relation
 *
 * @method sfGuardUserQuery leftJoinsfSocialEventInviteRelatedByUserFrom($relationAlias = null) Adds a LEFT JOIN clause to the query using the sfSocialEventInviteRelatedByUserFrom relation
 * @method sfGuardUserQuery rightJoinsfSocialEventInviteRelatedByUserFrom($relationAlias = null) Adds a RIGHT JOIN clause to the query using the sfSocialEventInviteRelatedByUserFrom relation
 * @method sfGuardUserQuery innerJoinsfSocialEventInviteRelatedByUserFrom($relationAlias = null) Adds a INNER JOIN clause to the query using the sfSocialEventInviteRelatedByUserFrom relation
 *
 * @method sfGuardUserQuery leftJoinsfSocialEventUser($relationAlias = null) Adds a LEFT JOIN clause to the query using the sfSocialEventUser relation
 * @method sfGuardUserQuery rightJoinsfSocialEventUser($relationAlias = null) Adds a RIGHT JOIN clause to the query using the sfSocialEventUser relation
 * @method sfGuardUserQuery innerJoinsfSocialEventUser($relationAlias = null) Adds a INNER JOIN clause to the query using the sfSocialEventUser relation
 *
 * @method sfGuardUserQuery leftJoinsfSocialGroup($relationAlias = null) Adds a LEFT JOIN clause to the query using the sfSocialGroup relation
 * @method sfGuardUserQuery rightJoinsfSocialGroup($relationAlias = null) Adds a RIGHT JOIN clause to the query using the sfSocialGroup relation
 * @method sfGuardUserQuery innerJoinsfSocialGroup($relationAlias = null) Adds a INNER JOIN clause to the query using the sfSocialGroup relation
 *
 * @method sfGuardUserQuery leftJoinsfSocialGroupInviteRelatedByUserId($relationAlias = null) Adds a LEFT JOIN clause to the query using the sfSocialGroupInviteRelatedByUserId relation
 * @method sfGuardUserQuery rightJoinsfSocialGroupInviteRelatedByUserId($relationAlias = null) Adds a RIGHT JOIN clause to the query using the sfSocialGroupInviteRelatedByUserId relation
 * @method sfGuardUserQuery innerJoinsfSocialGroupInviteRelatedByUserId($relationAlias = null) Adds a INNER JOIN clause to the query using the sfSocialGroupInviteRelatedByUserId relation
 *
 * @method sfGuardUserQuery leftJoinsfSocialGroupInviteRelatedByUserFrom($relationAlias = null) Adds a LEFT JOIN clause to the query using the sfSocialGroupInviteRelatedByUserFrom relation
 * @method sfGuardUserQuery rightJoinsfSocialGroupInviteRelatedByUserFrom($relationAlias = null) Adds a RIGHT JOIN clause to the query using the sfSocialGroupInviteRelatedByUserFrom relation
 * @method sfGuardUserQuery innerJoinsfSocialGroupInviteRelatedByUserFrom($relationAlias = null) Adds a INNER JOIN clause to the query using the sfSocialGroupInviteRelatedByUserFrom relation
 *
 * @method sfGuardUserQuery leftJoinsfSocialGroupUser($relationAlias = null) Adds a LEFT JOIN clause to the query using the sfSocialGroupUser relation
 * @method sfGuardUserQuery rightJoinsfSocialGroupUser($relationAlias = null) Adds a RIGHT JOIN clause to the query using the sfSocialGroupUser relation
 * @method sfGuardUserQuery innerJoinsfSocialGroupUser($relationAlias = null) Adds a INNER JOIN clause to the query using the sfSocialGroupUser relation
 *
 * @method sfGuardUserQuery leftJoinGroupStatusComment($relationAlias = null) Adds a LEFT JOIN clause to the query using the GroupStatusComment relation
 * @method sfGuardUserQuery rightJoinGroupStatusComment($relationAlias = null) Adds a RIGHT JOIN clause to the query using the GroupStatusComment relation
 * @method sfGuardUserQuery innerJoinGroupStatusComment($relationAlias = null) Adds a INNER JOIN clause to the query using the GroupStatusComment relation
 *
 * @method sfGuardUserQuery leftJoinEventStatus($relationAlias = null) Adds a LEFT JOIN clause to the query using the EventStatus relation
 * @method sfGuardUserQuery rightJoinEventStatus($relationAlias = null) Adds a RIGHT JOIN clause to the query using the EventStatus relation
 * @method sfGuardUserQuery innerJoinEventStatus($relationAlias = null) Adds a INNER JOIN clause to the query using the EventStatus relation
 *
 * @method sfGuardUser findOne(PropelPDO $con = null) Return the first sfGuardUser matching the query
 * @method sfGuardUser findOneOrCreate(PropelPDO $con = null) Return the first sfGuardUser matching the query, or a new sfGuardUser object populated from the query conditions when no match is found
 *
 * @method sfGuardUser findOneById(int $id) Return the first sfGuardUser filtered by the id column
 * @method sfGuardUser findOneByUsername(string $username) Return the first sfGuardUser filtered by the username column
 * @method sfGuardUser findOneByAlgorithm(string $algorithm) Return the first sfGuardUser filtered by the algorithm column
 * @method sfGuardUser findOneBySalt(string $salt) Return the first sfGuardUser filtered by the salt column
 * @method sfGuardUser findOneByPassword(string $password) Return the first sfGuardUser filtered by the password column
 * @method sfGuardUser findOneByEmail(string $email) Return the first sfGuardUser filtered by the email column
 * @method sfGuardUser findOneByPasswordHint(string $password_hint) Return the first sfGuardUser filtered by the password_hint column
 * @method sfGuardUser findOneByCreatedAt(string $created_at) Return the first sfGuardUser filtered by the created_at column
 * @method sfGuardUser findOneByLastLogin(string $last_login) Return the first sfGuardUser filtered by the last_login column
 * @method sfGuardUser findOneByIsActive(boolean $is_active) Return the first sfGuardUser filtered by the is_active column
 * @method sfGuardUser findOneByIsSuperAdmin(boolean $is_super_admin) Return the first sfGuardUser filtered by the is_super_admin column
 *
 * @method array findById(int $id) Return sfGuardUser objects filtered by the id column
 * @method array findByUsername(string $username) Return sfGuardUser objects filtered by the username column
 * @method array findByAlgorithm(string $algorithm) Return sfGuardUser objects filtered by the algorithm column
 * @method array findBySalt(string $salt) Return sfGuardUser objects filtered by the salt column
 * @method array findByPassword(string $password) Return sfGuardUser objects filtered by the password column
 * @method array findByEmail(string $email) Return sfGuardUser objects filtered by the email column
 * @method array findByPasswordHint(string $password_hint) Return sfGuardUser objects filtered by the password_hint column
 * @method array findByCreatedAt(string $created_at) Return sfGuardUser objects filtered by the created_at column
 * @method array findByLastLogin(string $last_login) Return sfGuardUser objects filtered by the last_login column
 * @method array findByIsActive(boolean $is_active) Return sfGuardUser objects filtered by the is_active column
 * @method array findByIsSuperAdmin(boolean $is_super_admin) Return sfGuardUser objects filtered by the is_super_admin column
 *
 * @package    propel.generator.plugins.sfGuardPlugin.lib.model.om
 */
abstract class BasesfGuardUserQuery extends ModelCriteria
{
    /**
     * Initializes internal state of BasesfGuardUserQuery object.
     *
     * @param     string $dbName The dabase name
     * @param     string $modelName The phpName of a model, e.g. 'Book'
     * @param     string $modelAlias The alias for the model in this query, e.g. 'b'
     */
    public function __construct($dbName = 'propel', $modelName = 'sfGuardUser', $modelAlias = null)
    {
        parent::__construct($dbName, $modelName, $modelAlias);
    }

    /**
     * Returns a new sfGuardUserQuery object.
     *
     * @param     string $modelAlias The alias of a model in the query
     * @param     sfGuardUserQuery|Criteria $criteria Optional Criteria to build the query from
     *
     * @return sfGuardUserQuery
     */
    public static function create($modelAlias = null, $criteria = null)
    {
        if ($criteria instanceof sfGuardUserQuery) {
            return $criteria;
        }
        $query = new sfGuardUserQuery();
        if (null !== $modelAlias) {
            $query->setModelAlias($modelAlias);
        }
        if ($criteria instanceof Criteria) {
            $query->mergeWith($criteria);
        }

        return $query;
    }

    /**
     * Find object by primary key.
     * Propel uses the instance pool to skip the database if the object exists.
     * Go fast if the query is untouched.
     *
     * <code>
     * $obj  = $c->findPk(12, $con);
     * </code>
     *
     * @param mixed $key Primary key to use for the query
     * @param     PropelPDO $con an optional connection object
     *
     * @return   sfGuardUser|sfGuardUser[]|mixed the result, formatted by the current formatter
     */
    public function findPk($key, $con = null)
    {
        if ($key === null) {
            return null;
        }
        if ((null !== ($obj = sfGuardUserPeer::getInstanceFromPool((string) $key))) && !$this->formatter) {
            // the object is alredy in the instance pool
            return $obj;
        }
        if ($con === null) {
            $con = Propel::getConnection(sfGuardUserPeer::DATABASE_NAME, Propel::CONNECTION_READ);
        }
        $this->basePreSelect($con);
        if ($this->formatter || $this->modelAlias || $this->with || $this->select
         || $this->selectColumns || $this->asColumns || $this->selectModifiers
         || $this->map || $this->having || $this->joins) {
            return $this->findPkComplex($key, $con);
        } else {
            return $this->findPkSimple($key, $con);
        }
    }

    /**
     * Find object by primary key using raw SQL to go fast.
     * Bypass doSelect() and the object formatter by using generated code.
     *
     * @param     mixed $key Primary key to use for the query
     * @param     PropelPDO $con A connection object
     *
     * @return   sfGuardUser A model object, or null if the key is not found
     * @throws   PropelException
     */
    protected function findPkSimple($key, $con)
    {
        $sql = 'SELECT `ID`, `USERNAME`, `ALGORITHM`, `SALT`, `PASSWORD`, `EMAIL`, `PASSWORD_HINT`, `CREATED_AT`, `LAST_LOGIN`, `IS_ACTIVE`, `IS_SUPER_ADMIN` FROM `sf_guard_user` WHERE `ID` = :p0';
        try {
            $stmt = $con->prepare($sql);
            $stmt->bindValue(':p0', $key, PDO::PARAM_INT);
            $stmt->execute();
        } catch (Exception $e) {
            Propel::log($e->getMessage(), Propel::LOG_ERR);
            throw new PropelException(sprintf('Unable to execute SELECT statement [%s]', $sql), $e);
        }
        $obj = null;
        if ($row = $stmt->fetch(PDO::FETCH_NUM)) {
            $obj = new sfGuardUser();
            $obj->hydrate($row);
            sfGuardUserPeer::addInstanceToPool($obj, (string) $key);
        }
        $stmt->closeCursor();

        return $obj;
    }

    /**
     * Find object by primary key.
     *
     * @param     mixed $key Primary key to use for the query
     * @param     PropelPDO $con A connection object
     *
     * @return sfGuardUser|sfGuardUser[]|mixed the result, formatted by the current formatter
     */
    protected function findPkComplex($key, $con)
    {
        // As the query uses a PK condition, no limit(1) is necessary.
        $criteria = $this->isKeepQuery() ? clone $this : $this;
        $stmt = $criteria
            ->filterByPrimaryKey($key)
            ->doSelect($con);

        return $criteria->getFormatter()->init($criteria)->formatOne($stmt);
    }

    /**
     * Find objects by primary key
     * <code>
     * $objs = $c->findPks(array(12, 56, 832), $con);
     * </code>
     * @param     array $keys Primary keys to use for the query
     * @param     PropelPDO $con an optional connection object
     *
     * @return PropelObjectCollection|sfGuardUser[]|mixed the list of results, formatted by the current formatter
     */
    public function findPks($keys, $con = null)
    {
        if ($con === null) {
            $con = Propel::getConnection($this->getDbName(), Propel::CONNECTION_READ);
        }
        $this->basePreSelect($con);
        $criteria = $this->isKeepQuery() ? clone $this : $this;
        $stmt = $criteria
            ->filterByPrimaryKeys($keys)
            ->doSelect($con);

        return $criteria->getFormatter()->init($criteria)->format($stmt);
    }

    /**
     * Filter the query by primary key
     *
     * @param     mixed $key Primary key to use for the query
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function filterByPrimaryKey($key)
    {

        return $this->addUsingAlias(sfGuardUserPeer::ID, $key, Criteria::EQUAL);
    }

    /**
     * Filter the query by a list of primary keys
     *
     * @param     array $keys The list of primary key to use for the query
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function filterByPrimaryKeys($keys)
    {

        return $this->addUsingAlias(sfGuardUserPeer::ID, $keys, Criteria::IN);
    }

    /**
     * Filter the query on the id column
     *
     * Example usage:
     * <code>
     * $query->filterById(1234); // WHERE id = 1234
     * $query->filterById(array(12, 34)); // WHERE id IN (12, 34)
     * $query->filterById(array('min' => 12)); // WHERE id > 12
     * </code>
     *
     * @param     mixed $id The value to use as filter.
     *              Use scalar values for equality.
     *              Use array values for in_array() equivalent.
     *              Use associative array('min' => $minValue, 'max' => $maxValue) for intervals.
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function filterById($id = null, $comparison = null)
    {
        if (is_array($id) && null === $comparison) {
            $comparison = Criteria::IN;
        }

        return $this->addUsingAlias(sfGuardUserPeer::ID, $id, $comparison);
    }

    /**
     * Filter the query on the username column
     *
     * Example usage:
     * <code>
     * $query->filterByUsername('fooValue');   // WHERE username = 'fooValue'
     * $query->filterByUsername('%fooValue%'); // WHERE username LIKE '%fooValue%'
     * </code>
     *
     * @param     string $username The value to use as filter.
     *              Accepts wildcards (* and % trigger a LIKE)
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function filterByUsername($username = null, $comparison = null)
    {
        if (null === $comparison) {
            if (is_array($username)) {
                $comparison = Criteria::IN;
            } elseif (preg_match('/[\%\*]/', $username)) {
                $username = str_replace('*', '%', $username);
                $comparison = Criteria::LIKE;
            }
        }

        return $this->addUsingAlias(sfGuardUserPeer::USERNAME, $username, $comparison);
    }

    /**
     * Filter the query on the algorithm column
     *
     * Example usage:
     * <code>
     * $query->filterByAlgorithm('fooValue');   // WHERE algorithm = 'fooValue'
     * $query->filterByAlgorithm('%fooValue%'); // WHERE algorithm LIKE '%fooValue%'
     * </code>
     *
     * @param     string $algorithm The value to use as filter.
     *              Accepts wildcards (* and % trigger a LIKE)
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function filterByAlgorithm($algorithm = null, $comparison = null)
    {
        if (null === $comparison) {
            if (is_array($algorithm)) {
                $comparison = Criteria::IN;
            } elseif (preg_match('/[\%\*]/', $algorithm)) {
                $algorithm = str_replace('*', '%', $algorithm);
                $comparison = Criteria::LIKE;
            }
        }

        return $this->addUsingAlias(sfGuardUserPeer::ALGORITHM, $algorithm, $comparison);
    }

    /**
     * Filter the query on the salt column
     *
     * Example usage:
     * <code>
     * $query->filterBySalt('fooValue');   // WHERE salt = 'fooValue'
     * $query->filterBySalt('%fooValue%'); // WHERE salt LIKE '%fooValue%'
     * </code>
     *
     * @param     string $salt The value to use as filter.
     *              Accepts wildcards (* and % trigger a LIKE)
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function filterBySalt($salt = null, $comparison = null)
    {
        if (null === $comparison) {
            if (is_array($salt)) {
                $comparison = Criteria::IN;
            } elseif (preg_match('/[\%\*]/', $salt)) {
                $salt = str_replace('*', '%', $salt);
                $comparison = Criteria::LIKE;
            }
        }

        return $this->addUsingAlias(sfGuardUserPeer::SALT, $salt, $comparison);
    }

    /**
     * Filter the query on the password column
     *
     * Example usage:
     * <code>
     * $query->filterByPassword('fooValue');   // WHERE password = 'fooValue'
     * $query->filterByPassword('%fooValue%'); // WHERE password LIKE '%fooValue%'
     * </code>
     *
     * @param     string $password The value to use as filter.
     *              Accepts wildcards (* and % trigger a LIKE)
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function filterByPassword($password = null, $comparison = null)
    {
        if (null === $comparison) {
            if (is_array($password)) {
                $comparison = Criteria::IN;
            } elseif (preg_match('/[\%\*]/', $password)) {
                $password = str_replace('*', '%', $password);
                $comparison = Criteria::LIKE;
            }
        }

        return $this->addUsingAlias(sfGuardUserPeer::PASSWORD, $password, $comparison);
    }

    /**
     * Filter the query on the email column
     *
     * Example usage:
     * <code>
     * $query->filterByEmail('fooValue');   // WHERE email = 'fooValue'
     * $query->filterByEmail('%fooValue%'); // WHERE email LIKE '%fooValue%'
     * </code>
     *
     * @param     string $email The value to use as filter.
     *              Accepts wildcards (* and % trigger a LIKE)
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function filterByEmail($email = null, $comparison = null)
    {
        if (null === $comparison) {
            if (is_array($email)) {
                $comparison = Criteria::IN;
            } elseif (preg_match('/[\%\*]/', $email)) {
                $email = str_replace('*', '%', $email);
                $comparison = Criteria::LIKE;
            }
        }

        return $this->addUsingAlias(sfGuardUserPeer::EMAIL, $email, $comparison);
    }

    /**
     * Filter the query on the password_hint column
     *
     * Example usage:
     * <code>
     * $query->filterByPasswordHint('fooValue');   // WHERE password_hint = 'fooValue'
     * $query->filterByPasswordHint('%fooValue%'); // WHERE password_hint LIKE '%fooValue%'
     * </code>
     *
     * @param     string $passwordHint The value to use as filter.
     *              Accepts wildcards (* and % trigger a LIKE)
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function filterByPasswordHint($passwordHint = null, $comparison = null)
    {
        if (null === $comparison) {
            if (is_array($passwordHint)) {
                $comparison = Criteria::IN;
            } elseif (preg_match('/[\%\*]/', $passwordHint)) {
                $passwordHint = str_replace('*', '%', $passwordHint);
                $comparison = Criteria::LIKE;
            }
        }

        return $this->addUsingAlias(sfGuardUserPeer::PASSWORD_HINT, $passwordHint, $comparison);
    }

    /**
     * Filter the query on the created_at column
     *
     * Example usage:
     * <code>
     * $query->filterByCreatedAt('2011-03-14'); // WHERE created_at = '2011-03-14'
     * $query->filterByCreatedAt('now'); // WHERE created_at = '2011-03-14'
     * $query->filterByCreatedAt(array('max' => 'yesterday')); // WHERE created_at > '2011-03-13'
     * </code>
     *
     * @param     mixed $createdAt The value to use as filter.
     *              Values can be integers (unix timestamps), DateTime objects, or strings.
     *              Empty strings are treated as NULL.
     *              Use scalar values for equality.
     *              Use array values for in_array() equivalent.
     *              Use associative array('min' => $minValue, 'max' => $maxValue) for intervals.
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function filterByCreatedAt($createdAt = null, $comparison = null)
    {
        if (is_array($createdAt)) {
            $useMinMax = false;
            if (isset($createdAt['min'])) {
                $this->addUsingAlias(sfGuardUserPeer::CREATED_AT, $createdAt['min'], Criteria::GREATER_EQUAL);
                $useMinMax = true;
            }
            if (isset($createdAt['max'])) {
                $this->addUsingAlias(sfGuardUserPeer::CREATED_AT, $createdAt['max'], Criteria::LESS_EQUAL);
                $useMinMax = true;
            }
            if ($useMinMax) {
                return $this;
            }
            if (null === $comparison) {
                $comparison = Criteria::IN;
            }
        }

        return $this->addUsingAlias(sfGuardUserPeer::CREATED_AT, $createdAt, $comparison);
    }

    /**
     * Filter the query on the last_login column
     *
     * Example usage:
     * <code>
     * $query->filterByLastLogin('2011-03-14'); // WHERE last_login = '2011-03-14'
     * $query->filterByLastLogin('now'); // WHERE last_login = '2011-03-14'
     * $query->filterByLastLogin(array('max' => 'yesterday')); // WHERE last_login > '2011-03-13'
     * </code>
     *
     * @param     mixed $lastLogin The value to use as filter.
     *              Values can be integers (unix timestamps), DateTime objects, or strings.
     *              Empty strings are treated as NULL.
     *              Use scalar values for equality.
     *              Use array values for in_array() equivalent.
     *              Use associative array('min' => $minValue, 'max' => $maxValue) for intervals.
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function filterByLastLogin($lastLogin = null, $comparison = null)
    {
        if (is_array($lastLogin)) {
            $useMinMax = false;
            if (isset($lastLogin['min'])) {
                $this->addUsingAlias(sfGuardUserPeer::LAST_LOGIN, $lastLogin['min'], Criteria::GREATER_EQUAL);
                $useMinMax = true;
            }
            if (isset($lastLogin['max'])) {
                $this->addUsingAlias(sfGuardUserPeer::LAST_LOGIN, $lastLogin['max'], Criteria::LESS_EQUAL);
                $useMinMax = true;
            }
            if ($useMinMax) {
                return $this;
            }
            if (null === $comparison) {
                $comparison = Criteria::IN;
            }
        }

        return $this->addUsingAlias(sfGuardUserPeer::LAST_LOGIN, $lastLogin, $comparison);
    }

    /**
     * Filter the query on the is_active column
     *
     * Example usage:
     * <code>
     * $query->filterByIsActive(true); // WHERE is_active = true
     * $query->filterByIsActive('yes'); // WHERE is_active = true
     * </code>
     *
     * @param     boolean|string $isActive The value to use as filter.
     *              Non-boolean arguments are converted using the following rules:
     *                * 1, '1', 'true',  'on',  and 'yes' are converted to boolean true
     *                * 0, '0', 'false', 'off', and 'no'  are converted to boolean false
     *              Check on string values is case insensitive (so 'FaLsE' is seen as 'false').
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function filterByIsActive($isActive = null, $comparison = null)
    {
        if (is_string($isActive)) {
            $is_active = in_array(strtolower($isActive), array('false', 'off', '-', 'no', 'n', '0', '')) ? false : true;
        }

        return $this->addUsingAlias(sfGuardUserPeer::IS_ACTIVE, $isActive, $comparison);
    }

    /**
     * Filter the query on the is_super_admin column
     *
     * Example usage:
     * <code>
     * $query->filterByIsSuperAdmin(true); // WHERE is_super_admin = true
     * $query->filterByIsSuperAdmin('yes'); // WHERE is_super_admin = true
     * </code>
     *
     * @param     boolean|string $isSuperAdmin The value to use as filter.
     *              Non-boolean arguments are converted using the following rules:
     *                * 1, '1', 'true',  'on',  and 'yes' are converted to boolean true
     *                * 0, '0', 'false', 'off', and 'no'  are converted to boolean false
     *              Check on string values is case insensitive (so 'FaLsE' is seen as 'false').
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function filterByIsSuperAdmin($isSuperAdmin = null, $comparison = null)
    {
        if (is_string($isSuperAdmin)) {
            $is_super_admin = in_array(strtolower($isSuperAdmin), array('false', 'off', '-', 'no', 'n', '0', '')) ? false : true;
        }

        return $this->addUsingAlias(sfGuardUserPeer::IS_SUPER_ADMIN, $isSuperAdmin, $comparison);
    }

    /**
     * Filter the query by a related Biznes object
     *
     * @param   Biznes|PropelObjectCollection $biznes  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterByBiznes($biznes, $comparison = null)
    {
        if ($biznes instanceof Biznes) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $biznes->getUserId(), $comparison);
        } elseif ($biznes instanceof PropelObjectCollection) {
            return $this
                ->useBiznesQuery()
                ->filterByPrimaryKeys($biznes->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterByBiznes() only accepts arguments of type Biznes or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the Biznes relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinBiznes($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('Biznes');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'Biznes');
        }

        return $this;
    }

    /**
     * Use the Biznes relation Biznes object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   BiznesQuery A secondary query class using the current class as primary query
     */
    public function useBiznesQuery($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
    {
        return $this
            ->joinBiznes($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'Biznes', 'BiznesQuery');
    }

    /**
     * Filter the query by a related BiznesComment object
     *
     * @param   BiznesComment|PropelObjectCollection $biznesComment  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterByBiznesComment($biznesComment, $comparison = null)
    {
        if ($biznesComment instanceof BiznesComment) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $biznesComment->getUserId(), $comparison);
        } elseif ($biznesComment instanceof PropelObjectCollection) {
            return $this
                ->useBiznesCommentQuery()
                ->filterByPrimaryKeys($biznesComment->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterByBiznesComment() only accepts arguments of type BiznesComment or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the BiznesComment relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinBiznesComment($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('BiznesComment');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'BiznesComment');
        }

        return $this;
    }

    /**
     * Use the BiznesComment relation BiznesComment object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   BiznesCommentQuery A secondary query class using the current class as primary query
     */
    public function useBiznesCommentQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->joinBiznesComment($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'BiznesComment', 'BiznesCommentQuery');
    }

    /**
     * Filter the query by a related BiznesTag object
     *
     * @param   BiznesTag|PropelObjectCollection $biznesTag  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterByBiznesTag($biznesTag, $comparison = null)
    {
        if ($biznesTag instanceof BiznesTag) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $biznesTag->getUserId(), $comparison);
        } elseif ($biznesTag instanceof PropelObjectCollection) {
            return $this
                ->useBiznesTagQuery()
                ->filterByPrimaryKeys($biznesTag->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterByBiznesTag() only accepts arguments of type BiznesTag or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the BiznesTag relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinBiznesTag($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('BiznesTag');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'BiznesTag');
        }

        return $this;
    }

    /**
     * Use the BiznesTag relation BiznesTag object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   BiznesTagQuery A secondary query class using the current class as primary query
     */
    public function useBiznesTagQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->joinBiznesTag($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'BiznesTag', 'BiznesTagQuery');
    }

    /**
     * Filter the query by a related BiznesFav object
     *
     * @param   BiznesFav|PropelObjectCollection $biznesFav  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterByBiznesFav($biznesFav, $comparison = null)
    {
        if ($biznesFav instanceof BiznesFav) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $biznesFav->getUserId(), $comparison);
        } elseif ($biznesFav instanceof PropelObjectCollection) {
            return $this
                ->useBiznesFavQuery()
                ->filterByPrimaryKeys($biznesFav->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterByBiznesFav() only accepts arguments of type BiznesFav or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the BiznesFav relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinBiznesFav($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('BiznesFav');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'BiznesFav');
        }

        return $this;
    }

    /**
     * Use the BiznesFav relation BiznesFav object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   BiznesFavQuery A secondary query class using the current class as primary query
     */
    public function useBiznesFavQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->joinBiznesFav($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'BiznesFav', 'BiznesFavQuery');
    }

    /**
     * Filter the query by a related BiznesRate object
     *
     * @param   BiznesRate|PropelObjectCollection $biznesRate  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterByBiznesRate($biznesRate, $comparison = null)
    {
        if ($biznesRate instanceof BiznesRate) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $biznesRate->getUserId(), $comparison);
        } elseif ($biznesRate instanceof PropelObjectCollection) {
            return $this
                ->useBiznesRateQuery()
                ->filterByPrimaryKeys($biznesRate->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterByBiznesRate() only accepts arguments of type BiznesRate or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the BiznesRate relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinBiznesRate($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('BiznesRate');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'BiznesRate');
        }

        return $this;
    }

    /**
     * Use the BiznesRate relation BiznesRate object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   BiznesRateQuery A secondary query class using the current class as primary query
     */
    public function useBiznesRateQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->joinBiznesRate($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'BiznesRate', 'BiznesRateQuery');
    }

    /**
     * Filter the query by a related Album object
     *
     * @param   Album|PropelObjectCollection $album  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterByAlbum($album, $comparison = null)
    {
        if ($album instanceof Album) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $album->getUserId(), $comparison);
        } elseif ($album instanceof PropelObjectCollection) {
            return $this
                ->useAlbumQuery()
                ->filterByPrimaryKeys($album->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterByAlbum() only accepts arguments of type Album or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the Album relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinAlbum($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('Album');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'Album');
        }

        return $this;
    }

    /**
     * Use the Album relation Album object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   AlbumQuery A secondary query class using the current class as primary query
     */
    public function useAlbumQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->joinAlbum($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'Album', 'AlbumQuery');
    }

    /**
     * Filter the query by a related Friend object
     *
     * @param   Friend|PropelObjectCollection $friend  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterByFriendRelatedByUserId($friend, $comparison = null)
    {
        if ($friend instanceof Friend) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $friend->getUserId(), $comparison);
        } elseif ($friend instanceof PropelObjectCollection) {
            return $this
                ->useFriendRelatedByUserIdQuery()
                ->filterByPrimaryKeys($friend->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterByFriendRelatedByUserId() only accepts arguments of type Friend or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the FriendRelatedByUserId relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinFriendRelatedByUserId($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('FriendRelatedByUserId');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'FriendRelatedByUserId');
        }

        return $this;
    }

    /**
     * Use the FriendRelatedByUserId relation Friend object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   FriendQuery A secondary query class using the current class as primary query
     */
    public function useFriendRelatedByUserIdQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->joinFriendRelatedByUserId($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'FriendRelatedByUserId', 'FriendQuery');
    }

    /**
     * Filter the query by a related Friend object
     *
     * @param   Friend|PropelObjectCollection $friend  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterByFriendRelatedByFriendId($friend, $comparison = null)
    {
        if ($friend instanceof Friend) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $friend->getFriendId(), $comparison);
        } elseif ($friend instanceof PropelObjectCollection) {
            return $this
                ->useFriendRelatedByFriendIdQuery()
                ->filterByPrimaryKeys($friend->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterByFriendRelatedByFriendId() only accepts arguments of type Friend or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the FriendRelatedByFriendId relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinFriendRelatedByFriendId($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('FriendRelatedByFriendId');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'FriendRelatedByFriendId');
        }

        return $this;
    }

    /**
     * Use the FriendRelatedByFriendId relation Friend object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   FriendQuery A secondary query class using the current class as primary query
     */
    public function useFriendRelatedByFriendIdQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->joinFriendRelatedByFriendId($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'FriendRelatedByFriendId', 'FriendQuery');
    }

    /**
     * Filter the query by a related Message object
     *
     * @param   Message|PropelObjectCollection $message  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterByMessageRelatedByFromUserid($message, $comparison = null)
    {
        if ($message instanceof Message) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $message->getFromUserid(), $comparison);
        } elseif ($message instanceof PropelObjectCollection) {
            return $this
                ->useMessageRelatedByFromUseridQuery()
                ->filterByPrimaryKeys($message->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterByMessageRelatedByFromUserid() only accepts arguments of type Message or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the MessageRelatedByFromUserid relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinMessageRelatedByFromUserid($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('MessageRelatedByFromUserid');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'MessageRelatedByFromUserid');
        }

        return $this;
    }

    /**
     * Use the MessageRelatedByFromUserid relation Message object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   MessageQuery A secondary query class using the current class as primary query
     */
    public function useMessageRelatedByFromUseridQuery($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
    {
        return $this
            ->joinMessageRelatedByFromUserid($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'MessageRelatedByFromUserid', 'MessageQuery');
    }

    /**
     * Filter the query by a related Message object
     *
     * @param   Message|PropelObjectCollection $message  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterByMessageRelatedByToUserid($message, $comparison = null)
    {
        if ($message instanceof Message) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $message->getToUserid(), $comparison);
        } elseif ($message instanceof PropelObjectCollection) {
            return $this
                ->useMessageRelatedByToUseridQuery()
                ->filterByPrimaryKeys($message->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterByMessageRelatedByToUserid() only accepts arguments of type Message or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the MessageRelatedByToUserid relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinMessageRelatedByToUserid($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('MessageRelatedByToUserid');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'MessageRelatedByToUserid');
        }

        return $this;
    }

    /**
     * Use the MessageRelatedByToUserid relation Message object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   MessageQuery A secondary query class using the current class as primary query
     */
    public function useMessageRelatedByToUseridQuery($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
    {
        return $this
            ->joinMessageRelatedByToUserid($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'MessageRelatedByToUserid', 'MessageQuery');
    }

    /**
     * Filter the query by a related Photo object
     *
     * @param   Photo|PropelObjectCollection $photo  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterByPhoto($photo, $comparison = null)
    {
        if ($photo instanceof Photo) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $photo->getUserId(), $comparison);
        } elseif ($photo instanceof PropelObjectCollection) {
            return $this
                ->usePhotoQuery()
                ->filterByPrimaryKeys($photo->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterByPhoto() only accepts arguments of type Photo or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the Photo relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinPhoto($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('Photo');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'Photo');
        }

        return $this;
    }

    /**
     * Use the Photo relation Photo object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   PhotoQuery A secondary query class using the current class as primary query
     */
    public function usePhotoQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->joinPhoto($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'Photo', 'PhotoQuery');
    }

    /**
     * Filter the query by a related PhotoComment object
     *
     * @param   PhotoComment|PropelObjectCollection $photoComment  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterByPhotoComment($photoComment, $comparison = null)
    {
        if ($photoComment instanceof PhotoComment) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $photoComment->getUserId(), $comparison);
        } elseif ($photoComment instanceof PropelObjectCollection) {
            return $this
                ->usePhotoCommentQuery()
                ->filterByPrimaryKeys($photoComment->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterByPhotoComment() only accepts arguments of type PhotoComment or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the PhotoComment relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinPhotoComment($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('PhotoComment');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'PhotoComment');
        }

        return $this;
    }

    /**
     * Use the PhotoComment relation PhotoComment object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   PhotoCommentQuery A secondary query class using the current class as primary query
     */
    public function usePhotoCommentQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->joinPhotoComment($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'PhotoComment', 'PhotoCommentQuery');
    }

    /**
     * Filter the query by a related PhotoTag object
     *
     * @param   PhotoTag|PropelObjectCollection $photoTag  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterByPhotoTag($photoTag, $comparison = null)
    {
        if ($photoTag instanceof PhotoTag) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $photoTag->getUserId(), $comparison);
        } elseif ($photoTag instanceof PropelObjectCollection) {
            return $this
                ->usePhotoTagQuery()
                ->filterByPrimaryKeys($photoTag->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterByPhotoTag() only accepts arguments of type PhotoTag or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the PhotoTag relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinPhotoTag($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('PhotoTag');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'PhotoTag');
        }

        return $this;
    }

    /**
     * Use the PhotoTag relation PhotoTag object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   PhotoTagQuery A secondary query class using the current class as primary query
     */
    public function usePhotoTagQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->joinPhotoTag($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'PhotoTag', 'PhotoTagQuery');
    }

    /**
     * Filter the query by a related PhotoFav object
     *
     * @param   PhotoFav|PropelObjectCollection $photoFav  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterByPhotoFav($photoFav, $comparison = null)
    {
        if ($photoFav instanceof PhotoFav) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $photoFav->getUserId(), $comparison);
        } elseif ($photoFav instanceof PropelObjectCollection) {
            return $this
                ->usePhotoFavQuery()
                ->filterByPrimaryKeys($photoFav->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterByPhotoFav() only accepts arguments of type PhotoFav or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the PhotoFav relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinPhotoFav($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('PhotoFav');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'PhotoFav');
        }

        return $this;
    }

    /**
     * Use the PhotoFav relation PhotoFav object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   PhotoFavQuery A secondary query class using the current class as primary query
     */
    public function usePhotoFavQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->joinPhotoFav($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'PhotoFav', 'PhotoFavQuery');
    }

    /**
     * Filter the query by a related PhotoVote object
     *
     * @param   PhotoVote|PropelObjectCollection $photoVote  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterByPhotoVote($photoVote, $comparison = null)
    {
        if ($photoVote instanceof PhotoVote) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $photoVote->getUserId(), $comparison);
        } elseif ($photoVote instanceof PropelObjectCollection) {
            return $this
                ->usePhotoVoteQuery()
                ->filterByPrimaryKeys($photoVote->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterByPhotoVote() only accepts arguments of type PhotoVote or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the PhotoVote relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinPhotoVote($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('PhotoVote');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'PhotoVote');
        }

        return $this;
    }

    /**
     * Use the PhotoVote relation PhotoVote object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   PhotoVoteQuery A secondary query class using the current class as primary query
     */
    public function usePhotoVoteQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->joinPhotoVote($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'PhotoVote', 'PhotoVoteQuery');
    }

    /**
     * Filter the query by a related PhotoRate object
     *
     * @param   PhotoRate|PropelObjectCollection $photoRate  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterByPhotoRate($photoRate, $comparison = null)
    {
        if ($photoRate instanceof PhotoRate) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $photoRate->getUserId(), $comparison);
        } elseif ($photoRate instanceof PropelObjectCollection) {
            return $this
                ->usePhotoRateQuery()
                ->filterByPrimaryKeys($photoRate->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterByPhotoRate() only accepts arguments of type PhotoRate or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the PhotoRate relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinPhotoRate($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('PhotoRate');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'PhotoRate');
        }

        return $this;
    }

    /**
     * Use the PhotoRate relation PhotoRate object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   PhotoRateQuery A secondary query class using the current class as primary query
     */
    public function usePhotoRateQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->joinPhotoRate($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'PhotoRate', 'PhotoRateQuery');
    }

    /**
     * Filter the query by a related SchoolUser object
     *
     * @param   SchoolUser|PropelObjectCollection $schoolUser  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterBySchoolUser($schoolUser, $comparison = null)
    {
        if ($schoolUser instanceof SchoolUser) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $schoolUser->getUserId(), $comparison);
        } elseif ($schoolUser instanceof PropelObjectCollection) {
            return $this
                ->useSchoolUserQuery()
                ->filterByPrimaryKeys($schoolUser->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterBySchoolUser() only accepts arguments of type SchoolUser or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the SchoolUser relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinSchoolUser($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('SchoolUser');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'SchoolUser');
        }

        return $this;
    }

    /**
     * Use the SchoolUser relation SchoolUser object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   SchoolUserQuery A secondary query class using the current class as primary query
     */
    public function useSchoolUserQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->joinSchoolUser($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'SchoolUser', 'SchoolUserQuery');
    }

    /**
     * Filter the query by a related Updates object
     *
     * @param   Updates|PropelObjectCollection $updates  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterByUpdates($updates, $comparison = null)
    {
        if ($updates instanceof Updates) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $updates->getUserId(), $comparison);
        } elseif ($updates instanceof PropelObjectCollection) {
            return $this
                ->useUpdatesQuery()
                ->filterByPrimaryKeys($updates->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterByUpdates() only accepts arguments of type Updates or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the Updates relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinUpdates($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('Updates');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'Updates');
        }

        return $this;
    }

    /**
     * Use the Updates relation Updates object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   UpdatesQuery A secondary query class using the current class as primary query
     */
    public function useUpdatesQuery($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
    {
        return $this
            ->joinUpdates($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'Updates', 'UpdatesQuery');
    }

    /**
     * Filter the query by a related Ignorelist object
     *
     * @param   Ignorelist|PropelObjectCollection $ignorelist  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterByIgnorelistRelatedByUserId($ignorelist, $comparison = null)
    {
        if ($ignorelist instanceof Ignorelist) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $ignorelist->getUserId(), $comparison);
        } elseif ($ignorelist instanceof PropelObjectCollection) {
            return $this
                ->useIgnorelistRelatedByUserIdQuery()
                ->filterByPrimaryKeys($ignorelist->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterByIgnorelistRelatedByUserId() only accepts arguments of type Ignorelist or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the IgnorelistRelatedByUserId relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinIgnorelistRelatedByUserId($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('IgnorelistRelatedByUserId');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'IgnorelistRelatedByUserId');
        }

        return $this;
    }

    /**
     * Use the IgnorelistRelatedByUserId relation Ignorelist object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   IgnorelistQuery A secondary query class using the current class as primary query
     */
    public function useIgnorelistRelatedByUserIdQuery($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
    {
        return $this
            ->joinIgnorelistRelatedByUserId($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'IgnorelistRelatedByUserId', 'IgnorelistQuery');
    }

    /**
     * Filter the query by a related Ignorelist object
     *
     * @param   Ignorelist|PropelObjectCollection $ignorelist  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterByIgnorelistRelatedByIgnoredUserId($ignorelist, $comparison = null)
    {
        if ($ignorelist instanceof Ignorelist) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $ignorelist->getIgnoredUserId(), $comparison);
        } elseif ($ignorelist instanceof PropelObjectCollection) {
            return $this
                ->useIgnorelistRelatedByIgnoredUserIdQuery()
                ->filterByPrimaryKeys($ignorelist->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterByIgnorelistRelatedByIgnoredUserId() only accepts arguments of type Ignorelist or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the IgnorelistRelatedByIgnoredUserId relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinIgnorelistRelatedByIgnoredUserId($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('IgnorelistRelatedByIgnoredUserId');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'IgnorelistRelatedByIgnoredUserId');
        }

        return $this;
    }

    /**
     * Use the IgnorelistRelatedByIgnoredUserId relation Ignorelist object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   IgnorelistQuery A secondary query class using the current class as primary query
     */
    public function useIgnorelistRelatedByIgnoredUserIdQuery($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
    {
        return $this
            ->joinIgnorelistRelatedByIgnoredUserId($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'IgnorelistRelatedByIgnoredUserId', 'IgnorelistQuery');
    }

    /**
     * Filter the query by a related Sessions object
     *
     * @param   Sessions|PropelObjectCollection $sessions  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterBySessions($sessions, $comparison = null)
    {
        if ($sessions instanceof Sessions) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $sessions->getUserId(), $comparison);
        } elseif ($sessions instanceof PropelObjectCollection) {
            return $this
                ->useSessionsQuery()
                ->filterByPrimaryKeys($sessions->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterBySessions() only accepts arguments of type Sessions or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the Sessions relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinSessions($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('Sessions');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'Sessions');
        }

        return $this;
    }

    /**
     * Use the Sessions relation Sessions object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   SessionsQuery A secondary query class using the current class as primary query
     */
    public function useSessionsQuery($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
    {
        return $this
            ->joinSessions($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'Sessions', 'SessionsQuery');
    }

    /**
     * Filter the query by a related Guest object
     *
     * @param   Guest|PropelObjectCollection $guest  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterByGuestRelatedByUserId($guest, $comparison = null)
    {
        if ($guest instanceof Guest) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $guest->getUserId(), $comparison);
        } elseif ($guest instanceof PropelObjectCollection) {
            return $this
                ->useGuestRelatedByUserIdQuery()
                ->filterByPrimaryKeys($guest->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterByGuestRelatedByUserId() only accepts arguments of type Guest or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the GuestRelatedByUserId relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinGuestRelatedByUserId($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('GuestRelatedByUserId');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'GuestRelatedByUserId');
        }

        return $this;
    }

    /**
     * Use the GuestRelatedByUserId relation Guest object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   GuestQuery A secondary query class using the current class as primary query
     */
    public function useGuestRelatedByUserIdQuery($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
    {
        return $this
            ->joinGuestRelatedByUserId($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'GuestRelatedByUserId', 'GuestQuery');
    }

    /**
     * Filter the query by a related Guest object
     *
     * @param   Guest|PropelObjectCollection $guest  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterByGuestRelatedByGuestId($guest, $comparison = null)
    {
        if ($guest instanceof Guest) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $guest->getGuestId(), $comparison);
        } elseif ($guest instanceof PropelObjectCollection) {
            return $this
                ->useGuestRelatedByGuestIdQuery()
                ->filterByPrimaryKeys($guest->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterByGuestRelatedByGuestId() only accepts arguments of type Guest or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the GuestRelatedByGuestId relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinGuestRelatedByGuestId($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('GuestRelatedByGuestId');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'GuestRelatedByGuestId');
        }

        return $this;
    }

    /**
     * Use the GuestRelatedByGuestId relation Guest object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   GuestQuery A secondary query class using the current class as primary query
     */
    public function useGuestRelatedByGuestIdQuery($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
    {
        return $this
            ->joinGuestRelatedByGuestId($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'GuestRelatedByGuestId', 'GuestQuery');
    }

    /**
     * Filter the query by a related GameUser object
     *
     * @param   GameUser|PropelObjectCollection $gameUser  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterByGameUser($gameUser, $comparison = null)
    {
        if ($gameUser instanceof GameUser) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $gameUser->getUserId(), $comparison);
        } elseif ($gameUser instanceof PropelObjectCollection) {
            return $this
                ->useGameUserQuery()
                ->filterByPrimaryKeys($gameUser->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterByGameUser() only accepts arguments of type GameUser or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the GameUser relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinGameUser($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('GameUser');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'GameUser');
        }

        return $this;
    }

    /**
     * Use the GameUser relation GameUser object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   GameUserQuery A secondary query class using the current class as primary query
     */
    public function useGameUserQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->joinGameUser($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'GameUser', 'GameUserQuery');
    }

    /**
     * Filter the query by a related Music object
     *
     * @param   Music|PropelObjectCollection $music  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterByMusic($music, $comparison = null)
    {
        if ($music instanceof Music) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $music->getUserId(), $comparison);
        } elseif ($music instanceof PropelObjectCollection) {
            return $this
                ->useMusicQuery()
                ->filterByPrimaryKeys($music->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterByMusic() only accepts arguments of type Music or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the Music relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinMusic($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('Music');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'Music');
        }

        return $this;
    }

    /**
     * Use the Music relation Music object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   MusicQuery A secondary query class using the current class as primary query
     */
    public function useMusicQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->joinMusic($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'Music', 'MusicQuery');
    }

    /**
     * Filter the query by a related Playlist object
     *
     * @param   Playlist|PropelObjectCollection $playlist  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterByPlaylist($playlist, $comparison = null)
    {
        if ($playlist instanceof Playlist) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $playlist->getUserId(), $comparison);
        } elseif ($playlist instanceof PropelObjectCollection) {
            return $this
                ->usePlaylistQuery()
                ->filterByPrimaryKeys($playlist->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterByPlaylist() only accepts arguments of type Playlist or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the Playlist relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinPlaylist($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('Playlist');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'Playlist');
        }

        return $this;
    }

    /**
     * Use the Playlist relation Playlist object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   PlaylistQuery A secondary query class using the current class as primary query
     */
    public function usePlaylistQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->joinPlaylist($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'Playlist', 'PlaylistQuery');
    }

    /**
     * Filter the query by a related PlaylistComment object
     *
     * @param   PlaylistComment|PropelObjectCollection $playlistComment  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterByPlaylistComment($playlistComment, $comparison = null)
    {
        if ($playlistComment instanceof PlaylistComment) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $playlistComment->getUserId(), $comparison);
        } elseif ($playlistComment instanceof PropelObjectCollection) {
            return $this
                ->usePlaylistCommentQuery()
                ->filterByPrimaryKeys($playlistComment->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterByPlaylistComment() only accepts arguments of type PlaylistComment or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the PlaylistComment relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinPlaylistComment($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('PlaylistComment');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'PlaylistComment');
        }

        return $this;
    }

    /**
     * Use the PlaylistComment relation PlaylistComment object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   PlaylistCommentQuery A secondary query class using the current class as primary query
     */
    public function usePlaylistCommentQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->joinPlaylistComment($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'PlaylistComment', 'PlaylistCommentQuery');
    }

    /**
     * Filter the query by a related PlaylistFav object
     *
     * @param   PlaylistFav|PropelObjectCollection $playlistFav  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterByPlaylistFav($playlistFav, $comparison = null)
    {
        if ($playlistFav instanceof PlaylistFav) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $playlistFav->getUserId(), $comparison);
        } elseif ($playlistFav instanceof PropelObjectCollection) {
            return $this
                ->usePlaylistFavQuery()
                ->filterByPrimaryKeys($playlistFav->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterByPlaylistFav() only accepts arguments of type PlaylistFav or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the PlaylistFav relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinPlaylistFav($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('PlaylistFav');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'PlaylistFav');
        }

        return $this;
    }

    /**
     * Use the PlaylistFav relation PlaylistFav object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   PlaylistFavQuery A secondary query class using the current class as primary query
     */
    public function usePlaylistFavQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->joinPlaylistFav($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'PlaylistFav', 'PlaylistFavQuery');
    }

    /**
     * Filter the query by a related YtvideoFav object
     *
     * @param   YtvideoFav|PropelObjectCollection $ytvideoFav  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterByYtvideoFav($ytvideoFav, $comparison = null)
    {
        if ($ytvideoFav instanceof YtvideoFav) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $ytvideoFav->getUserId(), $comparison);
        } elseif ($ytvideoFav instanceof PropelObjectCollection) {
            return $this
                ->useYtvideoFavQuery()
                ->filterByPrimaryKeys($ytvideoFav->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterByYtvideoFav() only accepts arguments of type YtvideoFav or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the YtvideoFav relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinYtvideoFav($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('YtvideoFav');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'YtvideoFav');
        }

        return $this;
    }

    /**
     * Use the YtvideoFav relation YtvideoFav object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   YtvideoFavQuery A secondary query class using the current class as primary query
     */
    public function useYtvideoFavQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->joinYtvideoFav($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'YtvideoFav', 'YtvideoFavQuery');
    }

    /**
     * Filter the query by a related Videolist object
     *
     * @param   Videolist|PropelObjectCollection $videolist  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterByVideolist($videolist, $comparison = null)
    {
        if ($videolist instanceof Videolist) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $videolist->getUserId(), $comparison);
        } elseif ($videolist instanceof PropelObjectCollection) {
            return $this
                ->useVideolistQuery()
                ->filterByPrimaryKeys($videolist->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterByVideolist() only accepts arguments of type Videolist or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the Videolist relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinVideolist($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('Videolist');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'Videolist');
        }

        return $this;
    }

    /**
     * Use the Videolist relation Videolist object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   VideolistQuery A secondary query class using the current class as primary query
     */
    public function useVideolistQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->joinVideolist($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'Videolist', 'VideolistQuery');
    }

    /**
     * Filter the query by a related UserLink object
     *
     * @param   UserLink|PropelObjectCollection $userLink  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterByUserLink($userLink, $comparison = null)
    {
        if ($userLink instanceof UserLink) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $userLink->getUserId(), $comparison);
        } elseif ($userLink instanceof PropelObjectCollection) {
            return $this
                ->useUserLinkQuery()
                ->filterByPrimaryKeys($userLink->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterByUserLink() only accepts arguments of type UserLink or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the UserLink relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinUserLink($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('UserLink');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'UserLink');
        }

        return $this;
    }

    /**
     * Use the UserLink relation UserLink object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   UserLinkQuery A secondary query class using the current class as primary query
     */
    public function useUserLinkQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->joinUserLink($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'UserLink', 'UserLinkQuery');
    }

    /**
     * Filter the query by a related UserLinkComment object
     *
     * @param   UserLinkComment|PropelObjectCollection $userLinkComment  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterByUserLinkComment($userLinkComment, $comparison = null)
    {
        if ($userLinkComment instanceof UserLinkComment) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $userLinkComment->getUserId(), $comparison);
        } elseif ($userLinkComment instanceof PropelObjectCollection) {
            return $this
                ->useUserLinkCommentQuery()
                ->filterByPrimaryKeys($userLinkComment->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterByUserLinkComment() only accepts arguments of type UserLinkComment or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the UserLinkComment relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinUserLinkComment($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('UserLinkComment');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'UserLinkComment');
        }

        return $this;
    }

    /**
     * Use the UserLinkComment relation UserLinkComment object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   UserLinkCommentQuery A secondary query class using the current class as primary query
     */
    public function useUserLinkCommentQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->joinUserLinkComment($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'UserLinkComment', 'UserLinkCommentQuery');
    }

    /**
     * Filter the query by a related sfGuardUserPermission object
     *
     * @param   sfGuardUserPermission|PropelObjectCollection $sfGuardUserPermission  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterBysfGuardUserPermission($sfGuardUserPermission, $comparison = null)
    {
        if ($sfGuardUserPermission instanceof sfGuardUserPermission) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $sfGuardUserPermission->getUserId(), $comparison);
        } elseif ($sfGuardUserPermission instanceof PropelObjectCollection) {
            return $this
                ->usesfGuardUserPermissionQuery()
                ->filterByPrimaryKeys($sfGuardUserPermission->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterBysfGuardUserPermission() only accepts arguments of type sfGuardUserPermission or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the sfGuardUserPermission relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinsfGuardUserPermission($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('sfGuardUserPermission');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'sfGuardUserPermission');
        }

        return $this;
    }

    /**
     * Use the sfGuardUserPermission relation sfGuardUserPermission object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   sfGuardUserPermissionQuery A secondary query class using the current class as primary query
     */
    public function usesfGuardUserPermissionQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->joinsfGuardUserPermission($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'sfGuardUserPermission', 'sfGuardUserPermissionQuery');
    }

    /**
     * Filter the query by a related sfGuardUserGroup object
     *
     * @param   sfGuardUserGroup|PropelObjectCollection $sfGuardUserGroup  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterBysfGuardUserGroup($sfGuardUserGroup, $comparison = null)
    {
        if ($sfGuardUserGroup instanceof sfGuardUserGroup) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $sfGuardUserGroup->getUserId(), $comparison);
        } elseif ($sfGuardUserGroup instanceof PropelObjectCollection) {
            return $this
                ->usesfGuardUserGroupQuery()
                ->filterByPrimaryKeys($sfGuardUserGroup->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterBysfGuardUserGroup() only accepts arguments of type sfGuardUserGroup or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the sfGuardUserGroup relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinsfGuardUserGroup($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('sfGuardUserGroup');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'sfGuardUserGroup');
        }

        return $this;
    }

    /**
     * Use the sfGuardUserGroup relation sfGuardUserGroup object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   sfGuardUserGroupQuery A secondary query class using the current class as primary query
     */
    public function usesfGuardUserGroupQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->joinsfGuardUserGroup($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'sfGuardUserGroup', 'sfGuardUserGroupQuery');
    }

    /**
     * Filter the query by a related sfGuardRememberKey object
     *
     * @param   sfGuardRememberKey|PropelObjectCollection $sfGuardRememberKey  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterBysfGuardRememberKey($sfGuardRememberKey, $comparison = null)
    {
        if ($sfGuardRememberKey instanceof sfGuardRememberKey) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $sfGuardRememberKey->getUserId(), $comparison);
        } elseif ($sfGuardRememberKey instanceof PropelObjectCollection) {
            return $this
                ->usesfGuardRememberKeyQuery()
                ->filterByPrimaryKeys($sfGuardRememberKey->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterBysfGuardRememberKey() only accepts arguments of type sfGuardRememberKey or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the sfGuardRememberKey relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinsfGuardRememberKey($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('sfGuardRememberKey');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'sfGuardRememberKey');
        }

        return $this;
    }

    /**
     * Use the sfGuardRememberKey relation sfGuardRememberKey object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   sfGuardRememberKeyQuery A secondary query class using the current class as primary query
     */
    public function usesfGuardRememberKeyQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->joinsfGuardRememberKey($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'sfGuardRememberKey', 'sfGuardRememberKeyQuery');
    }

    /**
     * Filter the query by a related sfGuardUserProfile object
     *
     * @param   sfGuardUserProfile|PropelObjectCollection $sfGuardUserProfile  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterBysfGuardUserProfile($sfGuardUserProfile, $comparison = null)
    {
        if ($sfGuardUserProfile instanceof sfGuardUserProfile) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $sfGuardUserProfile->getUserId(), $comparison);
        } elseif ($sfGuardUserProfile instanceof PropelObjectCollection) {
            return $this
                ->usesfGuardUserProfileQuery()
                ->filterByPrimaryKeys($sfGuardUserProfile->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterBysfGuardUserProfile() only accepts arguments of type sfGuardUserProfile or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the sfGuardUserProfile relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinsfGuardUserProfile($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('sfGuardUserProfile');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'sfGuardUserProfile');
        }

        return $this;
    }

    /**
     * Use the sfGuardUserProfile relation sfGuardUserProfile object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   sfGuardUserProfileQuery A secondary query class using the current class as primary query
     */
    public function usesfGuardUserProfileQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->joinsfGuardUserProfile($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'sfGuardUserProfile', 'sfGuardUserProfileQuery');
    }

    /**
     * Filter the query by a related sfGuardUserStatus object
     *
     * @param   sfGuardUserStatus|PropelObjectCollection $sfGuardUserStatus  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterBysfGuardUserStatus($sfGuardUserStatus, $comparison = null)
    {
        if ($sfGuardUserStatus instanceof sfGuardUserStatus) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $sfGuardUserStatus->getUserId(), $comparison);
        } elseif ($sfGuardUserStatus instanceof PropelObjectCollection) {
            return $this
                ->usesfGuardUserStatusQuery()
                ->filterByPrimaryKeys($sfGuardUserStatus->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterBysfGuardUserStatus() only accepts arguments of type sfGuardUserStatus or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the sfGuardUserStatus relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinsfGuardUserStatus($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('sfGuardUserStatus');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'sfGuardUserStatus');
        }

        return $this;
    }

    /**
     * Use the sfGuardUserStatus relation sfGuardUserStatus object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   sfGuardUserStatusQuery A secondary query class using the current class as primary query
     */
    public function usesfGuardUserStatusQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->joinsfGuardUserStatus($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'sfGuardUserStatus', 'sfGuardUserStatusQuery');
    }

    /**
     * Filter the query by a related sfGuardUserStatusComment object
     *
     * @param   sfGuardUserStatusComment|PropelObjectCollection $sfGuardUserStatusComment  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterBysfGuardUserStatusComment($sfGuardUserStatusComment, $comparison = null)
    {
        if ($sfGuardUserStatusComment instanceof sfGuardUserStatusComment) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $sfGuardUserStatusComment->getUserId(), $comparison);
        } elseif ($sfGuardUserStatusComment instanceof PropelObjectCollection) {
            return $this
                ->usesfGuardUserStatusCommentQuery()
                ->filterByPrimaryKeys($sfGuardUserStatusComment->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterBysfGuardUserStatusComment() only accepts arguments of type sfGuardUserStatusComment or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the sfGuardUserStatusComment relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinsfGuardUserStatusComment($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('sfGuardUserStatusComment');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'sfGuardUserStatusComment');
        }

        return $this;
    }

    /**
     * Use the sfGuardUserStatusComment relation sfGuardUserStatusComment object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   sfGuardUserStatusCommentQuery A secondary query class using the current class as primary query
     */
    public function usesfGuardUserStatusCommentQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->joinsfGuardUserStatusComment($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'sfGuardUserStatusComment', 'sfGuardUserStatusCommentQuery');
    }

    /**
     * Filter the query by a related sfSocialEvent object
     *
     * @param   sfSocialEvent|PropelObjectCollection $sfSocialEvent  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterBysfSocialEvent($sfSocialEvent, $comparison = null)
    {
        if ($sfSocialEvent instanceof sfSocialEvent) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $sfSocialEvent->getUserAdmin(), $comparison);
        } elseif ($sfSocialEvent instanceof PropelObjectCollection) {
            return $this
                ->usesfSocialEventQuery()
                ->filterByPrimaryKeys($sfSocialEvent->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterBysfSocialEvent() only accepts arguments of type sfSocialEvent or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the sfSocialEvent relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinsfSocialEvent($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('sfSocialEvent');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'sfSocialEvent');
        }

        return $this;
    }

    /**
     * Use the sfSocialEvent relation sfSocialEvent object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   sfSocialEventQuery A secondary query class using the current class as primary query
     */
    public function usesfSocialEventQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->joinsfSocialEvent($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'sfSocialEvent', 'sfSocialEventQuery');
    }

    /**
     * Filter the query by a related sfSocialEventInvite object
     *
     * @param   sfSocialEventInvite|PropelObjectCollection $sfSocialEventInvite  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterBysfSocialEventInviteRelatedByUserId($sfSocialEventInvite, $comparison = null)
    {
        if ($sfSocialEventInvite instanceof sfSocialEventInvite) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $sfSocialEventInvite->getUserId(), $comparison);
        } elseif ($sfSocialEventInvite instanceof PropelObjectCollection) {
            return $this
                ->usesfSocialEventInviteRelatedByUserIdQuery()
                ->filterByPrimaryKeys($sfSocialEventInvite->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterBysfSocialEventInviteRelatedByUserId() only accepts arguments of type sfSocialEventInvite or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the sfSocialEventInviteRelatedByUserId relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinsfSocialEventInviteRelatedByUserId($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('sfSocialEventInviteRelatedByUserId');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'sfSocialEventInviteRelatedByUserId');
        }

        return $this;
    }

    /**
     * Use the sfSocialEventInviteRelatedByUserId relation sfSocialEventInvite object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   sfSocialEventInviteQuery A secondary query class using the current class as primary query
     */
    public function usesfSocialEventInviteRelatedByUserIdQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->joinsfSocialEventInviteRelatedByUserId($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'sfSocialEventInviteRelatedByUserId', 'sfSocialEventInviteQuery');
    }

    /**
     * Filter the query by a related sfSocialEventInvite object
     *
     * @param   sfSocialEventInvite|PropelObjectCollection $sfSocialEventInvite  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterBysfSocialEventInviteRelatedByUserFrom($sfSocialEventInvite, $comparison = null)
    {
        if ($sfSocialEventInvite instanceof sfSocialEventInvite) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $sfSocialEventInvite->getUserFrom(), $comparison);
        } elseif ($sfSocialEventInvite instanceof PropelObjectCollection) {
            return $this
                ->usesfSocialEventInviteRelatedByUserFromQuery()
                ->filterByPrimaryKeys($sfSocialEventInvite->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterBysfSocialEventInviteRelatedByUserFrom() only accepts arguments of type sfSocialEventInvite or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the sfSocialEventInviteRelatedByUserFrom relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinsfSocialEventInviteRelatedByUserFrom($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('sfSocialEventInviteRelatedByUserFrom');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'sfSocialEventInviteRelatedByUserFrom');
        }

        return $this;
    }

    /**
     * Use the sfSocialEventInviteRelatedByUserFrom relation sfSocialEventInvite object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   sfSocialEventInviteQuery A secondary query class using the current class as primary query
     */
    public function usesfSocialEventInviteRelatedByUserFromQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->joinsfSocialEventInviteRelatedByUserFrom($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'sfSocialEventInviteRelatedByUserFrom', 'sfSocialEventInviteQuery');
    }

    /**
     * Filter the query by a related sfSocialEventUser object
     *
     * @param   sfSocialEventUser|PropelObjectCollection $sfSocialEventUser  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterBysfSocialEventUser($sfSocialEventUser, $comparison = null)
    {
        if ($sfSocialEventUser instanceof sfSocialEventUser) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $sfSocialEventUser->getUserId(), $comparison);
        } elseif ($sfSocialEventUser instanceof PropelObjectCollection) {
            return $this
                ->usesfSocialEventUserQuery()
                ->filterByPrimaryKeys($sfSocialEventUser->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterBysfSocialEventUser() only accepts arguments of type sfSocialEventUser or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the sfSocialEventUser relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinsfSocialEventUser($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('sfSocialEventUser');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'sfSocialEventUser');
        }

        return $this;
    }

    /**
     * Use the sfSocialEventUser relation sfSocialEventUser object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   sfSocialEventUserQuery A secondary query class using the current class as primary query
     */
    public function usesfSocialEventUserQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->joinsfSocialEventUser($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'sfSocialEventUser', 'sfSocialEventUserQuery');
    }

    /**
     * Filter the query by a related sfSocialGroup object
     *
     * @param   sfSocialGroup|PropelObjectCollection $sfSocialGroup  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterBysfSocialGroup($sfSocialGroup, $comparison = null)
    {
        if ($sfSocialGroup instanceof sfSocialGroup) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $sfSocialGroup->getUserAdmin(), $comparison);
        } elseif ($sfSocialGroup instanceof PropelObjectCollection) {
            return $this
                ->usesfSocialGroupQuery()
                ->filterByPrimaryKeys($sfSocialGroup->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterBysfSocialGroup() only accepts arguments of type sfSocialGroup or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the sfSocialGroup relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinsfSocialGroup($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('sfSocialGroup');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'sfSocialGroup');
        }

        return $this;
    }

    /**
     * Use the sfSocialGroup relation sfSocialGroup object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   sfSocialGroupQuery A secondary query class using the current class as primary query
     */
    public function usesfSocialGroupQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->joinsfSocialGroup($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'sfSocialGroup', 'sfSocialGroupQuery');
    }

    /**
     * Filter the query by a related sfSocialGroupInvite object
     *
     * @param   sfSocialGroupInvite|PropelObjectCollection $sfSocialGroupInvite  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterBysfSocialGroupInviteRelatedByUserId($sfSocialGroupInvite, $comparison = null)
    {
        if ($sfSocialGroupInvite instanceof sfSocialGroupInvite) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $sfSocialGroupInvite->getUserId(), $comparison);
        } elseif ($sfSocialGroupInvite instanceof PropelObjectCollection) {
            return $this
                ->usesfSocialGroupInviteRelatedByUserIdQuery()
                ->filterByPrimaryKeys($sfSocialGroupInvite->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterBysfSocialGroupInviteRelatedByUserId() only accepts arguments of type sfSocialGroupInvite or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the sfSocialGroupInviteRelatedByUserId relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinsfSocialGroupInviteRelatedByUserId($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('sfSocialGroupInviteRelatedByUserId');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'sfSocialGroupInviteRelatedByUserId');
        }

        return $this;
    }

    /**
     * Use the sfSocialGroupInviteRelatedByUserId relation sfSocialGroupInvite object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   sfSocialGroupInviteQuery A secondary query class using the current class as primary query
     */
    public function usesfSocialGroupInviteRelatedByUserIdQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->joinsfSocialGroupInviteRelatedByUserId($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'sfSocialGroupInviteRelatedByUserId', 'sfSocialGroupInviteQuery');
    }

    /**
     * Filter the query by a related sfSocialGroupInvite object
     *
     * @param   sfSocialGroupInvite|PropelObjectCollection $sfSocialGroupInvite  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterBysfSocialGroupInviteRelatedByUserFrom($sfSocialGroupInvite, $comparison = null)
    {
        if ($sfSocialGroupInvite instanceof sfSocialGroupInvite) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $sfSocialGroupInvite->getUserFrom(), $comparison);
        } elseif ($sfSocialGroupInvite instanceof PropelObjectCollection) {
            return $this
                ->usesfSocialGroupInviteRelatedByUserFromQuery()
                ->filterByPrimaryKeys($sfSocialGroupInvite->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterBysfSocialGroupInviteRelatedByUserFrom() only accepts arguments of type sfSocialGroupInvite or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the sfSocialGroupInviteRelatedByUserFrom relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinsfSocialGroupInviteRelatedByUserFrom($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('sfSocialGroupInviteRelatedByUserFrom');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'sfSocialGroupInviteRelatedByUserFrom');
        }

        return $this;
    }

    /**
     * Use the sfSocialGroupInviteRelatedByUserFrom relation sfSocialGroupInvite object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   sfSocialGroupInviteQuery A secondary query class using the current class as primary query
     */
    public function usesfSocialGroupInviteRelatedByUserFromQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->joinsfSocialGroupInviteRelatedByUserFrom($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'sfSocialGroupInviteRelatedByUserFrom', 'sfSocialGroupInviteQuery');
    }

    /**
     * Filter the query by a related sfSocialGroupUser object
     *
     * @param   sfSocialGroupUser|PropelObjectCollection $sfSocialGroupUser  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterBysfSocialGroupUser($sfSocialGroupUser, $comparison = null)
    {
        if ($sfSocialGroupUser instanceof sfSocialGroupUser) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $sfSocialGroupUser->getUserId(), $comparison);
        } elseif ($sfSocialGroupUser instanceof PropelObjectCollection) {
            return $this
                ->usesfSocialGroupUserQuery()
                ->filterByPrimaryKeys($sfSocialGroupUser->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterBysfSocialGroupUser() only accepts arguments of type sfSocialGroupUser or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the sfSocialGroupUser relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinsfSocialGroupUser($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('sfSocialGroupUser');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'sfSocialGroupUser');
        }

        return $this;
    }

    /**
     * Use the sfSocialGroupUser relation sfSocialGroupUser object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   sfSocialGroupUserQuery A secondary query class using the current class as primary query
     */
    public function usesfSocialGroupUserQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->joinsfSocialGroupUser($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'sfSocialGroupUser', 'sfSocialGroupUserQuery');
    }

    /**
     * Filter the query by a related GroupStatusComment object
     *
     * @param   GroupStatusComment|PropelObjectCollection $groupStatusComment  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterByGroupStatusComment($groupStatusComment, $comparison = null)
    {
        if ($groupStatusComment instanceof GroupStatusComment) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $groupStatusComment->getUserId(), $comparison);
        } elseif ($groupStatusComment instanceof PropelObjectCollection) {
            return $this
                ->useGroupStatusCommentQuery()
                ->filterByPrimaryKeys($groupStatusComment->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterByGroupStatusComment() only accepts arguments of type GroupStatusComment or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the GroupStatusComment relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinGroupStatusComment($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('GroupStatusComment');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'GroupStatusComment');
        }

        return $this;
    }

    /**
     * Use the GroupStatusComment relation GroupStatusComment object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   GroupStatusCommentQuery A secondary query class using the current class as primary query
     */
    public function useGroupStatusCommentQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->joinGroupStatusComment($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'GroupStatusComment', 'GroupStatusCommentQuery');
    }

    /**
     * Filter the query by a related EventStatus object
     *
     * @param   EventStatus|PropelObjectCollection $eventStatus  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   sfGuardUserQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterByEventStatus($eventStatus, $comparison = null)
    {
        if ($eventStatus instanceof EventStatus) {
            return $this
                ->addUsingAlias(sfGuardUserPeer::ID, $eventStatus->getUserId(), $comparison);
        } elseif ($eventStatus instanceof PropelObjectCollection) {
            return $this
                ->useEventStatusQuery()
                ->filterByPrimaryKeys($eventStatus->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterByEventStatus() only accepts arguments of type EventStatus or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the EventStatus relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function joinEventStatus($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('EventStatus');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'EventStatus');
        }

        return $this;
    }

    /**
     * Use the EventStatus relation EventStatus object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   EventStatusQuery A secondary query class using the current class as primary query
     */
    public function useEventStatusQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->joinEventStatus($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'EventStatus', 'EventStatusQuery');
    }

    /**
     * Exclude object from result
     *
     * @param   sfGuardUser $sfGuardUser Object to remove from the list of results
     *
     * @return sfGuardUserQuery The current query, for fluid interface
     */
    public function prune($sfGuardUser = null)
    {
        if ($sfGuardUser) {
            $this->addUsingAlias(sfGuardUserPeer::ID, $sfGuardUser->getId(), Criteria::NOT_EQUAL);
        }

        return $this;
    }

}
