diff --git a/src/plugin/urlnormalizer-basic/plugin.xml b/src/plugin/urlnormalizer-basic/plugin.xml
index fb505aa..b0563e8 100644
--- a/src/plugin/urlnormalizer-basic/plugin.xml
+++ b/src/plugin/urlnormalizer-basic/plugin.xml
@@ -18,7 +18,7 @@
 <plugin
    id="urlnormalizer-basic"
    name="Basic URL Normalizer"
-   version="1.0.0"
+   version="1.1.0"
    provider-name="nutch.org">
 
    <runtime>
diff --git a/src/plugin/urlnormalizer-basic/src/java/org/apache/nutch/net/urlnormalizer/basic/BasicURLNormalizer.java b/src/plugin/urlnormalizer-basic/src/java/org/apache/nutch/net/urlnormalizer/basic/BasicURLNormalizer.java
index 624569d..ead53f2 100644
--- a/src/plugin/urlnormalizer-basic/src/java/org/apache/nutch/net/urlnormalizer/basic/BasicURLNormalizer.java
+++ b/src/plugin/urlnormalizer-basic/src/java/org/apache/nutch/net/urlnormalizer/basic/BasicURLNormalizer.java
@@ -19,7 +19,7 @@ package org.apache.nutch.net.urlnormalizer.basic;
 
 import java.net.URL;
 import java.net.MalformedURLException;
-
+import java.nio.charset.Charset;
 // Commons Logging imports
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -45,11 +45,14 @@ public class BasicURLNormalizer extends Configured implements URLNormalizer {
     private final Rule leadingRelativePathRule;
     private final Rule currentPathRule;
     private final Rule adjacentSlashRule;
-
     private Configuration conf;
+    private Rule unescapeRule = null;
+    private Charset utf8;    
 
     public BasicURLNormalizer() {
       try {
+        // charset used for encoding URLs before escaping
+        utf8 = Charset.forName("UTF-8");
         // this pattern tries to find spots like "/xx/../" in the url, which
         // could be replaced by "/" xx consists of chars, different then "/"
         // (slash) and needs to have at least one char different from "."
@@ -79,6 +82,10 @@ public class BasicURLNormalizer extends Configured implements URLNormalizer {
         adjacentSlashRule.pattern = (Perl5Pattern)      
           compiler.compile("/{2,}", Perl5Compiler.READ_ONLY_MASK);     
         adjacentSlashRule.substitution = new Perl5Substitution("/");
+    
+        // this pattern tries to find spots like "%34" in the url,
+        unescapeRule = new Rule();
+        unescapeRule.pattern = (Perl5Pattern)compiler.compile("%([0-9A-Fa-f]{2})", Perl5Compiler.READ_ONLY_MASK);
         
       } catch (MalformedPatternException e) {
         throw new RuntimeException(e);
@@ -91,6 +98,10 @@ public class BasicURLNormalizer extends Configured implements URLNormalizer {
             return urlString;
 
         urlString = urlString.trim();                 // remove extra spaces
+  
+        urlString = unescapeURL(urlString);           // decode %nn characters
+	urlString = urlString.replace(" ","%20");     // replace spaces in URL
+	urlString = escapeURL(urlString);	      // encode non ascii characters
 
         URL url = new URL(urlString);
 
@@ -196,6 +207,60 @@ public class BasicURLNormalizer extends Configured implements URLNormalizer {
         return fileWorkCopy;
     }
 
+    /**
+        Remove % encoding from URL in range 0x20-0x80 exclusive
+		/ and # are not decoded
+     */
+    private String unescapeURL(String file) {
+    	StringBuilder sb = new StringBuilder();
+    	PatternMatcherInput in = new PatternMatcherInput(file);
+    	Perl5Matcher matcher = (Perl5Matcher)matchers.get();
+    	int end = -1;
+    	int letter;
+
+    	while(matcher.contains(in, unescapeRule.pattern)) {
+    		MatchResult res;
+
+    		res = matcher.getMatch();
+           	sb.append(file.substring(end + 1, res.beginOffset(0)));
+    		letter = Integer.valueOf(res.group(1),16);
+    		if (letter <= 32 || letter > 127 || letter == 0x23 || letter == 0x2f ) 
+		{
+    			sb.append(res.group(0).toUpperCase());
+    		} else {
+    			sb.append(new Character((char)letter));
+    		}
+    		end = res.beginOffset(0)+2;
+    	}
+    	letter = file.length();
+    	if ( end <= letter - 1 ) sb.append(file.substring(end + 1, letter));
+
+    	return sb.toString();
+    }
+
+    /**
+        Convert URL from unicode to UTF-8 and escape high bit and control chars
+
+	control characters at URL sides will not currently reach this
+	function because String.trim() is called on URL before sending it here.
+    */
+    private String escapeURL(String URL) {
+     StringBuilder sb=new StringBuilder(URL.length());
+
+	for (byte b: URL.getBytes(utf8)) {
+	   String hex;
+	   if ( b < 32 ) {
+	      sb.append('%');
+	      hex = Integer.toHexString(b & 0xFF).toUpperCase();
+	      if ( hex.length() % 2 != 0 )
+	        sb.append('0');
+	      sb.append(hex);
+	   } else {
+	     sb.append((char)b);
+	   }
+	}
+	return sb.toString();
+    }
 
     /**
      * Class which holds a compiled pattern and its corresponding substition
diff --git a/src/plugin/urlnormalizer-basic/src/test/org/apache/nutch/net/urlnormalizer/basic/TestBasicURLNormalizer.java b/src/plugin/urlnormalizer-basic/src/test/org/apache/nutch/net/urlnormalizer/basic/TestBasicURLNormalizer.java
index d930816..a964696 100644
--- a/src/plugin/urlnormalizer-basic/src/test/org/apache/nutch/net/urlnormalizer/basic/TestBasicURLNormalizer.java
+++ b/src/plugin/urlnormalizer-basic/src/test/org/apache/nutch/net/urlnormalizer/basic/TestBasicURLNormalizer.java
@@ -56,6 +56,46 @@ public class TestBasicURLNormalizer extends TestCase {
     // check that references are removed
     normalizeTest("http://foo.com/foo.html#ref", "http://foo.com/foo.html");
 
+    // check that % encoding is normalized
+    normalizeTest("http://foo.com/%66oo.html", "http://foo.com/foo.html");
+
+    // check that % encoding works correctly at end of URL
+    normalizeTest("http://foo.com/%66oo.htm%6c", "http://foo.com/foo.html");
+    normalizeTest("http://foo.com/%66oo.ht%6dl", "http://foo.com/foo.html");
+
+    // check that % decoder do not overlap strings
+    normalizeTest("http://foo.com/%66oo.ht%6d%6c", "http://foo.com/foo.html");
+    
+    // check that % decoder leaves high bit chars alone
+    normalizeTest("http://foo.com/%66oo.htm%C0", "http://foo.com/foo.htm%C0");
+
+    // check that % decoder leaves control chars alone
+    normalizeTest("http://foo.com/%66oo.htm%1A", "http://foo.com/foo.htm%1A");
+
+    // check that % decoder converts to upper case letters
+    normalizeTest("http://foo.com/%66oo.htm%c0", "http://foo.com/foo.htm%C0");
+
+    // check that % decoder leaves encoded spaces alone
+    normalizeTest("http://foo.com/you%20too.html", "http://foo.com/you%20too.html");
+
+    // check that spaces are encoded into %20
+    normalizeTest("http://foo.com/you too.html", "http://foo.com/you%20too.html");
+
+    // check that encoded # are not decoded
+    normalizeTest("http://foo.com/file.html%23cz", "http://foo.com/file.html%23cz");
+
+    // check that encoded / are not decoded
+    normalizeTest("http://foo.com/fast/dir%2fcz", "http://foo.com/fast/dir%2Fcz");
+
+    // check that control chars are encoded
+    normalizeTest("http://foo.com/\u001a!", "http://foo.com/%1A!");
+
+    // check that control chars are always encoded into 2 digits
+    normalizeTest("http://foo.com/\u0001!", "http://foo.com/%01!");
+
+    // check encoding of spanish chars
+    normalizeTest("http://mydomain.com/en Espa\u00F1ol.aspx", "http://mydomain.com/en%20Espa%C3%B1ol.aspx");
+
     //     // check that encoding is normalized
     //     normalizeTest("http://foo.com/%66oo.html", "http://foo.com/foo.html");
 
@@ -106,6 +146,7 @@ public class TestBasicURLNormalizer extends TestCase {
   }
 
   private void normalizeTest(String weird, String normal) throws Exception {
+    System.out.println("in="+weird+" out="+normalizer.normalize(weird, URLNormalizers.SCOPE_DEFAULT));
     assertEquals(normal, normalizer.normalize(weird, URLNormalizers.SCOPE_DEFAULT));
   }
 
@@ -116,4 +157,4 @@ public class TestBasicURLNormalizer extends TestCase {
 
 
 
-}
\ No newline at end of file
+}
